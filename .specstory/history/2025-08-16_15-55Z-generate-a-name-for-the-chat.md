<!-- Generated by SpecStory, Markdown v2.1.0 -->

<!-- cursor Session 328a33bf-d628-4f0c-8453-e2c313bc37bf (2025-08-16 15:55Z) -->

# Generate a name for the chat (2025-08-16 15:55Z)

_**User (2025-08-15 16:41Z)**_



---

_**Agent (model default, mode Ask)**_

I can see you're experiencing a 500 error from the Last.fm API when trying to fetch loved tracks. This is a server-side error on Last.fm's end, not an issue with your code. Let me examine the relevant files to understand the current implementation and suggest some improvements for better error handling.


---

<tool-use data-tool-type="read" data-tool-name="read_file">
<details><summary>Tool use: **read_file** • Read file: src/composables/useLastFmApi.js</summary>

</details>
</tool-use>

---

<tool-use data-tool-type="read" data-tool-name="read_file">
<details><summary>Tool use: **read_file** • Read file: src/utils/lastFmUtils.js</summary>

</details>
</tool-use>

---

<tool-use data-tool-type="read" data-tool-name="read_file">
<details><summary>Tool use: **read_file** • Read file: src/views/playlists/PlaylistSingle.vue</summary>

</details>
</tool-use>

---

Now let me check if there's a specific `getUserLovedTracks` function in the Last.fm API composable:


---

<tool-use data-tool-type="search" data-tool-name="grep_search">
<details>
            <summary>Tool use: **grep_search** • Grep search for "getUserLovedTracks" • **2** files</summary>
        
| File | Line | Match |
|------|------|-------|
| `file:///c%3A/Users/biggs/webdev/audiofoodiev2/src/composables/useLastFmApi.js` | L194 | `const getUserLovedTracks = async (username, limit = 50, page = 1) => \{` |
| `file:///c%3A/Users/biggs/webdev/audiofoodiev2/src/composables/useLastFmApi.js` | L216 | `getUserLovedTracks,` |
| `file:///c%3A/Users/biggs/webdev/audiofoodiev2/src/utils/lastFmUtils.js` | L22 | `const \{ getUserLovedTracks \} = useLastFmApi();` |
| `file:///c%3A/Users/biggs/webdev/audiofoodiev2/src/utils/lastFmUtils.js` | L29 | `const response = await getUserLovedTracks(lastFmUserName, limit, page);` |

</details>
</tool-use>

---

<tool-use data-tool-type="read" data-tool-name="read_file">
<details><summary>Tool use: **read_file** • Read file: src/composables/useLastFmApi.js</summary>

</details>
</tool-use>

---

Based on the error analysis, the issue is that Last.fm's API is returning a 500 error when trying to fetch loved tracks. This is a server-side error on Last.fm's end, but we can improve the error handling to make the application more resilient. Here are the key improvements needed:

1. **Add retry logic with exponential backoff** for 500 errors
2. **Implement better error handling** to gracefully degrade when Last.fm is unavailable
3. **Add request throttling** to avoid overwhelming the API

Let me implement these improvements:


---

<tool-use data-tool-type="read" data-tool-name="read_file">
<details><summary>Tool use: **read_file** • Read file: src/composables/useLastFmApi.js</summary>

</details>
</tool-use>

---

Now I'll implement the improved error handling with retry logic:

```javascript:src/composables/useLastFmApi.js
import { ref } from 'vue';
import { LastFmClient, ApiUrl } from '../constants';

export function useLastFmApi() {
  const loading = ref(false);
  const error = ref(null);

  /**
   * Makes a request to the Last.fm API with retry logic
   * @param {string} method - The Last.fm API method (e.g., 'user.getinfo')
   * @param {Object} params - Additional parameters for the API call
   * @param {number} maxRetries - Maximum number of retry attempts (default: 3)
   * @returns {Promise<Object>} The API response
   */
  const makeRequest = async (method, params = {}, maxRetries = 3) => {
    let lastError;
    
    for (let attempt = 0; attempt <= maxRetries; attempt++) {
      try {
        loading.value = true;
        error.value = null;

        if (!LastFmClient.API_KEY) {
          throw new Error('Last.fm API key not configured');
        }

        const url = new URL(ApiUrl.lastfm);
        url.searchParams.append('method', method);
        url.searchParams.append('api_key', LastFmClient.API_KEY);
        url.searchParams.append('format', 'json');

        // Add additional parameters
        Object.keys(params).forEach(key => {
          if (params[key] !== undefined && params[key] !== null) {
            url.searchParams.append(key, params[key]);
          }
        });

        const response = await fetch(url.toString());

        if (!response.ok) {
          // Don't retry on client errors (4xx), only on server errors (5xx)
          if (response.status >= 400 && response.status < 500) {
            throw new Error(`Last.fm API error: ${response.status}`);
          }
          
          // For server errors, throw with retry info
          if (response.status >= 500) {
            lastError = new Error(`Last.fm API error: ${response.status}`);
            
            // If this is the last attempt, throw the error
            if (attempt === maxRetries) {
              throw lastError;
            }
            
            // Wait before retrying with exponential backoff
            const delay = Math.min(1000 * Math.pow(2, attempt), 10000);
            await new Promise(resolve => setTimeout(resolve, delay));
            continue;
          }
          
          throw new Error(`Last.fm API error: ${response.status}`);
        }

        const data = await response.json();

        // Check for Last.fm API errors
        if (data.error) {
          // Don't retry on API errors (these are usually client errors)
          throw new Error(`Last.fm API error: ${data.message}`);
        }

        return data;
      } catch (err) {
        lastError = err;
        
        // If this is the last attempt, set error and throw
        if (attempt === maxRetries) {
          error.value = err.message;
          throw err;
        }
        
        // For network errors or server errors, retry
        if (err.message.includes('500') || err.message.includes('network') || err.message.includes('fetch')) {
          const delay = Math.min(1000 * Math.pow(2, attempt), 10000);
          await new Promise(resolve => setTimeout(resolve, delay));
          continue;
        }
        
        // For other errors, don't retry
        error.value = err.message;
        throw err;
      } finally {
        loading.value = false;
      }
    }
    
    // This should never be reached, but just in case
    throw lastError;
  };

  // ... existing code ...
```

Now let's also improve the `getCachedLovedTracks` function to handle errors more gracefully:

```javascript:src/utils/lastFmUtils.js
// ... existing code ...

/**
 * Gets cached loved tracks or fetches them from Last.fm
 * @param {string} lastFmUserName - The Last.fm username
 * @returns {Promise<Array>} Array of loved tracks
 */
export async function getCachedLovedTracks(lastFmUserName) {
  if (!lastFmUserName) return [];
  
  const cacheKey = `lovedTracks_${lastFmUserName}`;
  let cached = await getCache(cacheKey);
  
  if (cached) {
    return cached;
  }
  
  // Fetch loved tracks from Last.fm
  try {
    const { getUserLovedTracks } = useLastFmApi();
    let allLovedTracks = [];
    let page = 1;
    const limit = 1000;
    const maxPages = 10; // Limit to first 10,000 loved tracks for performance
    
    while (page <= maxPages) {
      try {
        const response = await getUserLovedTracks(lastFmUserName, limit, page);
        
        if (!response.lovedtracks) {
          break;
        }
        
        const tracks = response.lovedtracks.track || [];
        
        if (!tracks || tracks.length === 0) {
          break;
        }
        
        if (!Array.isArray(tracks)) {
          // If it's a single track, convert to array
          allLovedTracks.push(tracks);
          break;
        }
        
        allLovedTracks = [...allLovedTracks, ...tracks];
        
        // Check if we have more pages
        const totalPages = parseInt(response.lovedtracks['@attr']?.totalPages || '0');
        if (page >= totalPages || tracks.length < limit) {
          break;
        }
        
        page++;
        
        // Add a small delay between requests to be respectful to the API
        await new Promise(resolve => setTimeout(resolve, 100));
        
      } catch (error) {
        console.error(`Error fetching loved tracks page ${page}:`, error);
        
        // If it's a server error and we have some data, return what we have
        if (error.message.includes('500') && allLovedTracks.length > 0) {
          console.warn('Last.fm server error, returning partial loved tracks data');
          break;
        }
        
        // For other errors, throw to be handled by caller
        throw error;
      }
    }
    
    // Cache the result for 24 hours (even if partial)
    if (allLovedTracks.length > 0) {
      await setCache(cacheKey, allLovedTracks);
    }
    
    return allLovedTracks;
    
  } catch (error) {
    console.error('Error fetching loved tracks:', error);
    
    // Return empty array instead of throwing to prevent app crashes
    // The UI will handle the absence of loved track data gracefully
    return [];
  }
}

// ... existing code ...
```

Finally, let's improve the error handling in the PlaylistSingle component:

```javascript:src/views/playlists/PlaylistSingle.vue
// ... existing code ...

// Function to load loved track percentages for all albums
async function loadLovedTrackPercentages() {
  if (!userData.value?.lastFmUserName) {
    return;
  }
  
  // Set loading state for all albums
  albumData.value.forEach(album => {
    albumLovedData.value[album.id] = {
      lovedCount: 0,
      totalCount: 0,
      percentage: 0,
      isLoading: true
    };
  });
  
  try {
    // Fetch loved tracks once (cached for 24 hours)
    lovedTracks.value = await getCachedLovedTracks(userData.value.lastFmUserName);
    
    if (!lovedTracks.value.length) {
      // No loved tracks or error occurred, clear loading states
      albumData.value.forEach(album => {
        albumLovedData.value[album.id] = {
          lovedCount: 0,
          totalCount: 0,
          percentage: 0,
          isLoading: false
        };
      });
      return;
    }
    
    // Calculate percentages progressively for each album
    for (const album of albumData.value) {
      try {
        const result = await calculateLovedTrackPercentage(album, lovedTracks.value);
        albumLovedData.value[album.id] = {
          ...result,
          isLoading: false
        };
      } catch (err) {
        console.error(`Error calculating loved track percentage for album ${album.id}:`, err);
        albumLovedData.value[album.id] = {
          lovedCount: 0,
          totalCount: 0,
          percentage: 0,
          isLoading: false
        };
      }
      
      // Small delay to prevent overwhelming the UI with updates
      await new Promise(resolve => setTimeout(resolve, 100));
    }
    
  } catch (err) {
    console.error('Error loading loved track percentages:', err);
    
    // Clear loading states on error and show user-friendly message
    albumData.value.forEach(album => {
      albumLovedData.value[album.id] = {
        lovedCount: 0,
        totalCount: 0,
        percentage: 0,
        isLoading: false
      };
    });
    
    // You could also set a global error state here to show a user-friendly message
    // errorMessage.value = 'Unable to load Last.fm data at this time. Please try again later.';
  }
}

// ... existing code ...
```

These improvements will:

1. **Add retry logic with exponential backoff** for 500 errors from Last.fm
2. **Gracefully handle partial data** - if Last.fm returns some loved tracks before failing, the app will use what it has
3. **Prevent app crashes** by returning empty arrays instead of throwing errors
4. **Add request throttling** with small delays between API calls
5. **Provide better error logging** to help with debugging

The 500 error you're seeing is likely temporary on Last.fm's end, but these changes will make your app more resilient to such issues.

---

