<!-- Generated by SpecStory, Markdown v2.1.0 -->

<!-- cursor Session 5f5e3d97-93d4-48a2-958d-650ba38c1d78 (2025-11-19 20:16Z) -->

# Refactor playlist grouping in pipeline (2025-11-19 20:16Z)

_**User (2025-11-19 14:37Z)**_

we use group to group together playlists in a pipeline. i think the way it's done is highly ineffifienct, each playlist has a group field. suggestions to refactored into something more robust? I do believe groups can be inferred by the pipeline settings.

---

_**Agent (model default, mode Ask)**_



---


Investigating how groups are used and how they might be inferred from pipeline settings.


---

<tool-use data-tool-type="search" data-tool-name="codebase_search">
<details>
                <summary>Tool use: **codebase_search** • Searched codebase "How are playlist groups used in pipelines?" • **12** results</summary>
            
| File | Lines |
|------|-------|
| `src/composables/usePlaylistData.js` | L19-194 |
| `tasks/pipeline-playlist-spec.md` | L60 |
| `src/views/playlists/PlaylistView.vue` | L155-196 |
| `src/views/playlists/PlaylistView.vue` | L38-103 |
| `src/views/playlists/PlaylistView.vue` | L98-159 |
| `src/composables/usePlaylistData.js` | L194 |
| `src/views/playlists/AddPlaylistView.vue` | L136-188 |
| `src/views/playlists/PlaylistView.vue` | L44 |
| `src/composables/usePlaylistUpdates.js` | L9-138 |
| `src/views/playlists/EditPlaylistView.vue` | L316-362 |
| `src/views/playlists/AddPlaylistView.vue` | L272-333 |
| `tasks/pipeline-playlist-spec.md` | L57-101 |

</details>
</tool-use>

---

<tool-use data-tool-type="search" data-tool-name="codebase_search">
<details>
                <summary>Tool use: **codebase_search** • Searched codebase "What are pipeline settings and how do they define groups?" • **10** results</summary>
            
| File | Lines |
|------|-------|
| `tasks/pipeline-playlist-spec.md` | L60 |
| `src/views/playlists/AddPlaylistView.vue` | L136-188 |
| `tasks/pipeline-playlist-spec.md` | L57-101 |
| `src/views/playlists/EditPlaylistView.vue` | L316-362 |
| `docs/purpose-and-function.md` | L33 |
| `tasks/pipeline-playlist-spec.md` | L97-160 |
| `src/composables/usePlaylistData.js` | L19-194 |
| `src/views/playlists/AddPlaylistView.vue` | L272-333 |
| `tasks/pipeline-playlist-spec.md` | L158-195 |
| `.cursor/rules/development.mdc` | L59 |

</details>
</tool-use>

---

<tool-use data-tool-type="search" data-tool-name="grep">
<details>
<summary>Tool use: **grep** • Grep for "\bgroup\b" in "src" • 136 matches</summary>

Output mode: content


| File | Content | Line |
|------|------|------|
| `src\views\playlists\PlaylistSingle.vue` | `// Step 3: Group albums by artist to minimize API calls` | L1467 |
| `src\views\playlists\PlaylistSingle.vue` | `// Step 4: Group albums by artist (same as mismatch check)` | L1675 |
| `src\views\playlists\PlaylistSingle.vue` | `<div class="form-group">` | L2285 |
| `src\views\playlists\PlaylistSingle.vue` | `.form-group \{` | L2380 |
| `src\composables\usePlaylistUpdates.js` | `for (const group of Object.keys(userPlaylists.value)) \{` | L34 |
| `src\composables\usePlaylistUpdates.js` | `const groupPlaylists = userPlaylists.value[group] \|\| [];` | L35 |
| `src\composables\usePlaylistUpdates.js` | `playlistsToRefresh.push(\{ ...playlistData, group \});` | L38 |
| `src\composables\usePlaylistUpdates.js` | `for (const group of Object.keys(currentPlaylistsState)) \{` | L51 |
| `src\composables\usePlaylistUpdates.js` | `const groupPlaylists = currentPlaylistsState[group] \|\| [];` | L52 |
| `src\composables\usePlaylistUpdates.js` | `group: group` | L69 |
| `src\composables\usePlaylistUpdates.js` | `logPlaylist(`Found playlist $\{cachedPlaylist.id\} in cache state (group: $\{group\})`);` | L72 |
| `src\composables\usePlaylistUpdates.js` | `if (!updatedState[playlistData.group]) \{` | L99 |
| `src\composables\usePlaylistUpdates.js` | `updatedState[playlistData.group] = [];` | L100 |
| `src\composables\usePlaylistUpdates.js` | `const existingIndex = updatedState[playlistData.group].findIndex(` | L103 |
| `src\composables\usePlaylistUpdates.js` | `logPlaylist(`Updating existing playlist in state: $\{playlistData.playlistId\} (group: $\{playlistData.group\}, index: $\{existingIndex\})`);` | L108 |
| `src\composables\usePlaylistUpdates.js` | `updatedState[playlistData.group][existingIndex] = updatedPlaylist;` | L109 |
| `src\composables\usePlaylistUpdates.js` | `logPlaylist(`Adding new playlist to state: $\{playlistData.playlistId\} (group: $\{playlistData.group\})`);` | L111 |
| `src\composables\usePlaylistUpdates.js` | `updatedState[playlistData.group].push(updatedPlaylist);` | L112 |
| `src\composables\usePlaylistUpdates.js` | `updatedState[playlistData.group].sort((a, b) => a.priority - b.priority);` | L116 |
| `src\views\playlists\PlaylistView.vue` | `// Dynamic active tab - will be set to first available group` | L29 |
| `src\views\playlists\PlaylistView.vue` | `// Set active tab to first available group if not set` | L42 |
| `src\views\playlists\PlaylistView.vue` | `const allGroupsLoaded = availableGroups.value.every(group => \{` | L61 |
| `src\views\playlists\PlaylistView.vue` | `const groupPlaylists = playlists.value[group] \|\| [];` | L62 |
| `src\views\playlists\PlaylistView.vue` | `// A group is considered loaded if it has playlists in the userPlaylists data` | L63 |
| `src\views\playlists\PlaylistView.vue` | `const hasPlaylistsInData = (userPlaylists.value[group] \|\| []).length > 0;` | L64 |
| `src\views\playlists\PlaylistView.vue` | `availableGroups.value.forEach(group => \{` | L88 |
| `src\views\playlists\PlaylistView.vue` | `filtered[group] = (playlists.value[group] \|\| []).filter(p =>` | L89 |
| `src\views\playlists\PlaylistView.vue` | `// Load all playlists for each group` | L143 |
| `src\views\playlists\PlaylistView.vue` | `for (const group of availableGroups.value) \{` | L144 |
| `src\views\playlists\PlaylistView.vue` | `logPlaylist(`Loading $\{group\} playlists...`);` | L145 |
| `src\views\playlists\PlaylistView.vue` | `// Collect all playlists for this group` | L147 |
| `src\views\playlists\PlaylistView.vue` | `const groupPlaylists = userPlaylists.value[group] \|\| [];` | L149 |
| `src\views\playlists\PlaylistView.vue` | `logPlaylist(`Group $\{group\} has $\{groupPlaylists.length\} playlists from userPlaylists`);` | L151 |
| `src\views\playlists\PlaylistView.vue` | `logPlaylist(`Missing playlist data for $\{group\}:`, playlistData);` | L155 |
| `src\views\playlists\PlaylistView.vue` | `logPlaylist(`Fetching Spotify data for $\{group\} ($\{playlistData.playlistId\})`);` | L160 |
| `src\views\playlists\PlaylistView.vue` | `logPlaylist(`Failed to load playlist $\{playlistData.playlistId\} for $\{group\}:`, playlistError);` | L174 |
| `src\views\playlists\PlaylistView.vue` | `name: playlistData.name \|\| `$\{group\} playlist`, // Fallback name` | L179 |
| `src\views\playlists\PlaylistView.vue` | `playlistSummaries[group] = allPlaylistsForGroup.sort((a, b) => a.priority - b.priority);` | L189 |
| `src\views\playlists\PlaylistView.vue` | `for (const group in playlists.value) \{` | L242 |
| `src\views\playlists\PlaylistView.vue` | `if (Array.isArray(playlists.value[group])) \{` | L243 |
| `src\views\playlists\PlaylistView.vue` | `const initialLength = playlists.value[group].length;` | L244 |
| `src\views\playlists\PlaylistView.vue` | `playlists.value[group] = playlists.value[group].filter(p => p.firebaseId !== firebaseId);` | L245 |
| `src\views\playlists\PlaylistView.vue` | `if (playlists.value[group].length < initialLength) \{` | L246 |
| `src\views\playlists\PlaylistView.vue` | `v-for="group in availableGroups"` | L368 |
| `src\views\playlists\PlaylistView.vue` | `:key="group"` | L369 |
| `src\views\playlists\PlaylistView.vue` | `@click="activeTab = group"` | L370 |
| `src\views\playlists\PlaylistView.vue` | `activeTab === group` | L373 |
| `src\views\playlists\PlaylistView.vue` | `\{{ group \}} (\{{ filteredPlaylists[group]?.length \|\| 0 \}})` | L378 |
| `src\composables\usePlaylistData.js` | `* @property \{string\} group` | L9 |
| `src\composables\usePlaylistData.js` | `* @returns \{string[]\} Array of group names that have playlists, sorted by creation date` | L28 |
| `src\composables\usePlaylistData.js` | `const groupsWithPlaylists = Object.keys(playlists.value).filter(group =>` | L31 |
| `src\composables\usePlaylistData.js` | `playlists.value[group]?.length > 0` | L32 |
| `src\composables\usePlaylistData.js` | `// Sort groups by the earliest createdAt date in each group` | L35 |
| `src\composables\usePlaylistData.js` | `// Find earliest createdAt in each group` | L40 |
| `src\composables\usePlaylistData.js` | `// If one group has no dates, put it at the end` | L53 |
| `src\composables\usePlaylistData.js` | `// Use group field if available, fallback to type for backward compatibility` | L110 |
| `src\composables\usePlaylistData.js` | `const group = playlist.group \|\| playlist.type \|\| 'unknown';` | L111 |
| `src\composables\usePlaylistData.js` | `if (!grouped[group]) \{` | L113 |
| `src\composables\usePlaylistData.js` | `grouped[group] = [];` | L114 |
| `src\composables\usePlaylistData.js` | `grouped[group].push(\{` | L117 |
| `src\composables\usePlaylistData.js` | `group: playlist.group,` | L124 |
| `src\composables\usePlaylistData.js` | `// Sort each group by priority` | L129 |
| `src\composables\usePlaylistData.js` | `Object.keys(grouped).forEach(group => \{` | L130 |
| `src\composables\usePlaylistData.js` | `grouped[group].sort((a, b) => a.priority - b.priority);` | L131 |
| `src\utils\cache.js` | `for (const group in cachedData) \{` | L199 |
| `src\utils\cache.js` | `if (Array.isArray(cachedData[group])) \{` | L200 |
| `src\utils\cache.js` | `const index = cachedData[group].findIndex(` | L201 |
| `src\utils\cache.js` | `logCache(`Found playlist $\{playlistId\} in group $\{group\} at index $\{index\}`);` | L205 |
| `src\utils\cache.js` | `cachedData[group][index] = \{` | L206 |
| `src\utils\cache.js` | `...cachedData[group][index],` | L207 |
| `src\utils\cache.js` | `id: playlistData.id \|\| cachedData[group][index].id,` | L209 |
| `src\utils\cache.js` | `firebaseId: playlistData.firebaseId \|\| cachedData[group][index].firebaseId` | L210 |
| `src\utils\cache.js` | `cachedData[group].sort((a, b) => a.priority - b.priority);` | L214 |
| `src\utils\cache.js` | `for (const group in cachedData) \{` | L247 |
| `src\utils\cache.js` | `if (Array.isArray(cachedData[group])) \{` | L248 |
| `src\utils\cache.js` | `const initialLength = cachedData[group].length;` | L249 |
| `src\utils\cache.js` | `cachedData[group] = cachedData[group].filter(p => p.firebaseId !== firebaseId);` | L250 |
| `src\utils\cache.js` | `if (cachedData[group].length < initialLength) \{` | L251 |
| `src\components\PlaylistItem.vue` | `'p-2 rounded-xl flex items-center cursor-pointer hover:bg-raspberry pr-6 w-full min-w-[200px] relative group',` | L72 |
| `src\components\PlaylistItem.vue` | `<div class="absolute right-2 top-1/2 transform -translate-y-1/2 opacity-0 group-hover:opacity-100 transition-opacity duration-200 flex gap-1">` | L98 |
| `src\views\playlists\EditPlaylistView.vue` | `group: 'known',` | L33 |
| `src\views\playlists\EditPlaylistView.vue` | `p.group === form.value.group &&` | L68 |
| `src\views\playlists\EditPlaylistView.vue` | `p.group === form.value.group &&` | L78 |
| `src\views\playlists\EditPlaylistView.vue` | `group: playlistData.group \|\| playlistData.type \|\| 'known',` | L115 |
| `src\views\playlists\EditPlaylistView.vue` | `group: playlistData.group \|\| playlistData.type,` | L159 |
| `src\views\playlists\EditPlaylistView.vue` | `if (!form.value.group.trim()) \{` | L177 |
| `src\views\playlists\EditPlaylistView.vue` | `errors.group = 'Group is required';` | L178 |
| `src\views\playlists\EditPlaylistView.vue` | `group: form.value.group,` | L212 |
| `src\views\playlists\EditPlaylistView.vue` | `<div class="form-group">` | L285 |
| `src\views\playlists\EditPlaylistView.vue` | `<div class="form-group">` | L304 |
| `src\views\playlists\EditPlaylistView.vue` | `<div class="form-group">` | L324 |
| `src\views\playlists\EditPlaylistView.vue` | `<label for="group" class="block text-sm font-medium text-gray-700 mb-1">` | L325 |
| `src\views\playlists\EditPlaylistView.vue` | `Group` | L326 |
| `src\views\playlists\EditPlaylistView.vue` | `id="group"` | L330 |
| `src\views\playlists\EditPlaylistView.vue` | `v-model="form.group"` | L331 |
| `src\views\playlists\EditPlaylistView.vue` | `formErrors.group ? 'border-red-500' : 'border-gray-300'` | L334 |
| `src\views\playlists\EditPlaylistView.vue` | `<p v-if="formErrors.group" class="text-red-500 text-sm mt-1">` | L338 |
| `src\views\playlists\EditPlaylistView.vue` | `\{{ formErrors.group \}}` | L339 |
| `src\views\playlists\EditPlaylistView.vue` | `<div v-if="pipelineRoleFields.includes('nextStagePlaylistId')" class="form-group">` | L366 |
| `src\views\playlists\EditPlaylistView.vue` | `<div v-if="pipelineRoleFields.includes('terminationPlaylistId')" class="form-group">` | L392 |
| `src\views\playlists\EditPlaylistView.vue` | `<div class="form-group">` | L428 |
| `src\composables\useAlbumsData.js` | `// Always use group field to populate type, fallback to type if group doesn't exist` | L372 |
| `src\composables\useAlbumsData.js` | `const entryType = _playlistData.group \|\| _playlistData.type \|\| 'unknown';` | L373 |
| `src\views\auth\LoginView.vue` | `<div class="form-group">` | L41 |
| `src\views\auth\LoginView.vue` | `<div class="form-group">` | L52 |
| `src\views\auth\LoginView.vue` | `.form-group \{` | L91 |
| `src\components\TrackList.vue` | `'group flex justify-between items-start text-delft-blue hover:bg-white/30 pl-3 pr-2 py-1 transition-colors',` | L489 |
| `src\components\TrackList.vue` | `class="mr-1 text-gray-400 flex-shrink-0 opacity-0 group-hover:opacity-100 transition-opacity"` | L518 |
| `src\views\auth\AccountView.vue` | `<div class="form-group">` | L172 |
| `src\views\auth\AccountView.vue` | `<div class="form-group">` | L185 |
| `src\views\auth\AccountView.vue` | `.form-group \{` | L231 |
| `src\components\AlbumSearch.vue` | `<div class="form-group">` | L3 |
| `src\components\AlbumSearch.vue` | `.form-group \{` | L172 |
| `src\composables\useUserSpotifyApi.js` | `// Group tracks by album` | L417 |
| `src\views\playlists\AddPlaylistView.vue` | `<div class="form-group">` | L111 |
| `src\views\playlists\AddPlaylistView.vue` | `<div class="form-group">` | L127 |
| `src\views\playlists\AddPlaylistView.vue` | `<div class="form-group">` | L141 |
| `src\views\playlists\AddPlaylistView.vue` | `<div class="form-group">` | L160 |
| `src\views\playlists\AddPlaylistView.vue` | `<label for="group">Group</label>` | L161 |
| `src\views\playlists\AddPlaylistView.vue` | `id="group"` | L164 |
| `src\views\playlists\AddPlaylistView.vue` | `v-model="form.group"` | L165 |
| `src\views\playlists\AddPlaylistView.vue` | `:class="\{ 'error': formError?.group \}"` | L167 |
| `src\views\playlists\AddPlaylistView.vue` | `<span v-if="formError?.group" class="error-text">\{{ formError.group \}}</span>` | L169 |
| `src\views\playlists\AddPlaylistView.vue` | `<div v-if="pipelineRoleFields && pipelineRoleFields.includes('nextStagePlaylistId')" class="form-group">` | L196 |
| `src\views\playlists\AddPlaylistView.vue` | `<div v-if="pipelineRoleFields && pipelineRoleFields.includes('terminationPlaylistId')" class="form-group">` | L208 |
| `src\views\playlists\AddPlaylistView.vue` | `<div class="form-group">` | L230 |
| `src\views\playlists\AddPlaylistView.vue` | `group: '',` | L289 |
| `src\views\playlists\AddPlaylistView.vue` | `if (!form.group?.trim()) \{` | L387 |
| `src\views\playlists\AddPlaylistView.vue` | `errors.group = 'Please enter a group name';` | L388 |
| `src\views\playlists\AddPlaylistView.vue` | `form.group = '';` | L419 |
| `src\views\playlists\AddPlaylistView.vue` | `.form-group \{` | L446 |
| `src\views\playlists\PlaylistManagementView.vue` | `<div class="form-group">` | L25 |
| `src\views\playlists\PlaylistManagementView.vue` | `<div class="form-group">` | L37 |
| `src\views\playlists\PlaylistManagementView.vue` | `<div class="form-group">` | L78 |
| `src\views\playlists\PlaylistManagementView.vue` | `<div class="form-group">` | L82 |
| `src\views\playlists\PlaylistManagementView.vue` | `.form-group \{` | L539 |


</details>
</tool-use>

---



---

<tool-use data-tool-type="read" data-tool-name="read_file">
<details><summary>Tool use: **read_file** • Read file: tasks/pipeline-playlist-spec.md</summary>

</details>
</tool-use>

---





---

<tool-use data-tool-type="search" data-tool-name="codebase_search">
<details>
                <summary>Tool use: **codebase_search** • Searched codebase "What are the pipeline connections and nextStagePlaylistId relationships?" • **11** results</summary>
            
| File | Lines |
|------|-------|
| `tasks/pipeline-playlist-spec.md` | L60 |
| `src/views/playlists/EditPlaylistView.vue` | L358-392 |
| `src/views/playlists/AddPlaylistView.vue` | L184-222 |
| `tasks/pipeline-playlist-spec.md` | L57-101 |
| `src/views/playlists/EditPlaylistView.vue` | L61-131 |
| `src/views/playlists/EditPlaylistView.vue` | L195-264 |
| `tasks/pipeline-playlist-spec.md` | L158-195 |
| `src/views/playlists/PlaylistSingle.vue` | L1168-1223 |
| `tasks/priority-refactor-spec.md` | L62 |
| `src/views/playlists/EditPlaylistView.vue` | L63 |
| `tasks/pipeline-playlist-spec.md` | L97-160 |

</details>
</tool-use>

---

<tool-use data-tool-type="search" data-tool-name="grep">
<details>
<summary>Tool use: **grep** • Grep for "nextStagePlaylistId|terminationPlaylistId|pipelineRole" in "src" • 121 matches</summary>

Output mode: content


| File | Content | Line |
|------|------|------|
| `src\views\playlists\PlaylistSingle.vue` | `pipelineRole: currentEntry.pipelineRole \|\| 'transient',` | L805 |
| `src\views\playlists\PlaylistSingle.vue` | `if (!currentPlaylistData?.nextStagePlaylistId) \{` | L1186 |
| `src\views\playlists\PlaylistSingle.vue` | `const targetPlaylistDoc = await getDoc(doc(db, 'playlists', currentPlaylistData.nextStagePlaylistId));` | L1191 |
| `src\views\playlists\PlaylistSingle.vue` | `if (!currentPlaylistData?.terminationPlaylistId) \{` | L1200 |
| `src\views\playlists\PlaylistSingle.vue` | `const terminationPlaylistDoc = await getDoc(doc(db, 'playlists', currentPlaylistData.terminationPlaylistId));` | L1205 |
| `src\views\playlists\PlaylistSingle.vue` | `:showProcessingButtons="userData?.spotifyConnected && !!playlistDoc?.data()?.nextStagePlaylistId"` | L2241 |
| `src\views\playlists\PlaylistSingle.vue` | `:isSourcePlaylist="!!playlistDoc?.data()?.nextStagePlaylistId"` | L2242 |
| `src\views\playlists\PlaylistSingle.vue` | `:hasTerminationPlaylist="!!playlistDoc?.data()?.terminationPlaylistId"` | L2243 |
| `src\composables\usePlaylistUpdates.js` | `pipelineRole: firebaseData?.pipelineRole \|\| cachedPlaylist.pipelineRole \|\| 'transient',` | L68 |
| `src\composables\usePlaylistUpdates.js` | `pipelineRole: playlistData.pipelineRole \|\| 'transient'` | L95 |
| `src\views\playlists\PlaylistView.vue` | `p.pipelineRole !== 'sink'` | L90 |
| `src\views\playlists\PlaylistView.vue` | `pipelineRole: playlistData.pipelineRole \|\| 'transient' // Include pipeline role from Firebase data` | L171 |
| `src\views\playlists\PlaylistView.vue` | `pipelineRole: playlistData.pipelineRole \|\| 'transient' // Include pipeline role from Firebase data` | L183 |
| `src\composables\usePlaylistData.js` | `* @property \{string\} pipelineRole` | L10 |
| `src\composables\usePlaylistData.js` | `pipelineRole: playlist.pipelineRole \|\| 'transient', // Include pipeline role` | L121 |
| `src\components\PlaylistItem.vue` | `// End playlists are those with pipelineRole 'terminal' or 'sink'` | L47 |
| `src\components\PlaylistItem.vue` | `return props.playlist?.pipelineRole === 'terminal' \|\| props.playlist?.pipelineRole === 'sink';` | L48 |
| `src\components\PlaylistItem.vue` | `return props.playlist?.pipelineRole === 'terminal';` | L53 |
| `src\components\PlaylistItem.vue` | `return props.playlist?.pipelineRole === 'sink';` | L58 |
| `src\components\AlbumItem.vue` | `v-if="currentPlaylist?.nextStagePlaylistId"` | L184 |
| `src\components\AlbumItem.vue` | `<MusicalNoteIcon v-if="currentPlaylist?.pipelineRole === 'source'" class="h-4 w-4" />` | L189 |
| `src\components\AlbumItem.vue` | `<RatingBar v-if="ratingData?.pipelineRole && ratingData?.pipelineRole !== 'source'" :priority="ratingData?.priority" :pipelineRole="ratingData?.pipelineRole" />` | L298 |
| `src\components\AlbumItem.vue` | `<div v-else-if="ratingData?.pipelineRole === 'source'" class="h-6 py-1 flex items-center justify-start pl-2" style="width: 100%">` | L300 |
| `src\views\playlists\EditPlaylistView.vue` | `pipelineRole: 'source',` | L34 |
| `src\views\playlists\EditPlaylistView.vue` | `nextStagePlaylistId: '',` | L35 |
| `src\views\playlists\EditPlaylistView.vue` | `terminationPlaylistId: ''` | L36 |
| `src\views\playlists\EditPlaylistView.vue` | `const pipelineRoles = [` | L42 |
| `src\views\playlists\EditPlaylistView.vue` | `const pipelineRoleFields = computed(() => \{` | L49 |
| `src\views\playlists\EditPlaylistView.vue` | `switch (form.value.pipelineRole) \{` | L50 |
| `src\views\playlists\EditPlaylistView.vue` | `return ['nextStagePlaylistId'];` | L52 |
| `src\views\playlists\EditPlaylistView.vue` | `return ['nextStagePlaylistId', 'terminationPlaylistId'];` | L54 |
| `src\views\playlists\EditPlaylistView.vue` | `p.pipelineRole !== 'sink'` | L69 |
| `src\views\playlists\EditPlaylistView.vue` | `p.pipelineRole === 'sink'` | L79 |
| `src\views\playlists\EditPlaylistView.vue` | `pipelineRole: playlistData.pipelineRole \|\| 'source',` | L116 |
| `src\views\playlists\EditPlaylistView.vue` | `nextStagePlaylistId: playlistData.nextStagePlaylistId \|\| '',` | L117 |
| `src\views\playlists\EditPlaylistView.vue` | `terminationPlaylistId: playlistData.terminationPlaylistId \|\| ''` | L118 |
| `src\views\playlists\EditPlaylistView.vue` | `name: playlistData.name \|\| `$\{playlistData.type\} $\{playlistData.pipelineRole\}`, // Use Firebase name, fallback to generated` | L156 |
| `src\views\playlists\EditPlaylistView.vue` | `pipelineRole: playlistData.pipelineRole \|\| 'transient'` | L160 |
| `src\views\playlists\EditPlaylistView.vue` | `if (pipelineRoleFields.value.includes('nextStagePlaylistId') && !form.value.nextStagePlaylistId) \{` | L182 |
| `src\views\playlists\EditPlaylistView.vue` | `errors.nextStagePlaylistId = 'Next stage playlist is required for this pipeline role';` | L183 |
| `src\views\playlists\EditPlaylistView.vue` | `if (pipelineRoleFields.value.includes('terminationPlaylistId') && !form.value.terminationPlaylistId) \{` | L186 |
| `src\views\playlists\EditPlaylistView.vue` | `errors.terminationPlaylistId = 'Termination playlist is required for this pipeline role';` | L187 |
| `src\views\playlists\EditPlaylistView.vue` | `pipelineRole: form.value.pipelineRole,` | L213 |
| `src\views\playlists\EditPlaylistView.vue` | `if (pipelineRoleFields.value.includes('nextStagePlaylistId')) \{` | L218 |
| `src\views\playlists\EditPlaylistView.vue` | `updateData.nextStagePlaylistId = form.value.nextStagePlaylistId;` | L219 |
| `src\views\playlists\EditPlaylistView.vue` | `updateData.nextStagePlaylistId = null;` | L221 |
| `src\views\playlists\EditPlaylistView.vue` | `if (pipelineRoleFields.value.includes('terminationPlaylistId')) \{` | L224 |
| `src\views\playlists\EditPlaylistView.vue` | `updateData.terminationPlaylistId = form.value.terminationPlaylistId;` | L225 |
| `src\views\playlists\EditPlaylistView.vue` | `updateData.terminationPlaylistId = null;` | L227 |
| `src\views\playlists\EditPlaylistView.vue` | `if (!pipelineRoleFields.value.includes('nextStagePlaylistId')) \{` | L250 |
| `src\views\playlists\EditPlaylistView.vue` | `form.value.nextStagePlaylistId = '';` | L251 |
| `src\views\playlists\EditPlaylistView.vue` | `if (!pipelineRoleFields.value.includes('terminationPlaylistId')) \{` | L253 |
| `src\views\playlists\EditPlaylistView.vue` | `form.value.terminationPlaylistId = '';` | L254 |
| `src\views\playlists\EditPlaylistView.vue` | `<label for="pipelineRole" class="block text-sm font-medium text-gray-700 mb-1">` | L345 |
| `src\views\playlists\EditPlaylistView.vue` | `id="pipelineRole"` | L349 |
| `src\views\playlists\EditPlaylistView.vue` | `v-model="form.pipelineRole"` | L350 |
| `src\views\playlists\EditPlaylistView.vue` | `<option v-for="role in pipelineRoles" :key="role.value" :value="role.value">` | L354 |
| `src\views\playlists\EditPlaylistView.vue` | `<div v-if="pipelineRoleFields.length > 0" class="bg-white shadow rounded-lg p-6">` | L362 |
| `src\views\playlists\EditPlaylistView.vue` | `<div v-if="pipelineRoleFields.includes('nextStagePlaylistId')" class="form-group">` | L366 |
| `src\views\playlists\EditPlaylistView.vue` | `<label for="nextStagePlaylistId" class="block text-sm font-medium text-gray-700 mb-1">` | L367 |
| `src\views\playlists\EditPlaylistView.vue` | `id="nextStagePlaylistId"` | L371 |
| `src\views\playlists\EditPlaylistView.vue` | `v-model="form.nextStagePlaylistId"` | L372 |
| `src\views\playlists\EditPlaylistView.vue` | `formErrors.nextStagePlaylistId ? 'border-red-500' : 'border-gray-300'` | L375 |
| `src\views\playlists\EditPlaylistView.vue` | `<p v-if="formErrors.nextStagePlaylistId" class="text-red-500 text-sm mt-1">` | L387 |
| `src\views\playlists\EditPlaylistView.vue` | `\{{ formErrors.nextStagePlaylistId \}}` | L388 |
| `src\views\playlists\EditPlaylistView.vue` | `<div v-if="pipelineRoleFields.includes('terminationPlaylistId')" class="form-group">` | L392 |
| `src\views\playlists\EditPlaylistView.vue` | `<label for="terminationPlaylistId" class="block text-sm font-medium text-gray-700 mb-1">` | L393 |
| `src\views\playlists\EditPlaylistView.vue` | `id="terminationPlaylistId"` | L397 |
| `src\views\playlists\EditPlaylistView.vue` | `v-model="form.terminationPlaylistId"` | L398 |
| `src\views\playlists\EditPlaylistView.vue` | `formErrors.terminationPlaylistId ? 'border-red-500' : 'border-gray-300'` | L401 |
| `src\views\playlists\EditPlaylistView.vue` | `<p v-if="formErrors.terminationPlaylistId" class="text-red-500 text-sm mt-1">` | L413 |
| `src\views\playlists\EditPlaylistView.vue` | `\{{ formErrors.terminationPlaylistId \}}` | L414 |
| `src\composables\useAlbumsData.js` | `pipelineRole: _playlistData.pipelineRole \|\| 'transient',` | L378 |
| `src\composables\useLatestMovements.js` | `pipelineRole: latestEntry.pipelineRole \|\| 'transient',` | L102 |
| `src\composables\useLatestMovements.js` | `fromPipelineRole: sortedHistory[1]?.pipelineRole \|\| null,` | L103 |
| `src\components\LatestMovements.vue` | `const getRoleColor = (pipelineRole) => \{` | L53 |
| `src\components\LatestMovements.vue` | `return colors[pipelineRole] \|\| 'bg-gray-800 text-white';` | L60 |
| `src\components\LatestMovements.vue` | `movement.pipelineRole === 'sink' ? 'rounded' : 'rounded-full',` | L184 |
| `src\components\LatestMovements.vue` | `getRoleColor(movement.pipelineRole)` | L185 |
| `src\components\LatestMovements.vue` | `movement.pipelineRole === 'sink' ? 'rounded' : 'rounded-full',` | L194 |
| `src\components\LatestMovements.vue` | `getRoleColor(movement.pipelineRole)` | L195 |
| `src\components\LatestMovements.vue` | `movement.pipelineRole === 'sink' ? 'rounded' : 'rounded-full',` | L207 |
| `src\components\LatestMovements.vue` | `getRoleColor(movement.pipelineRole)` | L208 |
| `src\components\LatestMovements.vue` | `movement.pipelineRole === 'sink' ? 'rounded' : 'rounded-full',` | L217 |
| `src\components\LatestMovements.vue` | `getRoleColor(movement.pipelineRole)` | L218 |
| `src\views\music\ArtistView.vue` | `pipelineRole: currentEntry.pipelineRole \|\| 'transient',` | L131 |
| `src\views\music\ArtistView.vue` | `pipelineRole: currentEntry.pipelineRole \|\| 'transient',` | L175 |
| `src\views\playlists\AddPlaylistView.vue` | `<label for="pipelineRole">Pipeline Role</label>` | L174 |
| `src\views\playlists\AddPlaylistView.vue` | `id="pipelineRole"` | L176 |
| `src\views\playlists\AddPlaylistView.vue` | `v-model="form.pipelineRole"` | L177 |
| `src\views\playlists\AddPlaylistView.vue` | `:class="\{ 'error': formError?.pipelineRole \}"` | L178 |
| `src\views\playlists\AddPlaylistView.vue` | `<option v-for="role in pipelineRoles" :key="role.value" :value="role.value">` | L180 |
| `src\views\playlists\AddPlaylistView.vue` | `<span v-if="formError?.pipelineRole" class="error-text">\{{ formError.pipelineRole \}}</span>` | L184 |
| `src\views\playlists\AddPlaylistView.vue` | `<div v-if="pipelineRoleFields && pipelineRoleFields.length > 0" class="bg-white shadow rounded-lg p-6 mb-6">` | L189 |
| `src\views\playlists\AddPlaylistView.vue` | `<div v-if="pipelineRoleFields && pipelineRoleFields.includes('nextStagePlaylistId')" class="form-group">` | L196 |
| `src\views\playlists\AddPlaylistView.vue` | `<label for="nextStagePlaylistId">Next Stage Playlist</label>` | L197 |
| `src\views\playlists\AddPlaylistView.vue` | `id="nextStagePlaylistId"` | L199 |
| `src\views\playlists\AddPlaylistView.vue` | `v-model="form.nextStagePlaylistId"` | L200 |
| `src\views\playlists\AddPlaylistView.vue` | `<div v-if="pipelineRoleFields && pipelineRoleFields.includes('terminationPlaylistId')" class="form-group">` | L208 |
| `src\views\playlists\AddPlaylistView.vue` | `<label for="terminationPlaylistId">Termination Playlist</label>` | L209 |
| `src\views\playlists\AddPlaylistView.vue` | `id="terminationPlaylistId"` | L211 |
| `src\views\playlists\AddPlaylistView.vue` | `v-model="form.terminationPlaylistId"` | L212 |
| `src\views\playlists\AddPlaylistView.vue` | `pipelineRole: 'source',` | L290 |
| `src\views\playlists\AddPlaylistView.vue` | `nextStagePlaylistId: '',` | L291 |
| `src\views\playlists\AddPlaylistView.vue` | `terminationPlaylistId: ''` | L292 |
| `src\views\playlists\AddPlaylistView.vue` | `const pipelineRoles = [` | L304 |
| `src\views\playlists\AddPlaylistView.vue` | `const pipelineRoleFields = computed(() => \{` | L311 |
| `src\views\playlists\AddPlaylistView.vue` | `// Add safety check to ensure form exists and has pipelineRole` | L312 |
| `src\views\playlists\AddPlaylistView.vue` | `if (!form \|\| !form.pipelineRole) \{` | L313 |
| `src\views\playlists\AddPlaylistView.vue` | `switch (form.pipelineRole) \{` | L317 |
| `src\views\playlists\AddPlaylistView.vue` | `return ['nextStagePlaylistId'];` | L319 |
| `src\views\playlists\AddPlaylistView.vue` | `return ['nextStagePlaylistId', 'terminationPlaylistId'];` | L321 |
| `src\views\playlists\AddPlaylistView.vue` | `if (!form.pipelineRole) \{` | L391 |
| `src\views\playlists\AddPlaylistView.vue` | `errors.pipelineRole = 'Please select a pipeline role';` | L392 |
| `src\views\playlists\AddPlaylistView.vue` | `form.pipelineRole = 'source';` | L420 |
| `src\views\playlists\AddPlaylistView.vue` | `form.nextStagePlaylistId = '';` | L421 |
| `src\views\playlists\AddPlaylistView.vue` | `form.terminationPlaylistId = '';` | L422 |
| `src\views\music\SearchView.vue` | `pipelineRole: currentEntry.pipelineRole \|\| 'transient',` | L110 |
| `src\components\RatingBar.vue` | `pipelineRole: \{` | L10 |
| `src\components\RatingBar.vue` | `const bgClass = computed(() => (props.pipelineRole === 'sink' \|\| props.pipelineRole === 'terminal') ? 'bg-raspberry' : 'bg-mint');` | L28 |
| `src\components\RatingBar.vue` | `<template v-if="props.pipelineRole === 'sink' \|\| props.pipelineRole === 'terminal'">` | L37 |


</details>
</tool-use>

---



---

<tool-use data-tool-type="read" data-tool-name="read_file">
<details><summary>Tool use: **read_file** • Read file: src/composables/usePlaylistData.js</summary>

</details>
</tool-use>

---





---

<tool-use data-tool-type="read" data-tool-name="read_file">
<details><summary>Tool use: **read_file** • Read file: src/views/playlists/EditPlaylistView.vue</summary>

</details>
</tool-use>

---



---


## Current Problem

- Every playlist stores a `group` field (redundant)
- Groups can be inferred from pipeline connections (`nextStagePlaylistId`, `terminationPlaylistId`)
- Extra storage and risk of inconsistency

## Refactoring Approach

### Option 1: Compute Groups from Pipeline Graph (Recommended)

Remove the `group` field and compute groups dynamically using graph traversal:

1. Build connected components from pipeline connections:
   - Playlists connected via `nextStagePlaylistId` or `terminationPlaylistId` are in the same group
   - Traverse bidirectional (follow both incoming and outgoing connections)
   - Each connected component = one group

2. Implementation strategy:
   - Compute groups in `usePlaylistData.js` after fetching playlists
   - Cache computed groups in memory
   - Recompute only when playlists or connections change

3. Handling edge cases:
   - Orphaned playlists (no connections): fallback to `type` or a default group
   - New playlists: assign to a group when first connection is created
   - Empty pipelines: can be grouped by `type` as a temporary measure

### Option 2: Derive Groups from Source Playlist

Since pipelines have a source playlist, derive group from the source:
- Start at source playlists (`pipelineRole: 'source'`)
- All playlists reachable from a source via connections belong to that source's group
- Name the group after the source playlist (e.g., "Rock" from "Rock Queued")

### Option 3: Groups Collection (More Structure)

If groups need metadata (display name, order), use a separate `pipelineGroups` collection:
- Store group definitions separately
- Playlists reference group by ID via `groupId`
- Enables richer group management

## Recommended Implementation

Option 1 (computed from graph) fits your constraints:
- Removes redundant storage
- Prevents group inconsistencies
- Matches pipeline structure
- Minimal changes (mainly in `usePlaylistData.js`)

Should I implement Option 1, or would you prefer a different approach?

---

_**User (2025-11-19 14:37Z)**_

for option 1, is there a group name, and where is it stored?

---

_**Agent (model default, mode Ask)**_



---


Checking how group names are currently used and where they come from.


---

<tool-use data-tool-type="search" data-tool-name="codebase_search">
<details>
                <summary>Tool use: **codebase_search** • Searched codebase "How are group names displayed and used in the UI?" • **14** results</summary>
            
| File | Lines |
|------|-------|
| `src/views/playlists/PlaylistView.vue` | L357-403 |
| `src/views/playlists/PlaylistView.vue` | L44 |
| `src/views/playlists/PlaylistSingle.vue` | L1850-1882 |
| `src/components/PlaylistItem.vue` | L76-115 |
| `src/composables/usePlaylistData.js` | L19-194 |
| `src/components/TrackList.vue` | L471-499 |
| `src/components/TrackList.vue` | L495-538 |
| `src/components/AlbumItem.vue` | L219-255 |
| `src/views/playlists/PlaylistView.vue` | L98-159 |
| `src/views/playlists/PlaylistManagementView.vue` | L172-205 |
| `src/views/playlists/PlaylistManagementView.vue` | L472-548 |
| `src/views/playlists/PlaylistView.vue` | L155-196 |
| `src/views/playlists/PlaylistSingle.vue` | L33-87 |
| `src/views/playlists/EditPlaylistView.vue` | L316-362 |

</details>
</tool-use>

---

<tool-use data-tool-type="search" data-tool-name="grep">
<details>
<summary>Tool use: **grep** • Grep for "group.*name|groupName|display.*group" in "src" • 3 matches</summary>

Output mode: content


| File | Content | Line |
|------|------|------|
| `src\views\playlists\PlaylistView.vue` | `name: playlistData.name \|\| `$\{group\} playlist`, // Fallback name` | L179 |
| `src\composables\usePlaylistData.js` | `* @returns \{string[]\} Array of group names that have playlists, sorted by creation date` | L28 |
| `src\views\playlists\AddPlaylistView.vue` | `errors.group = 'Please enter a group name';` | L388 |


</details>
</tool-use>

---

<tool-use data-tool-type="read" data-tool-name="read_file">
<details><summary>Tool use: **read_file** • Read file: src/views/playlists/PlaylistView.vue</summary>

</details>
</tool-use>

---



---


Checking how group names relate to playlist names and types:


---

<tool-use data-tool-type="read" data-tool-name="read_file">
<details><summary>Tool use: **read_file** • Read file: src/views/playlists/AddPlaylistView.vue</summary>

</details>
</tool-use>

---

<tool-use data-tool-type="search" data-tool-name="grep">
<details>
<summary>Tool use: **grep** • Grep for "group.*rock|group.*jazz|group.*known|group.*new" in "src" • 4 matches</summary>

Output mode: content


| File | Content | Line |
|------|------|------|
| `src\composables\usePlaylistData.js` | `const group = playlist.group \|\| playlist.type \|\| 'unknown';` | L111 |
| `src\views\playlists\EditPlaylistView.vue` | `group: 'known',` | L33 |
| `src\views\playlists\EditPlaylistView.vue` | `group: playlistData.group \|\| playlistData.type \|\| 'known',` | L115 |
| `src\composables\useAlbumsData.js` | `const entryType = _playlistData.group \|\| _playlistData.type \|\| 'unknown';` | L373 |


</details>
</tool-use>

---

<tool-use data-tool-type="search" data-tool-name="codebase_search">
<details>
                <summary>Tool use: **codebase_search** • Searched codebase "How are group names derived from playlist names or source playlists?" • **12** results</summary>
            
| File | Lines |
|------|-------|
| `src/composables/usePlaylistData.js` | L19-194 |
| `src/views/playlists/PlaylistView.vue` | L155-196 |
| `tasks/pipeline-playlist-spec.md` | L60 |
| `src/views/playlists/PlaylistView.vue` | L98-159 |
| `src/composables/usePlaylistData.js` | L194 |
| `src/views/playlists/EditPlaylistView.vue` | L125-172 |
| `src/views/playlists/PlaylistView.vue` | L44 |
| `src/views/playlists/PlaylistManagementView.vue` | L472-548 |
| `src/views/playlists/PlaylistManagementView.vue` | L417-477 |
| `src/views/playlists/EditPlaylistView.vue` | L63 |
| `src/views/playlists/AddPlaylistView.vue` | L328-403 |
| `src/views/playlists/EditPlaylistView.vue` | L61-131 |

</details>
</tool-use>

---



---


Group names are stored in the `group` field on each playlist. For Option 1 (computed from graph), we should store the name in one place. Here are practical options:

## Option 1A: Store group name on source playlist only

**Where it's stored:** Add a `groupName` field only to source playlists (`pipelineRole: 'source'`).

**How it works:**
1. Build connected components from the graph
2. Find the source playlist in each component
3. Use its `groupName` as the group identifier
4. Fallback: if no source, use `type` or derive from the earliest playlist name

**Storage:**
- Only source playlists have `groupName` (e.g., "rock", "jazz", "90s")
- Other playlists don't store group info — it's computed
- Each group stores the name once (on the source)

## Option 1B: Derive from source playlist name

**Where it's stored:** Not stored — derived dynamically.

**How it works:**
1. Build connected components from the graph
2. Find the source playlist (pipeline entry point)
3. Extract group name from source playlist name:
   - "Rock Queued" → "rock"
   - "Jazz Queued" → "jazz"
   - "90s Music Queued" → "90s music"
4. Cache the derived name for display

**Storage:**
- No group field stored anywhere
- Name is computed from source playlist name pattern
- Requires consistent naming convention

## Recommendation: Option 1A

- Single source of truth (one `groupName` per group)
- User control over display name
- Works even if naming patterns vary
- Minimal storage (one field per group, not per playlist)

Should I implement Option 1A, or do you prefer deriving from names (1B)?

---

_**User (2025-11-19 14:37Z)**_

no, with the idea of multiple sources, that option is not viable. I think a pipelineGroup collection might be the smartest way forward

---

_**Agent (model default, mode Ask)**_



---


A separate `pipelineGroups` collection makes sense with multiple sources. Exploring the structure:


---

<tool-use data-tool-type="search" data-tool-name="codebase_search">
<details>
                <summary>Tool use: **codebase_search** • Searched codebase "What are the playlist collection fields and structure?" • **12** results</summary>
            
| File | Lines |
|------|-------|
| `tasks/pipeline-playlist-spec.md` | L60 |
| `src/composables/usePlaylistData.js` | L19-194 |
| `src/composables/usePlaylistData.js` | L194 |
| `tasks/priority-refactor-spec.md` | L62 |
| `.cursor/rules/development.mdc` | L59 |
| `firestore.indexes.json` | L28 |
| `tasks/pipeline-playlist-spec.md` | L57-101 |
| `src/composables/useAlbumsData.js` | L24-664 |
| `tasks/pipeline-playlist-spec.md` | L97-160 |
| `src/views/playlists/EditPlaylistView.vue` | L63 |
| `firestore.rules` | L51 |
| `src/views/playlists/EditPlaylistView.vue` | L195-264 |

</details>
</tool-use>

---

Could not find file '.cursor/rules/data-structures.mdc' in the workspace.

---



---


## Proposed `pipelineGroups` Collection Structure

**Collection: `pipelineGroups`**
```json
{
  "groupId": "auto-generated-id",
  "name": "rock",                    // Display name (e.g., "rock", "jazz", "90s")
  "userId": "user123",               // Owner of the group
  "displayOrder": 0,                 // Optional: for sorting groups
  "createdAt": "timestamp",
  "updatedAt": "timestamp"
}
```

**Updated `playlists` Collection**
```json
{
  "playlistId": "spotifyId123",
  "name": "Rock Checking",
  "groupId": "group-doc-id",         // Reference to pipelineGroups document (replaces "group" string)
  "pipelineRole": "transient",
  "nextStagePlaylistId": "firebaseId...",
  "terminationPlaylistId": "firebaseId...",
  "priority": 20,
  "userId": "user123",
  "createdAt": "timestamp",
  "updatedAt": "timestamp"
}
```

## How It Works

1. Compute connected components from pipeline connections (graph traversal).
2. For each component:
   - If playlists already have a `groupId`, use that group.
   - If not (new pipeline), create a new `pipelineGroups` document and assign `groupId` to all playlists in that component.
   - Validate: all connected playlists share the same `groupId`.
3. Group metadata (name, display order) lives in `pipelineGroups` (not duplicated on each playlist).

## Benefits

- Single source of truth for group metadata
- No redundancy — one group document per group, not per playlist
- Supports multiple sources per group
- Can store group metadata (display order, custom sorting, etc.)
- Validated by connections — group membership verified by graph structure

## Migration Path

1. Create `pipelineGroups` collection.
2. For existing playlists: compute components, create groups, assign `groupId`.
3. Replace `group` (string) with `groupId` (reference).
4. Update queries to join with `pipelineGroups` when group metadata is needed.

Should I draft the implementation details and migration steps?

---

_**User (2025-11-19 14:37Z)**_

can you create folders in spotify api?

---

_**Agent (model default, mode Ask)**_



---


Checking the codebase for Spotify API usage and folder/playlist organization:


---

<tool-use data-tool-type="search" data-tool-name="codebase_search">
<details>
                <summary>Tool use: **codebase_search** • Searched codebase "How are Spotify playlists organized and managed?" • **12** results</summary>
            
| File | Lines |
|------|-------|
| `src/composables/usePlaylistData.js` | L19-194 |
| `src/composables/useUserSpotifyApi.js` | L5-654 |
| `src/views/playlists/PlaylistView.vue` | L155-196 |
| `src/composables/usePlaylistUpdates.js` | L9-138 |
| `src/views/playlists/PlaylistManagementView.vue` | L260-325 |
| `src/views/playlists/PlaylistView.vue` | L44 |
| `tasks/pipeline-playlist-spec.md` | L60 |
| `src/views/playlists/AddPlaylistView.vue` | L401-453 |
| `src/composables/usePlaylistData.js` | L194 |
| `src/views/playlists/PlaylistManagementView.vue` | L472-548 |
| `src/views/playlists/PlaylistView.vue` | L98-159 |
| `src/views/playlists/EditPlaylistView.vue` | L125-172 |

</details>
</tool-use>

---

<tool-use data-tool-type="search" data-tool-name="grep">
<details>
<summary>Tool use: **grep** • Grep for "spotify.*folder|folder.*spotify|create.*playlist|spotify.*api" in "src" • 70 matches</summary>

Output mode: content


| File | Content | Line |
|------|------|------|
| `src\views\playlists\AddPlaylistView.vue` | `Create AudioFoodie playlists in the` | L36 |
| `src\views\playlists\AddPlaylistView.vue` | `Pipeline connections can be configured after the playlist is created in the Edit Playlist page.` | L192 |
| `src\views\playlists\AddPlaylistView.vue` | `import \{ useUserSpotifyApi \} from '@composables/useUserSpotifyApi';` | L273 |
| `src\views\playlists\AddPlaylistView.vue` | `const \{ getUserPlaylists, isAudioFoodiePlaylist, getPlaylist \} = useUserSpotifyApi();` | L282 |
| `src\views\playlists\AddPlaylistView.vue` | `// Create playlist object for cache` | L429 |
| `src\views\playlists\PlaylistSingle.vue` | `import \{ useUserSpotifyApi \} from '@composables/useUserSpotifyApi';` | L26 |
| `src\views\playlists\PlaylistSingle.vue` | `const \{ getPlaylist, getPlaylistAlbumsWithDates, loadAlbumsBatched, addAlbumToPlaylist, removeAlbumFromPlaylist: removeFromSpotify, loading: spotifyLoading, error: spotifyError, getAlbumTracks, getAllArtistAlbums, getAllPlaylistTracks \} = useUserSpotifyApi();` | L35 |
| `src\views\playlists\PlaylistSingle.vue` | `// Strategy: Check DB first, then Spotify API for missing albums` | L761 |
| `src\views\playlists\PlaylistSingle.vue` | `// 3. Fetch missing albums from Spotify API (only if needed)` | L768 |
| `src\composables\usePlaylistUpdates.js` | `import \{ useUserSpotifyApi \} from './useUserSpotifyApi';` | L2 |
| `src\composables\usePlaylistUpdates.js` | `const \{ getPlaylist \} = useUserSpotifyApi();` | L12 |
| `src\views\playlists\PlaylistView.vue` | `import \{ useUserSpotifyApi \} from '@composables/useUserSpotifyApi';` | L9 |
| `src\views\playlists\PlaylistView.vue` | `const \{ getPlaylist\} = useUserSpotifyApi();` | L22 |
| `src\views\playlists\PlaylistView.vue` | `// Still add the playlist with basic data even if Spotify API fails` | L175 |
| `src\composables\usePlaylistData.js` | `const date = playlist.createdAt?.toDate ? playlist.createdAt.toDate() : new Date(playlist.createdAt);` | L43 |
| `src\composables\usePlaylistData.js` | `const date = playlist.createdAt?.toDate ? playlist.createdAt.toDate() : new Date(playlist.createdAt);` | L49 |
| `src\composables\usePlaylistData.js` | `createdAt: playlist.createdAt // Include createdAt for sorting groups` | L125 |
| `src\components\AlbumItem.vue` | `import \{ useUserSpotifyApi \} from '@composables/useUserSpotifyApi';` | L7 |
| `src\composables\useAlbumsData.js` | `import \{ useUserSpotifyApi \} from '@/composables/useUserSpotifyApi';` | L7 |
| `src\composables\useAlbumsData.js` | `const \{ getPlaylistAlbumsWithDates \} = useUserSpotifyApi();` | L363 |
| `src\composables\useAlbumsData.js` | `* Transforms DB album format to Spotify API format for component compatibility` | L509 |
| `src\composables\useAlbumsData.js` | `// Create updated playlist history with the current entry marked as removed` | L612 |
| `src\views\auth\SpotifyCallbackView.vue` | `const \{ exchangeSpotifyCode \} = useBackendApi();` | L15 |
| `src\components\TrackList.vue` | `import \{ useUserSpotifyApi \} from '@composables/useUserSpotifyApi';` | L6 |
| `src\components\TrackList.vue` | `// Spotify API for fetching next album tracks` | L95 |
| `src\components\TrackList.vue` | `const \{ getAlbumTracks \} = useUserSpotifyApi();` | L96 |
| `src\components\TrackList.vue` | `const limit = 50; // Maximum allowed by Spotify API` | L335 |
| `src\components\TrackList.vue` | `// Create context if playing from a playlist` | L444 |
| `src\composables\useUserData.js` | `import \{ useUserSpotifyApi \} from './useUserSpotifyApi';` | L5 |
| `src\composables\useUserData.js` | `const \{ checkConnectionStatus \} = useUserSpotifyApi();` | L13 |
| `src\composables\useBackendApi.js` | `* Make Spotify API call through our proxy` | L91 |
| `src\composables\useBackendApi.js` | `const spotifyApiCall = async (endpoint, method = 'GET', data = null, accessToken) => \{` | L93 |
| `src\composables\useBackendApi.js` | `return makeRequest('spotifyApiProxy', \{` | L94 |
| `src\composables\useBackendApi.js` | `spotifyApiCall,` | L113 |
| `src\composables\useSpotifyPlayer.js` | `import \{ useUserSpotifyApi \} from './useUserSpotifyApi';` | L2 |
| `src\composables\useSpotifyPlayer.js` | `const \{ getUserTokens \} = useUserSpotifyApi();` | L27 |
| `src\components\SpotifyDiagnostic.vue` | `import \{ useUserSpotifyApi \} from '@/composables/useUserSpotifyApi';` | L6 |
| `src\components\SpotifyDiagnostic.vue` | `const \{ getUserTokens, makeUserRequest \} = useUserSpotifyApi();` | L11 |
| `src\components\SpotifyDiagnostic.vue` | `logSpotify('✅ Spotify API test successful');` | L91 |
| `src\components\SpotifyDiagnostic.vue` | `logSpotify('❌ Spotify API test failed:', err.message);` | L94 |
| `src\utils\lastFmUtils.js` | `import \{ useUserSpotifyApi \} from '@composables/useUserSpotifyApi';` | L2 |
| `src\utils\lastFmUtils.js` | `const \{ getAlbumTracks \} = useUserSpotifyApi();` | L85 |
| `src\components\AlbumSearch.vue` | `import \{ useUserSpotifyApi \} from '@composables/useUserSpotifyApi';` | L86 |
| `src\components\AlbumSearch.vue` | `const \{ searchAlbums, loading: spotifyLoading \} = useUserSpotifyApi();` | L98 |
| `src\composables\useUserSpotifyApi.js` | `export function useUserSpotifyApi() \{` | L8 |
| `src\composables\useUserSpotifyApi.js` | `const \{ refreshSpotifyToken, spotifyApiCall \} = useBackendApi();` | L12 |
| `src\composables\useUserSpotifyApi.js` | `logSpotify('API test failed:', apiErr);` | L215 |
| `src\composables\useUserSpotifyApi.js` | `* Makes an authenticated request to the Spotify API using user's token` | L236 |
| `src\composables\useUserSpotifyApi.js` | `return await spotifyApiCall(endpointPath, options.method \|\| 'GET', options.body, accessToken);` | L286 |
| `src\composables\useUserSpotifyApi.js` | `* Creates a new playlist for the user` | L310 |
| `src\composables\useUserSpotifyApi.js` | `const createPlaylist = async (name, description = '', isPublic = false) => \{` | L312 |
| `src\composables\useUserSpotifyApi.js` | `// According to Spotify API docs, we need to use the tracks array format` | L477 |
| `src\composables\useUserSpotifyApi.js` | `createPlaylist,` | L629 |
| `src\views\music\AlbumView.vue` | `import \{ useUserSpotifyApi \} from '@composables/useUserSpotifyApi';` | L4 |
| `src\views\music\AlbumView.vue` | `const \{ getAlbum, getAlbumTracks, getPlaylistAlbumsWithDates\} = useUserSpotifyApi();` | L31 |
| `src\views\music\AlbumView.vue` | `const limit = 50; // Maximum allowed by Spotify API` | L85 |
| `src\views\music\ArtistView.vue` | `import \{ useUserSpotifyApi \} from '@composables/useUserSpotifyApi';` | L10 |
| `src\views\music\ArtistView.vue` | `const \{ getArtist, getArtistAlbums\} = useUserSpotifyApi();` | L22 |
| `src\views\playlists\PlaylistManagementView.vue` | `<!-- Create New Playlist Section -->` | L19 |
| `src\views\playlists\PlaylistManagementView.vue` | `<h2 class="text-lg font-semibold mb-4">Create New Playlist</h2>` | L21 |
| `src\views\playlists\PlaylistManagementView.vue` | `<form @submit.prevent="handleCreatePlaylist" class="space-y-4">` | L23 |
| `src\views\playlists\PlaylistManagementView.vue` | `\{{ spotifyLoading ? 'Creating...' : 'Create Playlist' \}}` | L66 |
| `src\views\playlists\PlaylistManagementView.vue` | `No AudioFoodie playlists found. Create your first AudioFoodie playlist above!` | L135 |
| `src\views\playlists\PlaylistManagementView.vue` | `No playlists found. Create your first playlist above!` | L138 |
| `src\views\playlists\PlaylistManagementView.vue` | `import \{ useUserSpotifyApi \} from '@composables/useUserSpotifyApi';` | L282 |
| `src\views\playlists\PlaylistManagementView.vue` | `createPlaylist,` | L294 |
| `src\views\playlists\PlaylistManagementView.vue` | `\} = useUserSpotifyApi();` | L301 |
| `src\views\playlists\PlaylistManagementView.vue` | `const handleCreatePlaylist = async () => \{` | L325 |
| `src\views\playlists\PlaylistManagementView.vue` | `const playlist = await createPlaylist(` | L330 |
| `src\views\playlists\PlaylistManagementView.vue` | `spotifyError.value = err.message \|\| 'Failed to create playlist';` | L349 |


</details>
</tool-use>

---

<tool-use data-tool-type="search" data-tool-name="web_search">
<details>
            <summary>Tool use: **web_search** • Searched web `Spotify Web API create folders organize playlists` • **1** results</summary>
        
| Title | URL | Chunk |
|-------|-----|-------|
| Web Search Results |  | As of November 2025, Spotify's public Web API does not support the creation or management of playlist folders. This functionality remains exclusive to Spotify's internal applications and is not accessible to third-party developers. ([support.spotify.com](https://support.spotify.com/na-en/article/playlist-folders/?utm_source=openai))<br/><br/>While the API allows for creating and managing individual playlists, it lacks endpoints for organizing these playlists into folders. Consequently, developers seeking to implement folder-like organization must resort to alternative methods.<br/><br/>**Workarounds:**<br/><br/>1. **Naming Conventions:** Implement a consistent naming scheme for your playlists to simulate folder structures. For example, prefixing playlist names with categories like "Rock - Classics" or "Workout - Cardio" can help group related playlists together. This approach relies on visual organization within the Spotify client. ([community.latenode.com](https://community.latenode.com/t/creating-playlist-directories-using-spotifys-application-interface/17263?utm_source=openai))<br/><br/>2. **External Metadata Management:** Maintain an external system or database that maps playlists to virtual folders. This method allows for custom organization within your application but does not reflect in the Spotify client. ([community.latenode.com](https://community.latenode.com/t/creating-playlist-directories-using-spotifys-application-interface/17263?utm_source=openai))<br/><br/>It's important to note that these workarounds do not integrate with Spotify's native folder system and are limited to the environments in which they are implemented.<br/><br/>For the most current information on Spotify's API capabilities, refer to the official Spotify Developer Documentation. ([developer.spotify.com](https://developer.spotify.com/documentation/general/guides/working-with-playlists?utm_source=openai)) |

</details>
</tool-use>

---



---


**No, the Spotify Web API does not support creating folders or organizing playlists into folders.** This is not available to third-party developers.

## What this means

The `pipelineGroups` collection approach works for your use case:

1. Spotify's API only supports:
   - Creating/updating playlists
   - Managing tracks within playlists
   - Querying playlist metadata

2. No folder/folder-like organization is exposed.

3. Your current grouping in Firestore (and the `pipelineGroups` collection proposal) is appropriate, since:
   - You control the organization
   - It isn't constrained by API limits
   - You can store additional group metadata

## Workaround (not recommended)

You could use naming conventions (e.g., "Rock - Queued", "Rock - Checking") to visually group playlists in Spotify, but this:
- Doesn't actually create folders
- Is brittle and user-visible
- Doesn't provide programmatic organization

## Recommendation

Proceed with the `pipelineGroups` collection:
- Store group metadata independently
- Use `groupId` references on playlists
- Compute grouping from pipeline connections
- Keep organization logic in your system, not Spotify

This confirms the refactoring approach aligns with API constraints.

---

_**User (2025-11-19 14:37Z)**_

yes makes sense. make a spec for this work.

---

_**Agent (model default, mode Agent)**_



---


Drafting a specification for the `pipelineGroups` refactor. Checking existing specs for format:


---

<tool-use data-tool-type="read" data-tool-name="read_file">
<details><summary>Tool use: **read_file** • Read file: tasks/pipeline-playlist-spec.md</summary>

</details>
</tool-use>

---

<tool-use data-tool-type="generic" data-tool-name="list_dir">
<details>
            <summary>Tool use: **list_dir** • Listed directory undefined • **0** results</summary>
        
No results found
</details>
</tool-use>

---



---


Creating the specification document:


---

<tool-use data-tool-type="write" data-tool-name="write">

<details><summary>Tool use: **write** • Edit file: tasks/pipeline-groups-refactor-spec.md</summary>

**Chunk 1**
Lines added: 576, lines removed: 1

```diff
@@ -1,1 +1,576 @@
- 
+ # Pipeline Groups Refactoring Specification
+ 
+ ## Overview
+ 
+ This document specifies the refactoring to remove the redundant &#96;group&#96; field from playlist documents and replace it with a &#96;pipelineGroups&#96; collection that stores group metadata separately. Groups will be inferred from pipeline connections using graph traversal, eliminating data redundancy and ensuring consistency.
+ 
+ ## Problem Statement
+ 
+ ### Current Issues
+ 
+ 1. **Data Redundancy**: Each playlist document stores a &#96;group&#96; string field (e.g., "rock", "jazz", "90s"), duplicating the same value across many documents
+ 2. **Storage Inefficiency**: The &#96;group&#96; field is stored on every playlist when it should be a shared entity
+ 3. **Potential Inconsistency**: Multiple playlists in the same pipeline could have different &#96;group&#96; values if data gets out of sync
+ 4. **Group Metadata Limitations**: Cannot easily store additional group metadata (display order, custom sorting, etc.) without adding more redundant fields
+ 
+ ### Current Structure
+ 
+ &#96;&#96;&#96;json
+ // Each playlist stores group redundantly
+ {
+   "playlistId": "spotifyId123",
+   "name": "Rock Checking",
+   "group": "rock",                     // ❌ Stored on EVERY playlist
+   "pipelineRole": "transient",
+   "nextStagePlaylistId": "nicePlaylistId",
+   "terminationPlaylistId": "notCheckingId",
+   "priority": 20,
+   "userId": "user123",
+   "createdAt": "timestamp",
+   "updatedAt": "timestamp"
+ }
+ &#96;&#96;&#96;
+ 
+ ## Solution
+ 
+ ### Core Concept
+ 
+ Groups are **computed from pipeline connections** using graph traversal (connected components). Each group has a single document in the &#96;pipelineGroups&#96; collection that stores metadata, and playlists reference it via &#96;groupId&#96;.
+ 
+ ### Key Principles
+ 
+ 1. **Single Source of Truth**: Group metadata exists in one place (&#96;pipelineGroups&#96; collection)
+ 2. **Graph-Based Inference**: Groups are determined by pipeline connections (not manually assigned)
+ 3. **Reference-Based**: Playlists reference groups via &#96;groupId&#96; field
+ 4. **Validation**: All connected playlists must reference the same group
+ 
+ ## Data Structure Changes
+ 
+ ### New Collection: &#96;pipelineGroups&#96;
+ 
+ &#96;&#96;&#96;json
+ {
+   "groupId": "auto-generated-firebase-id",
+   "name": "rock",                     // Display name (e.g., "rock", "jazz", "90s")
+   "userId": "user123",                // Owner of the group
+   "displayOrder": 0,                  // Optional: for custom sorting of groups in UI
+   "createdAt": "timestamp",
+   "updatedAt": "timestamp"
+ }
+ &#96;&#96;&#96;
+ 
+ **Fields:**
+ - &#96;groupId&#96; (string): Auto-generated Firestore document ID
+ - &#96;name&#96; (string): Display name for the group (required)
+ - &#96;userId&#96; (string): Owner user ID (required)
+ - &#96;displayOrder&#96; (number, optional): Custom sort order for groups
+ - &#96;createdAt&#96; (timestamp): Creation timestamp
+ - &#96;updatedAt&#96; (timestamp): Last update timestamp
+ 
+ **Indexes:**
+ - Single field index on &#96;userId&#96; (for querying user's groups)
+ 
+ ### Updated Collection: &#96;playlists&#96;
+ 
+ &#96;&#96;&#96;json
+ {
+   "playlistId": "spotifyId123",
+   "name": "Rock Checking",
+   "groupId": "group-doc-id",          // ✅ Reference to pipelineGroups document (replaces "group" string)
+   "pipelineRole": "transient",
+   "nextStagePlaylistId": "firebaseId...",
+   "terminationPlaylistId": "firebaseId...",
+   "priority": 20,
+   "userId": "user123",
+   "type": "rock",                     // Backward compatibility (legacy)
+   "category": "checking",             // Backward compatibility (legacy)
+   "createdAt": "timestamp",
+   "updatedAt": "timestamp"
+ }
+ &#96;&#96;&#96;
+ 
+ **Changes:**
+ - ❌ Remove: &#96;group&#96; (string) field
+ - ✅ Add: &#96;groupId&#96; (string) - Reference to &#96;pipelineGroups&#96; document
+ 
+ **Indexes:**
+ - Single field index on &#96;userId&#96; (existing)
+ - Single field index on &#96;groupId&#96; (new - for querying playlists by group)
+ - Composite index on &#96;userId&#96;, &#96;groupId&#96;, &#96;priority&#96; (for sorting playlists within groups)
+ 
+ ## Group Inference Algorithm
+ 
+ ### Connected Components Approach
+ 
+ Groups are determined by finding connected components in the playlist graph:
+ 
+ 1. **Build Graph**: Create adjacency map from pipeline connections
+    - Forward edges: &#96;nextStagePlaylistId&#96; connections
+    - Reverse edges: Playlists that reference this playlist as their &#96;nextStagePlaylistId&#96; or &#96;terminationPlaylistId&#96;
+ 
+ 2. **Traverse Components**: For each unvisited playlist:
+    - Start BFS/DFS from current playlist
+    - Follow both &#96;nextStagePlaylistId&#96; and &#96;terminationPlaylistId&#96; connections (bidirectional)
+    - Also follow reverse connections (playlists that point TO this one)
+    - All reachable playlists belong to the same component (group)
+ 
+ 3. **Group Assignment**:
+    - If playlists in component already have a &#96;groupId&#96;: Use existing group
+    - If no &#96;groupId&#96; exists (new pipeline): Create new &#96;pipelineGroups&#96; document and assign to all playlists
+    - If mixed &#96;groupId&#96; values: Validation error (data inconsistency)
+ 
+ ### Algorithm Pseudocode
+ 
+ &#96;&#96;&#96;javascript
+ function computeGroups(playlists) {
+   const graph = buildGraph(playlists);
+   const visited = new Set();
+   const groups = [];
+   
+   for (const playlist of playlists) {
+     if (visited.has(playlist.id)) continue;
+     
+     // Find connected component via BFS
+     const component = findConnectedComponent(playlist.id, graph);
+     component.forEach(id =&gt; visited.add(id));
+     
+     // Determine groupId for component
+     const groupId = determineGroupId(component, playlists);
+     groups.push({ groupId, playlistIds: component });
+   }
+   
+   return groups;
+ }
+ 
+ function findConnectedComponent(startId, graph) {
+   const component = [];
+   const queue = [startId];
+   const visited = new Set([startId]);
+   
+   while (queue.length &gt; 0) {
+     const currentId = queue.shift();
+     component.push(currentId);
+     
+     // Follow forward connections
+     const neighbors = graph[currentId] || [];
+     for (const neighborId of neighbors) {
+       if (!visited.has(neighborId)) {
+         visited.add(neighborId);
+         queue.push(neighborId);
+       }
+     }
+     
+     // Follow reverse connections
+     const reverseNeighbors = graph.getReverse(currentId) || [];
+     for (const reverseId of reverseNeighbors) {
+       if (!visited.has(reverseId)) {
+         visited.add(reverseId);
+         queue.push(reverseId);
+       }
+     }
+   }
+   
+   return component;
+ }
+ &#96;&#96;&#96;
+ 
+ ### Edge Cases
+ 
+ 1. **Orphaned Playlists** (no connections):
+    - If &#96;groupId&#96; exists: Use existing group
+    - If no &#96;groupId&#96;: Create new group or assign to default group based on &#96;type&#96;
+ 
+ 2. **Multiple Sources** (multiple entry points):
+    - All sources in same connected component share the same group
+    - Group name can be user-defined or derived from first source playlist
+ 
+ 3. **Disconnected Components** (same group name, different graphs):
+    - Should have separate group documents (different &#96;groupId&#96;)
+    - UI can still group them visually by name if desired
+ 
+ ## Migration Strategy
+ 
+ ### Phase 1: Add New Structure (Backward Compatible)
+ 
+ **Goal**: Add &#96;pipelineGroups&#96; collection and &#96;groupId&#96; field without breaking existing functionality
+ 
+ **Tasks:**
+ 1. Create &#96;pipelineGroups&#96; collection schema
+ 2. Add Firestore indexes for new fields
+ 3. Update Firestore security rules for &#96;pipelineGroups&#96; collection
+ 4. Add &#96;groupId&#96; field to playlist creation/editing (optional during transition)
+ 5. Implement group computation algorithm (for new pipelines)
+ 6. Keep existing &#96;group&#96; field functional (for backward compatibility)
+ 
+ **New Firestore Rules:**
+ &#96;&#96;&#96;javascript
+ match /pipelineGroups/{groupId} {
+   allow read: if request.auth != null &amp;&amp; resource.data.userId == request.auth.uid;
+   allow create: if request.auth != null &amp;&amp; request.resource.data.userId == request.auth.uid;
+   allow update: if request.auth != null &amp;&amp; resource.data.userId == request.auth.uid;
+   allow delete: if request.auth != null &amp;&amp; resource.data.userId == request.auth.uid;
+ }
+ &#96;&#96;&#96;
+ 
+ **Indexes to Add:**
+ &#96;&#96;&#96;json
+ {
+   "indexes": [
+     {
+       "collectionGroup": "pipelineGroups",
+       "queryScope": "COLLECTION",
+       "fields": [
+         { "fieldPath": "userId", "order": "ASCENDING" }
+       ]
+     },
+     {
+       "collectionGroup": "playlists",
+       "queryScope": "COLLECTION",
+       "fields": [
+         { "fieldPath": "userId", "order": "ASCENDING" },
+         { "fieldPath": "groupId", "order": "ASCENDING" },
+         { "fieldPath": "priority", "order": "ASCENDING" }
+       ]
+     }
+   ]
+ }
+ &#96;&#96;&#96;
+ 
+ ### Phase 2: Migration Script
+ 
+ **Goal**: Migrate existing playlists to new structure
+ 
+ **Migration Script Logic:**
+ &#96;&#96;&#96;javascript
+ async function migratePlaylists() {
+   // 1. Fetch all playlists for all users
+   const allPlaylists = await getAllPlaylists();
+   
+   // 2. Group playlists by userId
+   const playlistsByUser = groupBy(allPlaylists, 'userId');
+   
+   // 3. For each user:
+   for (const [userId, userPlaylists] of Object.entries(playlistsByUser)) {
+     // 4. Compute connected components
+     const groups = computeGroups(userPlaylists);
+     
+     // 5. For each connected component:
+     for (const group of groups) {
+       // 6. Check if group document already exists
+       let groupDoc = await findGroupByName(userId, group.name);
+       
+       // 7. If not, create new group document
+       if (!groupDoc) {
+         groupDoc = await createGroup({
+           userId,
+           name: group.name,
+           displayOrder: getDisplayOrder(group.name)
+         });
+       }
+       
+       // 8. Update all playlists in component with groupId
+       for (const playlistId of group.playlistIds) {
+         await updatePlaylist(playlistId, {
+           groupId: groupDoc.id
+           // Keep 'group' field for backward compatibility during transition
+         });
+       }
+     }
+   }
+ }
+ &#96;&#96;&#96;
+ 
+ **Migration Mapping:**
+ - For existing playlists with &#96;group&#96; field: Create &#96;pipelineGroups&#96; document and assign &#96;groupId&#96;
+ - For playlists without connections: Use &#96;type&#96; field as group name fallback
+ - Validate: Ensure all playlists in same component get same &#96;groupId&#96;
+ 
+ ### Phase 3: Update Application Code
+ 
+ **Goal**: Update codebase to use &#96;groupId&#96; references and group computation
+ 
+ **Tasks:**
+ 1. **Create &#96;usePipelineGroups&#96; composable:**
+    - &#96;fetchUserGroups(userId)&#96; - Fetch all groups for user
+    - &#96;createGroup(name, userId)&#96; - Create new group
+    - &#96;updateGroup(groupId, updates)&#96; - Update group metadata
+    - &#96;deleteGroup(groupId)&#96; - Delete group (validate no playlists reference it)
+    - &#96;computeGroupsFromPlaylists(playlists)&#96; - Compute groups from connections
+    - &#96;getGroupForPlaylist(playlistId)&#96; - Get group for a specific playlist
+ 
+ 2. **Update &#96;usePlaylistData&#96; composable:**
+    - Change &#96;getAvailableGroups()&#96; to query &#96;pipelineGroups&#96; collection
+    - Join with playlists to filter groups that have playlists
+    - Group playlists by &#96;groupId&#96; instead of &#96;group&#96; string
+ 
+ 3. **Update Playlist Views:**
+    - &#96;AddPlaylistView.vue&#96;: Add group selection/creation UI
+    - &#96;EditPlaylistView.vue&#96;: Show group name from &#96;pipelineGroups&#96;, allow changing &#96;groupId&#96;
+    - &#96;PlaylistView.vue&#96;: Use &#96;groupId&#96; for grouping, display group names from &#96;pipelineGroups&#96;
+ 
+ 4. **Update Playlist CRUD Operations:**
+    - On playlist creation: Compute or assign &#96;groupId&#96;
+    - On playlist update: Validate &#96;groupId&#96; consistency with connections
+    - On connection changes: Recompute groups if necessary
+ 
+ 5. **Update Validation:**
+    - Ensure all connected playlists share same &#96;groupId&#96;
+    - Validate &#96;nextStagePlaylistId&#96; and &#96;terminationPlaylistId&#96; reference playlists with same &#96;groupId&#96;
+ 
+ ### Phase 4: Group Management UI
+ 
+ **Goal**: Add UI for managing groups
+ 
+ **New Features:**
+ 1. **Group Management Page:**
+    - List all user's groups
+    - Create new groups
+    - Edit group names and display order
+    - Delete groups (with validation)
+ 
+ 2. **Group Selection in Playlist Forms:**
+    - Dropdown to select existing group
+    - Option to create new group
+    - For new playlists: Auto-assign group based on connections
+ 
+ 3. **Group Display:**
+    - Show group name from &#96;pipelineGroups&#96; collection
+    - Sort groups by &#96;displayOrder&#96; or creation date
+    - Visual indicators for group relationships
+ 
+ ### Phase 5: Remove Legacy Fields
+ 
+ **Goal**: Clean up backward compatibility code
+ 
+ **Tasks:**
+ 1. Remove &#96;group&#96; field from playlist documents (migration script)
+ 2. Remove &#96;group&#96; field from all TypeScript/JavaScript types
+ 3. Update all queries to use &#96;groupId&#96; instead of &#96;group&#96;
+ 4. Remove fallback logic for &#96;group&#96; field
+ 5. Update documentation
+ 
+ ## Validation Rules
+ 
+ ### Group Assignment Validation
+ 
+ - All playlists in the same connected component must have the same &#96;groupId&#96;
+ - If a playlist's connections change, validate that new connections are within the same group
+ - On playlist creation: If connecting to existing playlist, use that playlist's &#96;groupId&#96;
+ 
+ ### Pipeline Connection Validation
+ 
+ - &#96;nextStagePlaylistId&#96; must reference a playlist with the same &#96;groupId&#96;
+ - &#96;terminationPlaylistId&#96; must reference a playlist with the same &#96;groupId&#96;
+ - When updating connections, ensure &#96;groupId&#96; consistency
+ 
+ ### Group Reference Validation
+ 
+ - &#96;groupId&#96; must reference a valid &#96;pipelineGroups&#96; document
+ - &#96;pipelineGroups&#96; document must belong to the same user as the playlist
+ - Cannot delete a group that has playlists referencing it
+ 
+ ### Data Consistency Checks
+ 
+ &#96;&#96;&#96;javascript
+ async function validateGroupConsistency(userId) {
+   const playlists = await getPlaylistsByUser(userId);
+   const groups = computeGroups(playlists);
+   
+   const errors = [];
+   
+   for (const group of groups) {
+     const groupIds = group.playlistIds
+       .map(id =&gt; playlists.find(p =&gt; p.id === id)?.groupId)
+       .filter(Boolean);
+     
+     const uniqueGroupIds = new Set(groupIds);
+     
+     if (uniqueGroupIds.size &gt; 1) {
+       errors.push({
+         component: group.playlistIds,
+         conflictingGroupIds: Array.from(uniqueGroupIds)
+       });
+     }
+   }
+   
+   return errors;
+ }
+ &#96;&#96;&#96;
+ 
+ ## Implementation Details
+ 
+ ### New Composable: &#96;usePipelineGroups.js&#96;
+ 
+ &#96;&#96;&#96;javascript
+ export function usePipelineGroups() {
+   const groups = ref([]);
+   const loading = ref(false);
+   const error = ref(null);
+   
+   const fetchUserGroups = async (userId) =&gt; {
+     // Query pipelineGroups collection by userId
+   };
+   
+   const createGroup = async (name, userId, displayOrder = 0) =&gt; {
+     // Create new pipelineGroups document
+   };
+   
+   const updateGroup = async (groupId, updates) =&gt; {
+     // Update group metadata
+   };
+   
+   const deleteGroup = async (groupId) =&gt; {
+     // Validate no playlists reference it, then delete
+   };
+   
+   const computeGroupsFromPlaylists = (playlists) =&gt; {
+     // Graph traversal algorithm
+   };
+   
+   const assignGroupIdToPlaylist = async (playlistId, groupId) =&gt; {
+     // Update playlist with groupId reference
+   };
+   
+   return {
+     groups,
+     loading,
+     error,
+     fetchUserGroups,
+     createGroup,
+     updateGroup,
+     deleteGroup,
+     computeGroupsFromPlaylists,
+     assignGroupIdToPlaylist
+   };
+ }
+ &#96;&#96;&#96;
+ 
+ ### Updated Query Pattern
+ 
+ **Before:**
+ &#96;&#96;&#96;javascript
+ // Group by string field
+ const grouped = {};
+ playlists.forEach(p =&gt; {
+   const group = p.group || 'unknown';
+   if (!grouped[group]) grouped[group] = [];
+   grouped[group].push(p);
+ });
+ &#96;&#96;&#96;
+ 
+ **After:**
+ &#96;&#96;&#96;javascript
+ // Join with pipelineGroups collection
+ const groups = await fetchUserGroups(userId);
+ const groupsMap = new Map(groups.map(g =&gt; [g.id, g]));
+ 
+ const grouped = {};
+ playlists.forEach(p =&gt; {
+   const group = groupsMap.get(p.groupId);
+   const groupName = group?.name || 'unknown';
+   if (!grouped[groupName]) grouped[groupName] = [];
+   grouped[groupName].push(p);
+ });
+ &#96;&#96;&#96;
+ 
+ ## Testing Strategy
+ 
+ ### Unit Tests
+ 
+ 1. **Group Computation Algorithm:**
+    - Test connected component detection
+    - Test with multiple disconnected components
+    - Test with orphaned playlists
+    - Test with circular references (should be prevented)
+ 
+ 2. **Group CRUD Operations:**
+    - Create group
+    - Update group metadata
+    - Delete group (with validation)
+    - Fetch user groups
+ 
+ 3. **Validation Logic:**
+    - Validate groupId consistency
+    - Validate connection constraints
+    - Validate reference integrity
+ 
+ ### Integration Tests
+ 
+ 1. **Migration Script:**
+    - Test migration on sample data
+    - Verify all playlists get groupId assigned
+    - Verify group documents are created correctly
+    - Verify backward compatibility maintained
+ 
+ 2. **Playlist Operations:**
+    - Create playlist with group assignment
+    - Update playlist connections (verify group consistency)
+    - Delete playlist (verify group cleanup if needed)
+ 
+ 3. **UI Components:**
+    - Group selection in forms
+    - Group display in playlist views
+    - Group management interface
+ 
+ ### Manual Testing Checklist
+ 
+ - [ ] Create new playlist without connections → Assigns to new or default group
+ - [ ] Create new playlist with connection → Inherits group from connected playlist
+ - [ ] Update playlist connection → Validates group consistency
+ - [ ] Create new group → Appears in group selector
+ - [ ] Delete group with playlists → Validation error
+ - [ ] Delete group without playlists → Success
+ - [ ] Migration script runs without errors
+ - [ ] Existing functionality still works after migration
+ 
+ ## Rollback Plan
+ 
+ If issues arise during migration:
+ 
+ 1. **Keep Backward Compatibility:**
+    - Maintain &#96;group&#96; field during Phase 1-3
+    - Code falls back to &#96;group&#96; field if &#96;groupId&#96; is missing
+    - Allows gradual migration and rollback
+ 
+ 2. **Rollback Script:**
+    - Restore &#96;group&#96; field from &#96;pipelineGroups&#96; name
+    - Remove &#96;groupId&#96; references
+    - Delete &#96;pipelineGroups&#96; collection
+ 
+ 3. **Staged Rollout:**
+    - Test migration on staging environment first
+    - Migrate one user at a time if possible
+    - Monitor for errors before full rollout
+ 
+ 4. **Data Validation:**
+    - Validate data consistency before and after migration
+    - Keep backups of original data
+    - Ability to revert individual playlists if needed
+ 
+ ## Success Criteria
+ 
+ - [ ] All playlists have &#96;groupId&#96; field
+ - [ ] All groups have corresponding &#96;pipelineGroups&#96; documents
+ - [ ] Group computation algorithm correctly identifies connected components
+ - [ ] UI displays groups correctly
+ - [ ] No data redundancy (group name stored once per group)
+ - [ ] Validation prevents group inconsistencies
+ - [ ] Migration script completes successfully
+ - [ ] No regression in existing functionality
+ 
+ ## Future Enhancements
+ 
+ 1. **Group Metadata:**
+    - Custom group descriptions
+    - Group icons/colors
+    - Group-level settings
+ 
+ 2. **Group Sharing:**
+    - Share group templates between users
+    - Export/import group structures
+ 
+ 3. **Advanced Grouping:**
+    - Nested groups (if needed in future)
+    - Group hierarchies
+    - Dynamic group computation rules
+ 
```

</details>

</tool-use>

---



---


Checking for linting issues:


---

<tool-use data-tool-type="generic" data-tool-name="read_lints">
<details>
          <summary>Tool use: **read_lints** • Read lints for 1 file</summary>
      
Lint paths:

- `tasks/pipeline-groups-refactor-spec.md`

Lint results


**No lint errors found**
</details>
</tool-use>

---



---


Created the specification document at `tasks/pipeline-groups-refactor-spec.md`. It includes:

## Specification Highlights

1. **Problem statement**: Redundancy and inefficiency of storing `group` on every playlist
2. **Solution**: `pipelineGroups` collection with graph-based inference
3. **Data structures**:
   - New `pipelineGroups` collection schema
   - Updated `playlists` collection (replacing `group` with `groupId`)
4. **Group inference algorithm**: Connected components via graph traversal (pseudocode included)
5. **Migration strategy**: 5-phase approach:
   - Phase 1: Add new structure (backward compatible)
   - Phase 2: Migration script
   - Phase 3: Update application code
   - Phase 4: Group management UI
   - Phase 5: Remove legacy fields
6. **Validation rules**: Group assignment, connection constraints, data consistency
7. **Implementation details**: New composable structure, query patterns, code examples
8. **Testing strategy**: Unit, integration, and manual testing checklists
9. **Rollback plan**: Safety measures and staged rollout approach

The spec is ready for implementation. It follows the same format as your other specification documents and provides a roadmap for the refactoring work.

---

