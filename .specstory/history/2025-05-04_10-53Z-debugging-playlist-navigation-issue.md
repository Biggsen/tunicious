<!-- Generated by SpecStory, Markdown v2.1.0 -->

<!-- cursor Session 3ca57900-5b4d-4681-8663-99cba864b6db (2025-05-04 10:53Z) -->

# Debugging Playlist Navigation Issue (2025-05-04 10:53Z)

_**User (2025-05-04 09:28Z)**_

something strange is going on. When clicking on 'Known Curious' playlist on the playlists page, it loads up the 'New queued' playlist? the new queue playlist has the spotify id of 50mWTRVvyIC3lUjTJ3r5KV, while the known curious is 6LPO8pVjeuK2PbhvXxmlHe. Can we debug this?

---

_**Agent (mode Ask)**_

Here’s how we can debug this issue step by step:

### 1. Identify the Playlist Navigation Logic
The problem is likely in how the app routes to the playlist detail page or how it fetches the playlist data after navigation. We need to check:
- How the playlist is selected/clicked on the playlists page.
- How the app determines which playlist to load in the detail view.

### 2. Key Files to Inspect
Based on your file structure, the relevant files are likely:
- `src/views/playlists/PlaylistView.vue` (the main playlists page)
- `src/views/playlists/PlaylistSingle.vue` (the single playlist detail page)
- `src/composables/usePlaylistData.js` (playlist data fetching logic)
- `src/router/index.js` (route definitions)

### 3. What to Look For
- How the playlist ID is passed from the playlists page to the detail page (likely via route params).
- How the detail page fetches the playlist (does it use the correct ID from the route?).
- Any logic that could cause the wrong ID to be used (e.g., off-by-one errors, incorrect mapping, or state issues).

Would you like to start by inspecting the navigation (how the click event is handled and what route is pushed), or by looking at how the detail page fetches the playlist data? If you want, I can suggest which file/section to check first.

---

_**User (2025-05-04 09:28Z)**_

when going to this route: http://localhost:5173/playlist/6LPO8pVjeuK2PbhvXxmlHe, it display the 'New queued' playlist, which is incorrect. so it's something about the playlist page.

---

_**Agent (mode Ask)**_

Given that the URL contains the correct playlist ID (`6LPO8pVjeuK2PbhvXxmlHe` for "Known Curious"), but the page displays the wrong playlist ("New queued"), the issue is likely in how the `PlaylistSingle.vue` page fetches and displays playlist data based on the route parameter.

Here’s what to check next:

### 1. Route Param Usage in PlaylistSingle.vue
- Is the component correctly reading the playlist ID from the route?
- Is it using that ID to fetch the playlist data?

### 2. Data Fetching Logic
- Is the fetching logic (probably in a composable or directly in the component) using the correct ID?
- Is there any caching or state that could be returning the wrong playlist?

### 3. Playlist Data Source
- Is the playlist data being filtered or mapped incorrectly?

#### Next Steps
Would you like to see the relevant code in `PlaylistSingle.vue` (and possibly the composable it uses) to check how the playlist ID is handled and how the data is fetched? If so, let me know and I’ll guide you on what to look for or suggest a code search to pinpoint the logic.

---

_**User (2025-05-04 09:28Z)**_

start digging.

---

_**Agent (mode Ask)**_

<tool-use data-tool-type="search" data-tool-name="codebase_search">

</tool-use>

---

<tool-use data-tool-type="search" data-tool-name="grep_search">
<details>
            <summary>Tool use: **grep_search** • Grep search for "playlistId" • **6** files</summary>
        
| File | Line | Match |
|------|------|-------|
| `file:///c%3A/Users/biggs/webdev/audiofoodiev2/src/views/playlists/PlaylistSingle.vue` | L72 | `async function fetchPlaylistData(playlistId) \{` |
| `file:///c%3A/Users/biggs/webdev/audiofoodiev2/src/views/playlists/PlaylistSingle.vue` | L84 | `const playlistResponse = await getPlaylist(playlistId);` |
| `file:///c%3A/Users/biggs/webdev/audiofoodiev2/src/views/playlists/PlaylistSingle.vue` | L88 | `const albumsWithDates = await getPlaylistAlbumsWithDates(playlistId);` |
| `file:///c%3A/Users/biggs/webdev/audiofoodiev2/src/views/playlists/PlaylistSingle.vue` | L131 | `const q = query(playlistsRef, where('playlistId', '==', id.value));` |
| `file:///c%3A/Users/biggs/webdev/audiofoodiev2/src/views/playlists/PlaylistSingle.vue` | L213 | `if (currentInfo && currentInfo.playlistId !== id.value) \{` |
| `file:///c%3A/Users/biggs/webdev/audiofoodiev2/src/views/playlists/PlaylistSingle.vue` | L214 | `console.log('Album has moved:', album.name, 'Current playlist:', currentInfo.playlistId, 'Viewing playlist:', id.value);` |
| `file:///c%3A/Users/biggs/webdev/audiofoodiev2/src/views/playlists/PlaylistSingle.vue` | L217 | `console.log('Album has not moved:', album.name, currentInfo ? `Current playlist: $\{currentInfo.playlistId\}` : 'No current info');` |
| `file:///c%3A/Users/biggs/webdev/audiofoodiev2/src/views/playlists/PlaylistSingle.vue` | L238 | `playlistId: id.value,` |
| `file:///c%3A/Users/biggs/webdev/audiofoodiev2/src/views/playlists/PlaylistSingle.vue` | L312 | `:currentPlaylist="\{ playlistId: id \}"` |
| `file:///c%3A/Users/biggs/webdev/audiofoodiev2/src/views/playlists/PlaylistView.vue` | L114 | `if (!playlistData?.playlistId) \{` |
| `file:///c%3A/Users/biggs/webdev/audiofoodiev2/src/views/playlists/PlaylistView.vue` | L119 | `console.log(`Fetching Spotify data for $\{type\}/$\{category\} ($\{playlistData.playlistId\})`);` |
| `file:///c%3A/Users/biggs/webdev/audiofoodiev2/src/views/playlists/PlaylistView.vue` | L120 | `const playlist = await getPlaylist(playlistData.playlistId);` |
| `file:///c%3A/Users/biggs/webdev/audiofoodiev2/src/views/playlists/AddPlaylistView.vue` | L11 | `<label for="playlistId">Spotify Playlist ID</label>` |
| `file:///c%3A/Users/biggs/webdev/audiofoodiev2/src/views/playlists/AddPlaylistView.vue` | L14 | `id="playlistId"` |
| `file:///c%3A/Users/biggs/webdev/audiofoodiev2/src/views/playlists/AddPlaylistView.vue` | L15 | `v-model="form.playlistId"` |
| `file:///c%3A/Users/biggs/webdev/audiofoodiev2/src/views/playlists/AddPlaylistView.vue` | L18 | `:class="\{ 'error': formError?.playlistId \}"` |
| `file:///c%3A/Users/biggs/webdev/audiofoodiev2/src/views/playlists/AddPlaylistView.vue` | L20 | `<span v-if="formError?.playlistId" class="error-text">\{{ formError.playlistId \}}</span>` |
| `file:///c%3A/Users/biggs/webdev/audiofoodiev2/src/views/playlists/AddPlaylistView.vue` | L108 | `playlistId: '',` |
| `file:///c%3A/Users/biggs/webdev/audiofoodiev2/src/views/playlists/AddPlaylistView.vue` | L115 | `playlistId: \{ required: true, minLength: 1 \},` |
| `file:///c%3A/Users/biggs/webdev/audiofoodiev2/src/views/playlists/AddPlaylistView.vue` | L134 | `form.playlistId = '';` |
| `file:///c%3A/Users/biggs/webdev/audiofoodiev2/src/views/music/AlbumView.vue` | L63 | `// If there's no playlistId in the URL or no current playlist info, return false` |
| `file:///c%3A/Users/biggs/webdev/audiofoodiev2/src/views/music/AlbumView.vue` | L64 | `if (!playlistId.value \|\| !currentPlaylistInfo.value) \{` |
| `file:///c%3A/Users/biggs/webdev/audiofoodiev2/src/views/music/AlbumView.vue` | L68 | `// Return true if the current playlist ID doesn't match the URL query playlistId` |
| `file:///c%3A/Users/biggs/webdev/audiofoodiev2/src/views/music/AlbumView.vue` | L69 | `return currentPlaylistInfo.value.playlistId !== playlistId.value;` |
| `file:///c%3A/Users/biggs/webdev/audiofoodiev2/src/views/music/AlbumView.vue` | L72 | `const playlistId = computed(() => route.query.playlistId);` |
| `file:///c%3A/Users/biggs/webdev/audiofoodiev2/src/views/music/AlbumView.vue` | L73 | `const isFromPlaylist = computed(() => !!playlistId.value);` |
| `file:///c%3A/Users/biggs/webdev/audiofoodiev2/src/views/music/AlbumView.vue` | L113 | `if (!user.value \|\| !album.value \|\| !playlistId.value) return;` |
| `file:///c%3A/Users/biggs/webdev/audiofoodiev2/src/views/music/AlbumView.vue` | L119 | `playlistId: playlistId.value` |
| `file:///c%3A/Users/biggs/webdev/audiofoodiev2/src/views/music/AlbumView.vue` | L131 | `if (!user.value \|\| !album.value \|\| !playlistId.value) return;` |
| `file:///c%3A/Users/biggs/webdev/audiofoodiev2/src/views/music/AlbumView.vue` | L153 | `const q = query(playlistsRef, where('playlistId', '==', playlistId.value));` |
| `file:///c%3A/Users/biggs/webdev/audiofoodiev2/src/views/music/AlbumView.vue` | L164 | `const albumsWithDates = await getPlaylistAlbumsWithDates(playlistId.value);` |
| `file:///c%3A/Users/biggs/webdev/audiofoodiev2/src/views/music/AlbumView.vue` | L183 | `if (!user.value \|\| !album.value \|\| !playlistId.value) return;` |
| `file:///c%3A/Users/biggs/webdev/audiofoodiev2/src/views/music/AlbumView.vue` | L191 | `const q = query(playlistsRef, where('playlistId', '==', playlistId.value));` |
| `file:///c%3A/Users/biggs/webdev/audiofoodiev2/src/components/AlbumItem.vue` | L74 | `if (!user.value \|\| !props.album \|\| !props.currentPlaylist?.playlistId) return;` |
| `file:///c%3A/Users/biggs/webdev/audiofoodiev2/src/components/AlbumItem.vue` | L80 | `playlistId: props.currentPlaylist.playlistId` |
| `file:///c%3A/Users/biggs/webdev/audiofoodiev2/src/components/AlbumItem.vue` | L117 | `query: currentPlaylist && !isMappedAlbum ? \{ playlistId: currentPlaylist.playlistId \} : undefined` |
| `file:///c%3A/Users/biggs/webdev/audiofoodiev2/src/views/music/AlbumView.vue` | L63 | `// If there's no playlistId in the URL or no current playlist info, return false` |
| `file:///c%3A/Users/biggs/webdev/audiofoodiev2/src/views/music/AlbumView.vue` | L64 | `if (!playlistId.value \|\| !currentPlaylistInfo.value) \{` |
| `file:///c%3A/Users/biggs/webdev/audiofoodiev2/src/views/music/AlbumView.vue` | L68 | `// Return true if the current playlist ID doesn't match the URL query playlistId` |
| `file:///c%3A/Users/biggs/webdev/audiofoodiev2/src/views/music/AlbumView.vue` | L69 | `return currentPlaylistInfo.value.playlistId !== playlistId.value;` |
| `file:///c%3A/Users/biggs/webdev/audiofoodiev2/src/views/music/AlbumView.vue` | L72 | `const playlistId = computed(() => route.query.playlistId);` |
| `file:///c%3A/Users/biggs/webdev/audiofoodiev2/src/views/music/AlbumView.vue` | L73 | `const isFromPlaylist = computed(() => !!playlistId.value);` |
| `file:///c%3A/Users/biggs/webdev/audiofoodiev2/src/views/music/AlbumView.vue` | L113 | `if (!user.value \|\| !album.value \|\| !playlistId.value) return;` |
| `file:///c%3A/Users/biggs/webdev/audiofoodiev2/src/views/music/AlbumView.vue` | L119 | `playlistId: playlistId.value` |
| `file:///c%3A/Users/biggs/webdev/audiofoodiev2/src/views/music/AlbumView.vue` | L131 | `if (!user.value \|\| !album.value \|\| !playlistId.value) return;` |
| `file:///c%3A/Users/biggs/webdev/audiofoodiev2/src/views/music/AlbumView.vue` | L153 | `const q = query(playlistsRef, where('playlistId', '==', playlistId.value));` |
| `file:///c%3A/Users/biggs/webdev/audiofoodiev2/src/views/music/AlbumView.vue` | L164 | `const albumsWithDates = await getPlaylistAlbumsWithDates(playlistId.value);` |
| `file:///c%3A/Users/biggs/webdev/audiofoodiev2/src/views/music/AlbumView.vue` | L183 | `if (!user.value \|\| !album.value \|\| !playlistId.value) return;` |
| `file:///c%3A/Users/biggs/webdev/audiofoodiev2/src/views/music/AlbumView.vue` | L191 | `const q = query(playlistsRef, where('playlistId', '==', playlistId.value));` |

</details>
</tool-use>

---

<tool-use data-tool-type="read" data-tool-name="read_file">
<details><summary>Tool use: **read_file** • Read file: src/views/playlists/PlaylistSingle.vue</summary>

</details>
</tool-use>

---

<tool-use data-tool-type="read" data-tool-name="read_file">
<details><summary>Tool use: **read_file** • Read file: src/views/playlists/PlaylistSingle.vue</summary>

</details>
</tool-use>

---

<tool-use data-tool-type="read" data-tool-name="read_file">
<details><summary>Tool use: **read_file** • Read file: src/router/index.js</summary>

</details>
</tool-use>

---

<tool-use data-tool-type="search" data-tool-name="codebase_search">
<details>
                <summary>Tool use: **codebase_search** • Searched codebase "getPlaylist" • **25** results</summary>
            
| File | Lines |
|------|-------|
| `src/composables/usePlaylistData.js` | L36-65 |
| `src/composables/usePlaylistData.js` | L1-36 |
| `src/composables/usePlaylistData.js` | L65-120 |
| `src/composables/useSpotifyApi.js` | L55-135 |
| `src/composables/useAlbumsData.js` | L94-135 |
| `src/composables/useAlbumsData.js` | L1-32 |
| `src/composables/useSpotifyApi.js` | L179-232 |
| `src/composables/usePlaylistMovement.js` | L41-98 |
| `src/composables/usePlaylistMovement.js` | L1-41 |
| `src/composables/useAlbumsData.js` | L271-318 |
| `src/composables/useAlbumsData.js` | L32-94 |
| `src/composables/useAlbumsData.js` | L234-271 |
| `src/composables/usePlaylistMovement.js` | L98-122 |
| `src/composables/useSpotifyApi.js` | L135-179 |
| `src/composables/useSpotifyApi.js` | L1-55 |
| `src/composables/useAlbumsData.js` | L135-171 |
| `src/composables/useAlbumMappings.js` | L1-65 |
| `src/composables/useAlbumsData.js` | L171-234 |
| `src/composables/useAlbumMappings.js` | L65-133 |
| `src/composables/usePagination.js` | L1-47 |
| `src/composables/useUserData.js` | L1-51 |
| `src/composables/useSorting.js` | L1-64 |
| `src/composables/useCache.js` | L1-59 |
| `src/composables/useAuth.js` | L1-64 |
| `src/composables/useAuth.js` | L64-72 |

</details>
</tool-use>

---

Here’s what I’ve found so far:

### 1. Route and Param Handling
- The route `/playlist/:id` is correctly set up in the router, and in `PlaylistSingle.vue`, the playlist ID is accessed as `route.params.id` (via a computed property called `id`).

### 2. Data Fetching
- The function `fetchPlaylistData(playlistId)` is called with `id.value` (the route param) and uses this to fetch the playlist from Spotify (`getPlaylist(playlistId)`) and to get albums from the playlist.
- The Firestore playlist document is also fetched using `where('playlistId', '==', id.value)`.

### 3. Spotify API
- The `getPlaylist` function in `useSpotifyApi.js` simply calls the Spotify API with the given playlist ID.

### 4. Caching
- There is a cache key based on the playlist ID: `playlist_${id.value}_essential`. If the cache is stale or incorrect, it could cause the wrong playlist to display.

### 5. Potential Issues
- If the cache for one playlist ID is being incorrectly set or retrieved for another, it could cause this bug.
- If the playlist ID in the URL is correct, but the data returned from Spotify or Firestore is for a different playlist, there may be a bug in the caching or in the playlist fetching logic.

### Next Steps for Debugging
- Check if the cache for `playlist_6LPO8pVjeuK2PbhvXxmlHe_essential` actually contains data for the "New queued" playlist (ID: `50mWTRVvyIC3lUjTJ3r5KV`).
- Add a `console.log(playlistId)` and `console.log(playlistResponse)` in `fetchPlaylistData` to verify what is being fetched and stored.
- Try clearing the cache (there is a `handleClearCache` function) and reloading the page to see if the correct playlist loads.

Would you like to check the cache contents, or do you want to add more logging to see what’s happening during the fetch?

---

_**User (2025-05-04 09:28Z)**_

ah, I just reloaded the playlist and it got replaced with the correct one, so this is cache related

---

_**Agent (mode Ask)**_

That confirms the issue is with the cache logic. Here’s what’s likely happening and what to check next:

### What’s Happening
- The cache key is `playlist_${id.value}_essential`.
- If, for any reason, the cache is set with the wrong playlist data (e.g., due to a race condition, stale state, or a bug in how/when the cache is cleared/set), the wrong playlist will display until the cache is cleared or refreshed.

### What to Check/Suspect
1. **Cache Key Uniqueness:**  
   - Is there any scenario where the cache key could be reused or not updated when switching playlists?
2. **Cache Set Timing:**  
   - Is the cache being set before the correct data is fully loaded?
3. **Component Lifecycle:**  
   - If you navigate between playlists without a full reload, is the cache key or data lingering from the previous playlist?

### Suggestions for Debugging/Improvement
- Add logging for cache set/get operations, including the playlist ID and name.
- Ensure that when navigating to a new playlist, the cache key is always based on the current route param and that the cache is not being reused incorrectly.
- Consider invalidating or refreshing the cache when the playlist ID changes.

Would you like suggestions for how to make the cache more robust, or do you want to see example logging to help debug further?

---

_**User (2025-05-04 09:28Z)**_

review the caching logic to see if you can spot the issue

---

_**Agent (mode Ask)**_

Here’s a focused review of the caching logic in `PlaylistSingle.vue`:

---

### How Caching Works in the Code

- **Cache Key:**  
  ```js
  const cacheKey = computed(() => `playlist_${id.value}_essential`);
  ```
  This should be unique per playlist, as `id.value` is the route param.

- **Fetching Data:**  
  ```js
  async function fetchPlaylistData(playlistId) {
    const cachedData = await getCache(cacheKey.value);
    if (cachedData) {
      // Use cached data
      ...
      return;
    }
    // Fetch from Spotify, then set cache
    ...
    await setCache(cacheKey.value, {
      playlistName: playlistName.value,
      albumData: albumData.value
    });
  }
  ```

- **Loading Data:**  
  ```js
  async function loadPlaylistData() {
    ...
    await fetchPlaylistData(id.value);
    ...
  }
  ```

- **Cache Clearing:**  
  ```js
  async function handleClearCache() {
    await clearCache(cacheKey.value);
    ...
    await loadPlaylistData();
  }
  ```

- **Lifecycle:**  
  The code (not shown in the snippets above, but likely in `onMounted` or a watcher) calls `loadPlaylistData()` when the component mounts or when the playlist ID changes.

---

### Potential Issues

1. **Cache Key Calculation Timing**
   - If `cacheKey.value` is computed before `id.value` is updated (e.g., during a fast route change), it could use the previous playlist’s ID.
   - If `fetchPlaylistData` is called before the new route param is reactive, it could fetch/set the wrong cache.

2. **Component Reuse**
   - Vue may reuse the component instance when navigating between playlists, so if the watcher on `id` is not set up correctly, the cache key could be stale.

3. **Asynchronous Race**
   - If two fetches are triggered in quick succession (e.g., rapid navigation), the cache could be set with the wrong data for the current key.

---

### What to Check in the Code

- **Is there a watcher on `id` that calls `loadPlaylistData()` when the route param changes?**
- **Is `fetchPlaylistData` always called with the current `id.value`?**
- **Are there any places where the cache key could be computed with a stale value?**
- **Is there any debounce or cancellation logic to prevent race conditions when navigating quickly?**

---

### How to Make It More Robust

- Always use the function argument (`playlistId`) for cache key calculation inside `fetchPlaylistData`, not the possibly stale `cacheKey.value`.
- Add a watcher on `id` to ensure data is re-fetched when the route changes.
- Consider adding a unique request ID or cancellation logic to prevent race conditions.

---

If you want, I can suggest a more robust pattern for cache key calculation and data fetching to avoid these issues. Let me know if you want that suggestion.

---

