<!-- Generated by SpecStory, Markdown v2.1.0 -->

<!-- cursor Session 1c5ddcce-b6f8-4104-b55c-7732dfa6d817 (2025-11-21 06:01Z) -->

# Playlist tracklist not displaying issue (2025-11-21 06:01Z)

_**User (2025-11-19 14:37Z)**_

I processed an album between transients. the second playlist won't show the tracklist for the new album (Built to spill). reload doesn't fix it.

---

_**Agent (model default, mode Ask)**_



---


Investigating why the tracklist isn't showing. Checking how playlists load and display tracklists, and what "transients" refers to.


---

<tool-use data-tool-type="search" data-tool-name="codebase_search">
<details>
                <summary>Tool use: **codebase_search** • Searched codebase "What are transients in playlists and how are albums moved between them?" • **13** results</summary>
            
| File | Lines |
|------|-------|
| `src/views/playlists/PlaylistSingle.vue` | L1457-1512 |
| `src/views/playlists/PlaylistSingle.vue` | L1509-1553 |
| `tasks/completed/pipeline-playlist-spec.md` | L59 |
| `src/utils/unifiedTrackCache.js` | L498-656 |
| `dbscripts/migrate-pipelineRole.js` | L9-97 |
| `dbscripts/migrate-pipelineRole.js` | L5-95 |
| `src/composables/useAlbumsData.js` | L24-663 |
| `tasks/completed/priority-refactor-spec.md` | L56 |
| `src/components/TrackList.vue` | L382-441 |
| `tasks/completed/pipeline-playlist-spec.md` | L103-155 |
| `src/components/TrackList.vue` | L79 |
| `src/views/playlists/PlaylistSingle.vue` | L1549-1604 |
| `src/composables/useLatestMovements.js` | L4-185 |

</details>
</tool-use>

---

<tool-use data-tool-type="search" data-tool-name="codebase_search">
<details>
                <summary>Tool use: **codebase_search** • Searched codebase "How are tracklists fetched and displayed for albums in playlists?" • **15** results</summary>
            
| File | Lines |
|------|-------|
| `src/views/playlists/PlaylistSingle.vue` | L228-279 |
| `src/views/playlists/PlaylistSingle.vue` | L171-230 |
| `src/utils/unifiedTrackCache.js` | L285-374 |
| `src/utils/unifiedTrackCache.js` | L498-656 |
| `src/composables/useUserSpotifyApi.js` | L5-654 |
| `src/components/TrackList.vue` | L382-441 |
| `src/utils/unifiedTrackCache.js` | L315-382 |
| `src/composables/useAlbumsData.js` | L24-663 |
| `src/utils/unifiedTrackCache.js` | L271-338 |
| `src/components/TrackList.vue` | L79 |
| `src/views/playlists/PlaylistSingle.vue` | L75-128 |
| `src/views/playlists/PlaylistSingle.vue` | L457-494 |
| `src/views/playlists/PlaylistSingle.vue` | L2508-2552 |
| `src/views/playlists/PlaylistSingle.vue` | L933-975 |
| `src/views/music/AlbumView.vue` | L298-361 |

</details>
</tool-use>

---

<tool-use data-tool-type="search" data-tool-name="grep">
<details>
<summary>Tool use: **grep** • Grep for "transient" • 64 matches</summary>

Output mode: content


| File | Content | Line |
|------|------|------|
| `.\src\views\playlists\PlaylistSingle.vue` | `pipelineRole: currentEntry.pipelineRole \|\| 'transient',` | L991 |
| `.\tasks\completed\priority-refactor-spec.md` | `- **Transient**: Position 1, 2, 3... (notes icon, width = `(position / total) * 100%` where total = sinks + terminal)` | L34 |
| `.\tasks\completed\priority-refactor-spec.md` | `- **Sink**: Position = position of terminating transient (stars, width = `(position / total) * 100%`)` | L35 |
| `.\tasks\completed\priority-refactor-spec.md` | `- Transient: position 1+ (notes icon, width = `(position / totalPositions) * 100%`)` | L79 |
| `.\tasks\completed\priority-refactor-spec.md` | `- Sink: position from terminating transient (stars, width = `(position / totalPositions) * 100%`)` | L80 |
| `.\tasks\completed\priority-refactor-spec.md` | `// If this is a transient with a termination, insert the sink immediately after` | L147 |
| `.\tasks\completed\priority-refactor-spec.md` | `if (playlist.pipelineRole === 'transient' && playlist.terminationPlaylistId) \{` | L148 |
| `.\tasks\completed\priority-refactor-spec.md` | `// 6. Assign the same position to parent transients (transients that terminate to sinks)` | L186 |
| `.\tasks\completed\priority-refactor-spec.md` | `if (p.pipelineRole === 'transient' && p.terminationPlaylistId && p.pipelinePosition < 1000) \{` | L188 |
| `.\tasks\completed\priority-refactor-spec.md` | `- **Transient** (position 1+): Notes icon, width = `(position / totalPositions) * 100%`` | L215 |
| `.\tasks\completed\priority-refactor-spec.md` | `2. Sinks connected to different transients (position = terminating transient position)` | L249 |
| `.\tasks\completed\priority-refactor-spec.md` | `- Sinks positioned directly below parent transient` | L286 |
| `.\tasks\completed\priority-refactor-spec.md` | `- Transients share width with their sink` | L287 |
| `.\src\composables\useAlbumsData.js` | `pipelineRole: _playlistData.pipelineRole \|\| 'transient',` | L378 |
| `.\src\views\music\ArtistView.vue` | `pipelineRole: currentEntry.pipelineRole \|\| 'transient',` | L134 |
| `.\src\views\music\ArtistView.vue` | `pipelineRole: currentEntry.pipelineRole \|\| 'transient',` | L197 |
| `.\src\views\music\SearchView.vue` | `pipelineRole: currentEntry.pipelineRole \|\| 'transient',` | L126 |
| `.\src\composables\usePlaylistUpdates.js` | `pipelineRole: firebaseData?.pipelineRole \|\| cachedPlaylist.pipelineRole \|\| 'transient',` | L67 |
| `.\src\composables\usePlaylistUpdates.js` | `pipelineRole: playlistData.pipelineRole \|\| 'transient'` | L93 |
| `.\src\composables\usePlaylistData.js` | `// If this is a transient with a termination, insert the sink immediately after` | L51 |
| `.\src\composables\usePlaylistData.js` | `if (playlist.pipelineRole === 'transient' && playlist.terminationPlaylistId) \{` | L52 |
| `.\src\composables\usePlaylistData.js` | `// 6. Assign the same position to parent transients (transients that terminate to sinks)` | L100 |
| `.\src\composables\usePlaylistData.js` | `if (p.pipelineRole === 'transient' && p.terminationPlaylistId && p.pipelinePosition < 1000) \{` | L102 |
| `.\src\composables\usePlaylistData.js` | `pipelineRole: playlist.pipelineRole \|\| 'transient', // Include pipeline role` | L220 |
| `.\src\components\RatingBar.vue` | `// For sink and transient: use 1-based position for width calculation` | L30 |
| `.\src\components\RatingBar.vue` | `// Transients share the same position as their sink` | L31 |
| `.\src\components\RatingBar.vue` | `if ((props.pipelineRole === 'sink' \|\| props.pipelineRole === 'transient') && props.totalPositions > 0) \{` | L32 |
| `.\src\components\RatingBar.vue` | `<template v-else-if="props.pipelineRole === 'transient'">` | L64 |
| `.\src\views\playlists\PlaylistView.vue` | `pipelineRole: playlistData.pipelineRole \|\| 'transient' // Include pipeline role from Firebase data` | L172 |
| `.\src\views\playlists\PlaylistView.vue` | `pipelineRole: playlistData.pipelineRole \|\| 'transient' // Include pipeline role from Firebase data` | L185 |
| `.\src\views\playlists\EditPlaylistView.vue` | `\{ value: 'transient', label: 'Transient (Evaluation Point)' \},` | L42 |
| `.\src\views\playlists\EditPlaylistView.vue` | `case 'transient':` | L51 |
| `.\src\views\playlists\EditPlaylistView.vue` | `pipelineRole: playlistData.pipelineRole \|\| 'transient'` | L154 |
| `.\src\views\playlists\AddPlaylistView.vue` | `\{ value: 'transient', label: 'Transient (Evaluation Point)' \},` | L271 |
| `.\src\views\playlists\AddPlaylistView.vue` | `case 'transient':` | L285 |
| `.\src\views\playlists\AddPlaylistView.vue` | `pipelineRole: playlistData.pipelineRole \|\| 'transient'` | L400 |
| `.\tasks\enhancements\pipeline-enhancements.md` | `Implement automatic track limit enforcement for transient playlists to create backpressure in the pipeline system.` | L17 |
| `.\tasks\enhancements\pipeline-enhancements.md` | `- **Transient playlists**: Enforce 100 track limit` | L22 |
| `.\tasks\enhancements\pipeline-enhancements.md` | `- Before adding albums to transient playlists` | L30 |
| `.\tasks\enhancements\pipeline-enhancements.md` | `- Show warning when transient playlist approaches limit (e.g., > 80 tracks)` | L35 |
| `.\tasks\enhancements\pipeline-enhancements.md` | `- Prevent adding albums to transient playlists that are at capacity` | L37 |
| `.\tasks\enhancements\pipeline-enhancements.md` | `if (playlist.pipelineRole === 'transient' && trackCount >= 100) \{` | L60 |
| `.\tasks\enhancements\pipeline-enhancements.md` | `- Transient: Yellow/Orange` | L84 |
| `.\tasks\enhancements\pipeline-enhancements.md` | `pipelineRole: 'transient',` | L128 |
| `.\tasks\enhancements\pipeline-enhancements.md` | `- Display pipeline path (e.g., "Source → Transient → Terminal")` | L170 |
| `.\tasks\enhancements\pipeline-enhancements.md` | `- Use icons for pipeline roles (source: clock, transient: notes, terminal: star, sink: archive)` | L187 |
| `.\tasks\completed\pipeline-playlist-spec.md` | `This document specifies the new pipeline-based playlist system for AudioFoodie, which introduces flexible music evaluation pipelines with source, transient, terminal, and sink nodes.` | L9 |
| `.\tasks\completed\pipeline-playlist-spec.md` | `"pipelineRole": "transient",         // "source", "transient", "terminal", "sink"` | L33 |
| `.\tasks\completed\pipeline-playlist-spec.md` | `"terminationPlaylistId": "notCheckingId",    // Termination connection (transient only)` | L35 |
| `.\tasks\completed\pipeline-playlist-spec.md` | `### Transient` | L53 |
| `.\tasks\completed\pipeline-playlist-spec.md` | `- `pipelineRole` (enum: "source", "transient", "terminal", "sink")` | L97 |
| `.\tasks\completed\pipeline-playlist-spec.md` | `- `terminationPlaylistId` (string, optional) - Termination connection (transient only)` | L99 |
| `.\tasks\completed\pipeline-playlist-spec.md` | `5. ✅ Set `terminationPlaylistId` for transient nodes (completed manually)` | L111 |
| `.\tasks\completed\pipeline-playlist-spec.md` | `"curious": \{ pipelineRole: "transient", group: "known" \},` | L119 |
| `.\tasks\completed\pipeline-playlist-spec.md` | `"interested": \{ pipelineRole: "transient", group: "known" \},` | L120 |
| `.\tasks\completed\pipeline-playlist-spec.md` | `"great": \{ pipelineRole: "transient", group: "known" \},` | L121 |
| `.\tasks\completed\pipeline-playlist-spec.md` | `"excellent": \{ pipelineRole: "transient", group: "known" \},` | L122 |
| `.\tasks\completed\pipeline-playlist-spec.md` | `- **Transient**: Must have both `nextStagePlaylistId` and `terminationPlaylistId`` | L181 |
| `.\tasks\pipeline-groups-refactor-spec.md` | `"pipelineRole": "transient",` | L24 |
| `.\tasks\pipeline-groups-refactor-spec.md` | `"pipelineRole": "transient",` | L80 |
| `.\src\composables\useLatestMovements.js` | `pipelineRole: latestEntry.pipelineRole \|\| 'transient',` | L102 |
| `.\src\components\LatestMovements.vue` | `'transient': 'bg-blue-800 text-white',` | L56 |
| `.\dbscripts\migrate-pipelineRole.js` | `playlistMap.set(data.playlistId, data.pipelineRole \|\| 'transient');` | L26 |
| `.\dbscripts\migrate-pipelineRole.js` | `const pipelineRole = playlistMap.get(entry.playlistId) \|\| 'transient';` | L65 |


</details>
</tool-use>

---



---


Checking the cache refresh logic used when moving albums:


---

<tool-use data-tool-type="read" data-tool-name="read_file">
<details><summary>Tool use: **read_file** • Read file: src/views/playlists/PlaylistSingle.vue</summary>

</details>
</tool-use>

---

<tool-use data-tool-type="search" data-tool-name="codebase_search">
<details>
                <summary>Tool use: **codebase_search** • Searched codebase "How does refreshSpecificPlaylists update the cache when albums are moved to a new playlist?" • **13** results</summary>
            
| File | Lines |
|------|-------|
| `src/views/playlists/PlaylistSingle.vue` | L1509-1553 |
| `src/composables/usePlaylistUpdates.js` | L9-135 |
| `src/views/playlists/PlaylistSingle.vue` | L1549-1604 |
| `src/views/playlists/PlaylistView.vue` | L196-260 |
| `src/composables/usePlaylistUpdates.js` | L135 |
| `src/utils/cache.js` | L122-232 |
| `src/views/playlists/PlaylistSingle.vue` | L1134-1190 |
| `src/utils/unifiedTrackCache.js` | L498-656 |
| `src/utils/unifiedTrackCache.js` | L556-736 |
| `src/views/playlists/AddPlaylistView.vue` | L376-425 |
| `src/composables/useAlbumsData.js` | L24-663 |
| `src/views/playlists/PlaylistSingle.vue` | L1457-1512 |
| `src/views/playlists/PlaylistSingle.vue` | L1379-1426 |

</details>
</tool-use>

---

<tool-use data-tool-type="search" data-tool-name="grep">
<details>
<summary>Tool use: **grep** • Grep for "refreshSpecificPlaylists|buildCacheForPlaylist" • 13 matches</summary>

Output mode: content


| File | Content | Line |
|------|------|------|
| `.\src\composables\useUnifiedTrackCache.js` | `const buildCacheForPlaylist = async (playlistId, progressCallback) => \{` | L180 |
| `.\src\composables\useUnifiedTrackCache.js` | `buildCacheForPlaylist,` | L384 |
| `.\src\views\playlists\PlaylistSingle.vue` | `const \{ refreshSpecificPlaylists \} = usePlaylistUpdates();` | L37 |
| `.\src\views\playlists\PlaylistSingle.vue` | `buildCacheForPlaylist,` | L49 |
| `.\src\views\playlists\PlaylistSingle.vue` | `// For now, return empty - tracks will be loaded via buildCacheForPlaylist` | L116 |
| `.\src\views\playlists\PlaylistSingle.vue` | `await buildCacheForPlaylist(id.value, (progress) => \{` | L222 |
| `.\src\views\playlists\PlaylistSingle.vue` | `const updatedState = await refreshSpecificPlaylists(` | L1537 |
| `.\src\composables\usePlaylistUpdates.js` | `const refreshSpecificPlaylists = async (spotifyPlaylistIds, currentPlaylistsState, cacheKey) => \{` | L22 |
| `.\src\composables\usePlaylistUpdates.js` | `refreshSpecificPlaylists` | L134 |
| `.\src\views\playlists\PlaylistView.vue` | `const \{ refreshSpecificPlaylists: refreshSpecificPlaylistsComposable \} = usePlaylistUpdates();` | L19 |
| `.\src\views\playlists\PlaylistView.vue` | `async function refreshSpecificPlaylists(spotifyPlaylistIds) \{` | L221 |
| `.\src\views\playlists\PlaylistView.vue` | `const updatedState = await refreshSpecificPlaylistsComposable(` | L224 |
| `.\src\views\playlists\PlaylistView.vue` | `refreshSpecificPlaylists(playlistIds);` | L283 |


</details>
</tool-use>

---



---


Checking how the unified track cache is built and whether it's updated for the target playlist:


---

<tool-use data-tool-type="read" data-tool-name="read_file">
<details><summary>Tool use: **read_file** • Read file: src/composables/useUnifiedTrackCache.js</summary>

</details>
</tool-use>

---

<tool-use data-tool-type="read" data-tool-name="read_file">
<details><summary>Tool use: **read_file** • Read file: src/views/playlists/PlaylistSingle.vue</summary>

</details>
</tool-use>

---

<tool-use data-tool-type="search" data-tool-name="codebase_search">
<details>
                <summary>Tool use: **codebase_search** • Searched codebase "How does the unified track cache get cleared or invalidated when albums are added to a playlist?" • **15** results</summary>
            
| File | Lines |
|------|-------|
| `src/utils/unifiedTrackCache.js` | L498-656 |
| `src/utils/unifiedTrackCache.js` | L556-736 |
| `src/utils/unifiedTrackCache.js` | L480-656 |
| `src/views/playlists/PlaylistSingle.vue` | L1379-1426 |
| `src/views/playlists/PlaylistSingle.vue` | L1549-1604 |
| `src/views/playlists/PlaylistSingle.vue` | L1509-1553 |
| `src/views/playlists/PlaylistSingle.vue` | L171-230 |
| `src/views/playlists/AddPlaylistView.vue` | L376-425 |
| `src/utils/unifiedTrackCache.js` | L805-974 |
| `src/composables/useAlbumsData.js` | L24-663 |
| `src/views/playlists/PlaylistSingle.vue` | L1007-1073 |
| `src/views/playlists/PlaylistSingle.vue` | L228-279 |
| `src/utils/unifiedTrackCache.js` | L867-980 |
| `src/views/playlists/PlaylistSingle.vue` | L1266-1313 |
| `src/views/playlists/PlaylistManagementView.vue` | L372-421 |

</details>
</tool-use>

---



---


Checking how `getAlbumTracksForPlaylist` retrieves tracks:


---

<tool-use data-tool-type="search" data-tool-name="grep">
<details>
<summary>Tool use: **grep** • Grep for "getAlbumTracksForPlaylist" • 6 matches</summary>

Output mode: content


| File | Content | Line |
|------|------|------|
| `.\src\composables\useUnifiedTrackCache.js` | `const getAlbumTracksForPlaylist = async (playlistId, albumId) => \{` | L93 |
| `.\src\composables\useUnifiedTrackCache.js` | `getAlbumTracksForPlaylist,` | L378 |
| `.\src\views\playlists\PlaylistSingle.vue` | `getAlbumTracksForPlaylist,` | L46 |
| `.\src\views\playlists\PlaylistSingle.vue` | `const tracks = await getAlbumTracksForPlaylist(id.value, album.id);` | L233 |
| `.\src\views\playlists\PlaylistSingle.vue` | `const tracks = await getAlbumTracksForPlaylist(id.value, album.id);` | L437 |
| `.\src\views\playlists\PlaylistSingle.vue` | `const tracks = await getAlbumTracksForPlaylist(id.value, album.id);` | L473 |


</details>
</tool-use>

---

<tool-use data-tool-type="read" data-tool-name="read_file">
<details><summary>Tool use: **read_file** • Read file: src/utils/unifiedTrackCache.js</summary>

</details>
</tool-use>

---



---


Issue: when an album is processed and moved to the target playlist, the unified track cache isn't updated for that playlist. The cache check in `fetchAlbumTracks` skips rebuilding because other albums have tracks, so the new album's tracks are missing.

Checking how to invalidate or clear the unified track cache for a specific playlist:


---

<tool-use data-tool-type="search" data-tool-name="codebase_search">
<details>
                <summary>Tool use: **codebase_search** • Searched codebase "How do you clear or invalidate the unified track cache for a specific playlist?" • **13** results</summary>
            
| File | Lines |
|------|-------|
| `src/views/playlists/PlaylistSingle.vue` | L1007-1073 |
| `src/utils/unifiedTrackCache.js` | L1066-1173 |
| `src/composables/useUnifiedTrackCache.js` | L30-392 |
| `src/utils/unifiedTrackCache.js` | L805-974 |
| `src/utils/unifiedTrackCache.js` | L498-656 |
| `src/utils/unifiedTrackCache.js` | L70-192 |
| `src/composables/useUnifiedTrackCache.js` | L392 |
| `src/views/playlists/PlaylistView.vue` | L196-260 |
| `tasks/unified-track-cache-spec.md` | L54 |
| `src/views/playlists/PlaylistSingle.vue` | L171-230 |
| `src/utils/unifiedTrackCache.js` | L80-203 |
| `src/utils/unifiedTrackCache.js` | L867-980 |
| `src/utils/unifiedTrackCache.js` | L315-382 |

</details>
</tool-use>

---

<tool-use data-tool-type="search" data-tool-name="grep">
<details>
<summary>Tool use: **grep** • Grep for "clearPlaylistCache|invalidatePlaylist|removePlaylist" in "src/utils/unifiedTrackCache.js" • 0 matches</summary>

Output mode: content


_No matches found_

</details>
</tool-use>

---

<tool-use data-tool-type="read" data-tool-name="read_file">
<details><summary>Tool use: **read_file** • Read file: src/composables/useUnifiedTrackCache.js</summary>

</details>
</tool-use>

---



---


## The Problem

When an album is moved from one playlist to another:
1. The album is added to Spotify and Firebase
2. The album list cache is updated
3. The unified track cache isn't updated for the target playlist

When viewing the target playlist:
- `fetchAlbumTracks()` checks if the playlist has cached tracks
- Since other albums have tracks, it skips rebuilding (`needsBuild = false`)
- When it tries to get tracks for the new album, `getPlaylistAlbumTracks()` returns an empty array because that album isn't in the unified track cache for that playlist

The issue is in the cache check logic at ```196:217:src/views/playlists/PlaylistSingle.vue``` — it checks if any album has tracks, not if all albums are cached.

## The Fix

After processing an album, invalidate the unified track cache for the target playlist so it rebuilds with all albums. Since there isn't a function to remove a single playlist from the unified cache, either:

1. Remove that playlist entry from the in-memory cache after moving the album, or
2. Force a rebuild by deleting the playlist from the cache structure

In `handleProcessAlbum`, after moving the album to the target playlist, clear/invalidate the unified track cache entry for `targetSpotifyPlaylistId` so the cache check will rebuild it when the user opens that playlist.

The best approach: after line 1508 (adding the album to Spotify), also rebuild or invalidate the unified track cache for the target playlist, or remove that playlist from the cache so it gets rebuilt on next access.

I can show the exact code changes. Should I continue?

---

_**User (2025-11-19 14:37Z)**_

so what exactly in the cache is causing the tracks not to show?

---

_**Agent (model default, mode Ask)**_



---


Tracing the exact cache flow to pinpoint why tracks aren't showing:


---

<tool-use data-tool-type="read" data-tool-name="read_file">
<details><summary>Tool use: **read_file** • Read file: src/utils/unifiedTrackCache.js</summary>

</details>
</tool-use>

---

<tool-use data-tool-type="read" data-tool-name="read_file">
<details><summary>Tool use: **read_file** • Read file: src/views/playlists/PlaylistSingle.vue</summary>

</details>
</tool-use>

---

<tool-use data-tool-type="read" data-tool-name="read_file">
<details><summary>Tool use: **read_file** • Read file: src/utils/unifiedTrackCache.js</summary>

</details>
</tool-use>

---



---


Tracing the cache structure:


---

<tool-use data-tool-type="search" data-tool-name="codebase_search">
<details>
                <summary>Tool use: **codebase_search** • Searched codebase "What is the structure of the unified track cache and how are albums stored per playlist?" • **15** results</summary>
            
| File | Lines |
|------|-------|
| `src/utils/unifiedTrackCache.js` | L498-656 |
| `src/utils/unifiedTrackCache.js` | L480-656 |
| `src/utils/unifiedTrackCache.js` | L556-736 |
| `src/utils/unifiedTrackCache.js` | L31-75 |
| `src/utils/unifiedTrackCache.js` | L315-382 |
| `src/utils/unifiedTrackCache.js` | L271-338 |
| `src/utils/unifiedTrackCache.js` | L285-374 |
| `src/utils/unifiedTrackCache.js` | L208-280 |
| `src/utils/unifiedTrackCache.js` | L38 |
| `src/utils/unifiedTrackCache.js` | L70-192 |
| `src/utils/unifiedTrackCache.js` | L805-974 |
| `src/utils/unifiedTrackCache.js` | L80-203 |
| `src/utils/unifiedTrackCache.js` | L43-126 |
| `src/utils/unifiedTrackCache.js` | L867-980 |
| `src/utils/unifiedTrackCache.js` | L1085-1173 |

</details>
</tool-use>

---



---


Here’s what’s happening:

## The Exact Cache Issue

The unified track cache structure looks like this:
```
cache.playlists[playlistId].albums[albumId].trackIds
```

When you view the target playlist after moving the album:

1. At line 199-212 in `PlaylistSingle.vue`: `fetchAlbumTracks()` checks if the playlist is cached. It uses:
   ```javascript
   const hasTracks = albumKeys.some(albumId => {
     const album = existingPlaylist.albums[albumId];
     return album && album.trackIds && album.trackIds.length > 0;
   });
   ```
   This only checks if any album has tracks, not if all albums are cached.

2. Because other albums have tracks, it sets `needsBuild = false` and skips rebuilding.

3. At line 233, it tries to get tracks for each album, including the new one:
   ```javascript
   const tracks = await getAlbumTracksForPlaylist(id.value, album.id);
   ```

4. At line 319 in `unifiedTrackCache.js`, `getPlaylistAlbumTracks()` checks:
   ```javascript
   if (!cache.playlists[playlistId] || !cache.playlists[playlistId].albums[albumId]) {
     return [];
   }
   ```

5. For Built to Spill: `cache.playlists[targetPlaylistId].albums[builtToSpillAlbumId]` doesn’t exist because the unified track cache wasn’t updated when the album was moved.

6. The check at line 319 fails and returns an empty array.

## The Root Cause

The cache check at lines 204-207 checks if any album has tracks, not if all albums are cached. When a new album is added to a playlist:
- The unified track cache still has the old playlist structure (without the new album)
- The check sees existing albums with tracks and skips rebuilding
- The new album isn’t in the cache, so its tracks aren’t found

The missing piece is: `cache.playlists[targetPlaylistId].albums[newAlbumId]` doesn’t exist because the unified track cache wasn’t refreshed when the album was moved to the target playlist.

---

_**User (2025-11-19 14:37Z)**_

the album has been accurately moved. it is gone from playlist 1, and is showing in playlist 2. It's only the tracklist that's not showing

---

_**Agent (model default, mode Ask)**_



---


Confirming the issue: the album appears in playlist 2, but the tracklist is missing because the unified track cache doesn’t include that album’s tracks. Verifying the cache check logic:


---

<tool-use data-tool-type="read" data-tool-name="read_file">
<details><summary>Tool use: **read_file** • Read file: src/utils/unifiedTrackCache.js</summary>

</details>
</tool-use>

---

<tool-use data-tool-type="read" data-tool-name="read_file">
<details><summary>Tool use: **read_file** • Read file: src/views/playlists/PlaylistSingle.vue</summary>

</details>
</tool-use>

---



---


## The Exact Missing Cache Entry

When the album moved to playlist 2:
- ✅ Album removed from playlist 1
- ✅ Album added to playlist 2 (album list shows it)
- ❌ Unified track cache not updated for playlist 2

The missing cache entry is:
```
cache.playlists[playlist2Id].albums[builtToSpillAlbumId]
```

This structure stores which tracks from the album are in that playlist.

## What Happens When Loading Tracklists

At line 233 in `PlaylistSingle.vue`, when tracklists are enabled, it calls:
```javascript
const tracks = await getAlbumTracksForPlaylist(id.value, album.id);
```

This calls `getPlaylistAlbumTracks()` at line 316-320 in `unifiedTrackCache.js`, which checks:
```javascript
if (!cache.playlists[playlistId] || !cache.playlists[playlistId].albums[albumId]) {
  return [];
}
```

Since `cache.playlists[playlist2Id].albums[builtToSpillAlbumId]` doesn't exist, it returns an empty array, so the tracklist is empty.

## Why It Doesn't Rebuild

The cache check at lines 204-207 sees that playlist 2 has other albums with tracks cached, so it skips rebuilding. It only checks if any album has tracks, not if all albums in the playlist are cached.

**The fix:** When an album is moved to a playlist, the unified track cache for that playlist must be invalidated or rebuilt to include the new album's tracks. The code that handles album moves doesn't currently update or invalidate the unified track cache for the target playlist.

---

_**User (2025-11-19 14:37Z)**_

so handleProcessAlbum rebuilds the playlist_[playlist id]_ caches? can you check it? this is nothing to do with the unified cache btw

---

_**Agent (model default, mode Ask)**_



---


Checking what `handleProcessAlbum` does with the `playlist_[playlistId]_*` caches:


---

<tool-use data-tool-type="read" data-tool-name="read_file">
<details><summary>Tool use: **read_file** • Read file: src/views/playlists/PlaylistSingle.vue</summary>

</details>
</tool-use>

---

<tool-use data-tool-type="search" data-tool-name="codebase_search">
<details>
                <summary>Tool use: **codebase_search** • Searched codebase "How are tracklists stored and retrieved from playlist cache keys?" • **15** results</summary>
            
| File | Lines |
|------|-------|
| `src/utils/unifiedTrackCache.js` | L498-656 |
| `src/utils/unifiedTrackCache.js` | L38 |
| `src/utils/unifiedTrackCache.js` | L315-382 |
| `tasks/unified-track-cache-spec.md` | L86-150 |
| `tasks/unified-track-cache-spec.md` | L54 |
| `tasks/unified-track-cache-spec.md` | L339-395 |
| `src/views/playlists/PlaylistSingle.vue` | L171-230 |
| `src/utils/unifiedTrackCache.js` | L285-374 |
| `src/utils/unifiedTrackCache.js` | L70-192 |
| `src/utils/unifiedTrackCache.js` | L805-974 |
| `src/views/playlists/PlaylistSingle.vue` | L228-279 |
| `tasks/unified-track-cache-spec.md` | L48-91 |
| `src/utils/unifiedTrackCache.js` | L1099-1190 |
| `src/utils/unifiedTrackCache.js` | L480-656 |
| `src/utils/unifiedTrackCache.js` | L867-980 |

</details>
</tool-use>

---

<tool-use data-tool-type="search" data-tool-name="grep">
<details>
<summary>Tool use: **grep** • Grep for "playlist_.*_track|tracklist|getAlbumTracks" in "src/views/playlists/PlaylistSingle.vue" • 16 matches</summary>

Output mode: content


| File | Content | Line |
|------|------|------|
| `src/views/playlists/PlaylistSingle.vue` | `const \{ getPlaylist, getPlaylistAlbumsWithDates, loadAlbumsBatched, addAlbumToPlaylist, removeAlbumFromPlaylist: removeFromSpotify, loading: spotifyLoading, error: spotifyError, getAlbumTracks, getAllArtistAlbums, getAllPlaylistTracks \} = useUserSpotifyApi();` | L40 |
| `src/views/playlists/PlaylistSingle.vue` | `getAlbumTracksForPlaylist,` | L46 |
| `src/views/playlists/PlaylistSingle.vue` | `// Fetch tracks for all albums when tracklists are enabled (using unified cache)` | L175 |
| `src/views/playlists/PlaylistSingle.vue` | `const tracks = await getAlbumTracksForPlaylist(id.value, album.id);` | L233 |
| `src/views/playlists/PlaylistSingle.vue` | `// Initialize tracklist preference from per-playlist setting` | L268 |
| `src/views/playlists/PlaylistSingle.vue` | `const tracks = await getAlbumTracksForPlaylist(id.value, album.id);` | L437 |
| `src/views/playlists/PlaylistSingle.vue` | `// If tracklists are shown, also refresh playcounts (force refresh since user explicitly clicked refresh)` | L458 |
| `src/views/playlists/PlaylistSingle.vue` | `const tracks = await getAlbumTracksForPlaylist(id.value, album.id);` | L473 |
| `src/views/playlists/PlaylistSingle.vue` | `// Store tracklist preference before reloading` | L606 |
| `src/views/playlists/PlaylistSingle.vue` | `// Restore tracklist if it was enabled before reloading` | L613 |
| `src/views/playlists/PlaylistSingle.vue` | `// Store tracklist preference before clearing` | L1050 |
| `src/views/playlists/PlaylistSingle.vue` | `// Restore tracklist if it was enabled before clearing` | L1067 |
| `src/views/playlists/PlaylistSingle.vue` | `// Restore tracklist if it was enabled` | L1142 |
| `src/views/playlists/PlaylistSingle.vue` | `// Restore tracklist if it was enabled` | L1157 |
| `src/views/playlists/PlaylistSingle.vue` | `// If tracklists were shown on last visit, fetch them` | L1360 |
| `src/views/playlists/PlaylistSingle.vue` | `<p class="text-delft-blue">Loading tracklists...</p>` | L2512 |


</details>
</tool-use>

---



---


Checking what `handleProcessAlbum` does with `playlist_[playlistId]_*` caches and whether it handles tracklist caches:


---

<tool-use data-tool-type="read" data-tool-name="read_file">
<details><summary>Tool use: **read_file** • Read file: src/views/playlists/PlaylistSingle.vue</summary>

</details>
</tool-use>

---

<tool-use data-tool-type="search" data-tool-name="grep">
<details>
<summary>Tool use: **grep** • Grep for "playlist_.*track|playlist_tracks" • 4 matches</summary>

Output mode: content


| File | Content | Line |
|------|------|------|
| `.\src\views\playlists\PlaylistSingle.vue` | `await clearCache(`playlist_tracks_$\{id.value\}`);` | L1031 |
| `.\tasks\unified-track-cache-spec.md` | `- `playlist_tracks_$\{playlistId\}` - Track IDs only per playlist` | L13 |
| `.\tasks\unified-track-cache-spec.md` | `playlist_tracks_$\{playlistId\} = \{ albumId: \{ trackId: true \} \}` | L36 |
| `.\tasks\unified-track-cache-spec.md` | `- `playlist_tracks_$\{playlistId\}`` | L627 |


</details>
</tool-use>

---

<tool-use data-tool-type="read" data-tool-name="read_file">
<details><summary>Tool use: **read_file** • Read file: src/views/playlists/PlaylistSingle.vue</summary>

</details>
</tool-use>

---



---


`handleProcessAlbum` does not clear the tracklist cache for the target playlist.

In `handleClearCache()` (lines 1013-1071), it clears:
- `playlist_tracks_${id.value}` (line 1031)

But in `handleProcessAlbum()` (lines 1580-1589), for the target playlist, it only clears:
- `playlist_${targetSpotifyPlaylistId}_albumsWithDates` (updated)
- `playlist_${targetSpotifyPlaylistId}_page_${page}_${mode}_${dir}` (cleared)

It does not clear:
- `playlist_tracks_${targetSpotifyPlaylistId}`

So the target playlist's old tracks cache remains and doesn't include the new album's tracks.

The fix: In `handleProcessAlbum`, after clearing the page caches (around line 1589), also clear the target playlist's tracks cache:

```javascript
await clearCache(`playlist_tracks_${targetSpotifyPlaylistId}`);
```

This ensures the tracklist is rebuilt with the new album's tracks when viewing playlist 2.

---

_**User (2025-11-19 14:37Z)**_

there is no playlist_tracks_ cache.

---

_**Agent (model default, mode Ask)**_



---


Checking how tracklists are actually cached and retrieved:


---

<tool-use data-tool-type="search" data-tool-name="grep">
<details>
<summary>Tool use: **grep** • Grep for "playlist_tracks_" • 4 matches</summary>

Output mode: content


| File | Content | Line |
|------|------|------|
| `.\src\views\playlists\PlaylistSingle.vue` | `await clearCache(`playlist_tracks_$\{id.value\}`);` | L1031 |
| `.\tasks\unified-track-cache-spec.md` | `- `playlist_tracks_$\{playlistId\}` - Track IDs only per playlist` | L13 |
| `.\tasks\unified-track-cache-spec.md` | `playlist_tracks_$\{playlistId\} = \{ albumId: \{ trackId: true \} \}` | L36 |
| `.\tasks\unified-track-cache-spec.md` | `- `playlist_tracks_$\{playlistId\}`` | L627 |


</details>
</tool-use>

---

<tool-use data-tool-type="search" data-tool-name="codebase_search">
<details>
                <summary>Tool use: **codebase_search** • Searched codebase "Where are album tracklists cached and how are they retrieved for a playlist?" • **15** results</summary>
            
| File | Lines |
|------|-------|
| `src/views/playlists/PlaylistSingle.vue` | L171-230 |
| `src/views/playlists/PlaylistSingle.vue` | L228-279 |
| `src/utils/unifiedTrackCache.js` | L498-656 |
| `src/utils/unifiedTrackCache.js` | L285-374 |
| `src/utils/unifiedTrackCache.js` | L315-382 |
| `src/utils/unifiedTrackCache.js` | L271-338 |
| `src/utils/unifiedTrackCache.js` | L480-656 |
| `src/views/playlists/PlaylistSingle.vue` | L933-975 |
| `src/composables/useUnifiedTrackCache.js` | L30-392 |
| `src/views/playlists/PlaylistSingle.vue` | L907-937 |
| `tasks/unified-track-cache-spec.md` | L339-395 |
| `src/utils/unifiedTrackCache.js` | L805-974 |
| `src/views/playlists/PlaylistSingle.vue` | L1221-1269 |
| `src/composables/useAlbumsData.js` | L24-663 |
| `src/utils/unifiedTrackCache.js` | L556-736 |

</details>
</tool-use>

---

<tool-use data-tool-type="read" data-tool-name="read_file">
<details><summary>Tool use: **read_file** • Read file: src/views/playlists/PlaylistSingle.vue</summary>

</details>
</tool-use>

---

<tool-use data-tool-type="search" data-tool-name="grep">
<details>
<summary>Tool use: **grep** • Grep for "albumTracks_|album.*track|track.*cache" in "src/views/playlists/PlaylistSingle.vue" • 94 matches</summary>

Output mode: content


| File | Content | Line |
|------|------|------|
| `src/views/playlists/PlaylistSingle.vue` | `import \{ useUnifiedTrackCache \} from '@composables/useUnifiedTrackCache';` | L30 |
| `src/views/playlists/PlaylistSingle.vue` | `import \{ loadUnifiedTrackCache \} from '@utils/unifiedTrackCache';` | L32 |
| `src/views/playlists/PlaylistSingle.vue` | `const \{ getPlaylist, getPlaylistAlbumsWithDates, loadAlbumsBatched, addAlbumToPlaylist, removeAlbumFromPlaylist: removeFromSpotify, loading: spotifyLoading, error: spotifyError, getAlbumTracks, getAllArtistAlbums, getAllPlaylistTracks \} = useUserSpotifyApi();` | L40 |
| `src/views/playlists/PlaylistSingle.vue` | `getAlbumTracksForPlaylist,` | L46 |
| `src/views/playlists/PlaylistSingle.vue` | `\} = useUnifiedTrackCache();` | L56 |
| `src/views/playlists/PlaylistSingle.vue` | `// Computed property to get tracks for each album from unified cache` | L109 |
| `src/views/playlists/PlaylistSingle.vue` | `const albumTracks = computed(() => \{` | L110 |
| `src/views/playlists/PlaylistSingle.vue` | `// For now, return empty - tracks will be loaded via buildCacheForPlaylist` | L116 |
| `src/views/playlists/PlaylistSingle.vue` | `// Reactive tracks storage (populated from cache)` | L121 |
| `src/views/playlists/PlaylistSingle.vue` | `const albumTracksData = ref(\{});` | L122 |
| `src/views/playlists/PlaylistSingle.vue` | `// Update track playcount in albumTracksData when playcount changes` | L127 |
| `src/views/playlists/PlaylistSingle.vue` | `Object.keys(albumTracksData.value).forEach(albumId => \{` | L130 |
| `src/views/playlists/PlaylistSingle.vue` | `const tracks = albumTracksData.value[albumId];` | L131 |
| `src/views/playlists/PlaylistSingle.vue` | `albumTracksData.value[albumId] = [` | L136 |
| `src/views/playlists/PlaylistSingle.vue` | `// Fetch tracks for all albums when tracklists are enabled (using unified cache)` | L175 |
| `src/views/playlists/PlaylistSingle.vue` | `const fetchAlbumTracks = async () => \{` | L176 |
| `src/views/playlists/PlaylistSingle.vue` | `logPlaylist('Skipping fetchAlbumTracks:', \{` | L178 |
| `src/views/playlists/PlaylistSingle.vue` | `logPlaylist('Fetching album tracks:', \{` | L186 |
| `src/views/playlists/PlaylistSingle.vue` | `const cache = await loadUnifiedTrackCache(user.value.uid, userData.value?.lastFmUserName \|\| '');` | L199 |
| `src/views/playlists/PlaylistSingle.vue` | `// Check if we have albums and at least one has tracks` | L203 |
| `src/views/playlists/PlaylistSingle.vue` | `return album && album.trackIds && album.trackIds.length > 0;` | L206 |
| `src/views/playlists/PlaylistSingle.vue` | `// Load tracks from unified cache for each album` | L228 |
| `src/views/playlists/PlaylistSingle.vue` | `logPlaylist('Loading tracks for albums from cache');` | L229 |
| `src/views/playlists/PlaylistSingle.vue` | `const tracks = await getAlbumTracksForPlaylist(id.value, album.id);` | L233 |
| `src/views/playlists/PlaylistSingle.vue` | `albumTracksData.value[album.id] = tracks;` | L234 |
| `src/views/playlists/PlaylistSingle.vue` | `logCache('Loaded tracks for album:', \{ albumId: album.id, trackCount: tracks.length \});` | L235 |
| `src/views/playlists/PlaylistSingle.vue` | `albumTracksData.value[album.id] = [];` | L238 |
| `src/views/playlists/PlaylistSingle.vue` | `logPlaylist('All album tracks fetched successfully');` | L243 |
| `src/views/playlists/PlaylistSingle.vue` | `fetchAlbumTracks();` | L261 |
| `src/views/playlists/PlaylistSingle.vue` | `albumTracksData.value = \{};` | L264 |
| `src/views/playlists/PlaylistSingle.vue` | `fetchAlbumTracks();` | L273 |
| `src/views/playlists/PlaylistSingle.vue` | `// Handle track loving/unloving with unified cache` | L278 |
| `src/views/playlists/PlaylistSingle.vue` | `const handleTrackLoved = async (\{ album, track \}) => \{` | L279 |
| `src/views/playlists/PlaylistSingle.vue` | `// Optimistic UI update: update track in albumTracksData immediately` | L283 |
| `src/views/playlists/PlaylistSingle.vue` | `if (albumTracksData.value[album.id]) \{` | L284 |
| `src/views/playlists/PlaylistSingle.vue` | `const trackIndex = albumTracksData.value[album.id].findIndex(t => t.id === track.id);` | L285 |
| `src/views/playlists/PlaylistSingle.vue` | `albumTracksData.value[album.id] = [` | L288 |
| `src/views/playlists/PlaylistSingle.vue` | `...albumTracksData.value[album.id].slice(0, trackIndex),` | L289 |
| `src/views/playlists/PlaylistSingle.vue` | `...albumTracksData.value[album.id][trackIndex],` | L291 |
| `src/views/playlists/PlaylistSingle.vue` | `...albumTracksData.value[album.id].slice(trackIndex + 1)` | L294 |
| `src/views/playlists/PlaylistSingle.vue` | `if (albumTracksData.value[album.id]) \{` | L315 |
| `src/views/playlists/PlaylistSingle.vue` | `const trackIndex = albumTracksData.value[album.id].findIndex(t => t.id === track.id);` | L316 |
| `src/views/playlists/PlaylistSingle.vue` | `albumTracksData.value[album.id] = [` | L319 |
| `src/views/playlists/PlaylistSingle.vue` | `...albumTracksData.value[album.id].slice(0, trackIndex),` | L320 |
| `src/views/playlists/PlaylistSingle.vue` | `...albumTracksData.value[album.id][trackIndex],` | L322 |
| `src/views/playlists/PlaylistSingle.vue` | `...albumTracksData.value[album.id].slice(trackIndex + 1)` | L325 |
| `src/views/playlists/PlaylistSingle.vue` | `const handleTrackUnloved = async (\{ album, track \}) => \{` | L350 |
| `src/views/playlists/PlaylistSingle.vue` | `// Optimistic UI update: update track in albumTracksData immediately` | L354 |
| `src/views/playlists/PlaylistSingle.vue` | `if (albumTracksData.value[album.id]) \{` | L355 |
| `src/views/playlists/PlaylistSingle.vue` | `const trackIndex = albumTracksData.value[album.id].findIndex(t => t.id === track.id);` | L356 |
| `src/views/playlists/PlaylistSingle.vue` | `albumTracksData.value[album.id] = [` | L359 |
| `src/views/playlists/PlaylistSingle.vue` | `...albumTracksData.value[album.id].slice(0, trackIndex),` | L360 |
| `src/views/playlists/PlaylistSingle.vue` | `...albumTracksData.value[album.id][trackIndex],` | L362 |
| `src/views/playlists/PlaylistSingle.vue` | `...albumTracksData.value[album.id].slice(trackIndex + 1)` | L365 |
| `src/views/playlists/PlaylistSingle.vue` | `if (albumTracksData.value[album.id]) \{` | L386 |
| `src/views/playlists/PlaylistSingle.vue` | `const trackIndex = albumTracksData.value[album.id].findIndex(t => t.id === track.id);` | L387 |
| `src/views/playlists/PlaylistSingle.vue` | `albumTracksData.value[album.id] = [` | L390 |
| `src/views/playlists/PlaylistSingle.vue` | `...albumTracksData.value[album.id].slice(0, trackIndex),` | L391 |
| `src/views/playlists/PlaylistSingle.vue` | `...albumTracksData.value[album.id][trackIndex],` | L393 |
| `src/views/playlists/PlaylistSingle.vue` | `...albumTracksData.value[album.id].slice(trackIndex + 1)` | L396 |
| `src/views/playlists/PlaylistSingle.vue` | `// Refresh loved tracks from Last.fm using unified cache` | L429 |
| `src/views/playlists/PlaylistSingle.vue` | `// Reload tracks from cache to reflect updated loved status` | L432 |
| `src/views/playlists/PlaylistSingle.vue` | `// Reload tracks for all albums to get fresh loved status from cache` | L434 |
| `src/views/playlists/PlaylistSingle.vue` | `const tracks = await getAlbumTracksForPlaylist(id.value, album.id);` | L437 |
| `src/views/playlists/PlaylistSingle.vue` | `albumTracksData.value[album.id] = tracks;` | L438 |
| `src/views/playlists/PlaylistSingle.vue` | `// Recalculate all loved track percentages using unified cache` | L447 |
| `src/views/playlists/PlaylistSingle.vue` | `const trackIds = Object.values(albumTracksData.value)` | L460 |
| `src/views/playlists/PlaylistSingle.vue` | `// Reload tracks from cache to reflect updated playcounts` | L470 |
| `src/views/playlists/PlaylistSingle.vue` | `const tracks = await getAlbumTracksForPlaylist(id.value, album.id);` | L473 |
| `src/views/playlists/PlaylistSingle.vue` | `albumTracksData.value[album.id] = tracks;` | L474 |
| `src/views/playlists/PlaylistSingle.vue` | `// Calculate loved track percentages for all albums using unified cache` | L568 |
| `src/views/playlists/PlaylistSingle.vue` | `await fetchAlbumTracks();` | L615 |
| `src/views/playlists/PlaylistSingle.vue` | `// Progressive loading of loved track percentages (using unified cache)` | L794 |
| `src/views/playlists/PlaylistSingle.vue` | `// Find albums that don't have loved track data yet` | L855 |
| `src/views/playlists/PlaylistSingle.vue` | `// Clear playlist tracks cache` | L1029 |
| `src/views/playlists/PlaylistSingle.vue` | `albumTracksData.value = \{};` | L1054 |
| `src/views/playlists/PlaylistSingle.vue` | `// Clear loved tracks cache if exists` | L1060 |
| `src/views/playlists/PlaylistSingle.vue` | `await fetchAlbumTracks();` | L1069 |
| `src/views/playlists/PlaylistSingle.vue` | `await fetchAlbumTracks();` | L1144 |
| `src/views/playlists/PlaylistSingle.vue` | `await fetchAlbumTracks();` | L1159 |
| `src/views/playlists/PlaylistSingle.vue` | `// Check unified track cache for playlist name first` | L1237 |
| `src/views/playlists/PlaylistSingle.vue` | `const cache = await loadUnifiedTrackCache(user.value.uid, userData.value?.lastFmUserName \|\| '');` | L1240 |
| `src/views/playlists/PlaylistSingle.vue` | `// Find the album that contains this track` | L1295 |
| `src/views/playlists/PlaylistSingle.vue` | `const tracks = albumTracksData.value[alb.id] \|\| [];` | L1297 |
| `src/views/playlists/PlaylistSingle.vue` | `await handleTrackLoved(\{ album, track \});` | L1306 |
| `src/views/playlists/PlaylistSingle.vue` | `// If album not found but we have track ID, update unified cache directly` | L1308 |
| `src/views/playlists/PlaylistSingle.vue` | `// Find the album that contains this track` | L1317 |
| `src/views/playlists/PlaylistSingle.vue` | `const tracks = albumTracksData.value[alb.id] \|\| [];` | L1319 |
| `src/views/playlists/PlaylistSingle.vue` | `await handleTrackUnloved(\{ album, track \});` | L1328 |
| `src/views/playlists/PlaylistSingle.vue` | `// If album not found but we have track ID, update unified cache directly` | L1330 |
| `src/views/playlists/PlaylistSingle.vue` | `// Unified cache is automatically initialized by useUnifiedTrackCache composable` | L1353 |
| `src/views/playlists/PlaylistSingle.vue` | `fetchAlbumTracks();` | L1362 |
| `src/views/playlists/PlaylistSingle.vue` | `// THIS IS THE KEY CHECK - albums that fail this are the ones we need to track` | L1940 |
| `src/views/playlists/PlaylistSingle.vue` | `:tracks="albumTracksData[album.id] \|\| []"` | L2536 |


</details>
</tool-use>

---



---


Tracklists come from the unified track cache via `getAlbumTracksForPlaylist()`. Checking what `handleProcessAlbum` needs to invalidate:


---

<tool-use data-tool-type="read" data-tool-name="read_file">
<details><summary>Tool use: **read_file** • Read file: src/utils/unifiedTrackCache.js</summary>

</details>
</tool-use>

---

<tool-use data-tool-type="search" data-tool-name="codebase_search">
<details>
                <summary>Tool use: **codebase_search** • Searched codebase "How do you invalidate or clear a specific playlist from the unified track cache?" • **14** results</summary>
            
| File | Lines |
|------|-------|
| `src/views/playlists/PlaylistSingle.vue` | L1007-1073 |
| `src/views/playlists/PlaylistView.vue` | L196-260 |
| `src/utils/unifiedTrackCache.js` | L1066-1173 |
| `src/utils/cache.js` | L186-307 |
| `src/composables/useUnifiedTrackCache.js` | L30-392 |
| `src/utils/unifiedTrackCache.js` | L805-974 |
| `src/utils/unifiedTrackCache.js` | L498-656 |
| `src/utils/cache.js` | L122-232 |
| `tasks/unified-track-cache-spec.md` | L54 |
| `src/views/playlists/PlaylistSingle.vue` | L1423-1461 |
| `src/utils/unifiedTrackCache.js` | L867-980 |
| `src/utils/unifiedTrackCache.js` | L1085-1173 |
| `src/utils/unifiedTrackCache.js` | L315-382 |
| `src/composables/useUnifiedTrackCache.js` | L392 |

</details>
</tool-use>

---

<tool-use data-tool-type="search" data-tool-name="grep">
<details>
<summary>Tool use: **grep** • Grep for "delete.*playlist|playlist.*delete|removePlaylist|clearPlaylist" in "src/utils/unifiedTrackCache.js" • 0 matches</summary>

Output mode: content


_No matches found_

</details>
</tool-use>

---



---


Since tracklists come from the unified track cache via `cache.playlists[playlistId].albums[albumId]`, and `handleProcessAlbum` doesn't invalidate the unified track cache for the target playlist, the issue is:

1. After moving the album, the unified cache still has the old state for playlist 2 (without the new album)
2. The check at lines 204-207 sees other albums have tracks and skips rebuilding
3. `getPlaylistAlbumTracks()` for the new album returns `[]` because `cache.playlists[playlist2Id].albums[newAlbumId]` doesn't exist

`handleProcessAlbum` needs to remove the target playlist from the unified track cache so it gets rebuilt. Since there's no function for that, we should:

**Remove the target playlist entry from the unified track cache** in `handleProcessAlbum`, after moving the album. This will force a rebuild when the user views playlist 2.

We need to load the unified cache, delete `cache.playlists[targetSpotifyPlaylistId]`, and save it back. Since there's no helper, we'd need to add that logic or create a helper function.

---

_**User (2025-11-19 14:37Z)**_

can we surgically update the cache instead of rebuilding? basically move a node to another node?

---

_**Agent (model default, mode Ask)**_



---


Checking the unified cache structure and what needs to be updated when moving an album between playlists:


---

<tool-use data-tool-type="read" data-tool-name="read_file">
<details><summary>Tool use: **read_file** • Read file: src/utils/unifiedTrackCache.js</summary>

</details>
</tool-use>

---

<tool-use data-tool-type="read" data-tool-name="read_file">
<details><summary>Tool use: **read_file** • Read file: src/utils/unifiedTrackCache.js</summary>

</details>
</tool-use>

---

<tool-use data-tool-type="search" data-tool-name="codebase_search">
<details>
                <summary>Tool use: **codebase_search** • Searched codebase "How are tracks related to playlists in the unified cache and what fields need updating when moving albums?" • **15** results</summary>
            
| File | Lines |
|------|-------|
| `src/utils/unifiedTrackCache.js` | L498-656 |
| `src/utils/unifiedTrackCache.js` | L480-656 |
| `src/utils/unifiedTrackCache.js` | L556-736 |
| `src/utils/unifiedTrackCache.js` | L315-382 |
| `src/utils/unifiedTrackCache.js` | L285-374 |
| `src/utils/unifiedTrackCache.js` | L271-338 |
| `src/utils/unifiedTrackCache.js` | L208-280 |
| `src/utils/unifiedTrackCache.js` | L439-556 |
| `src/utils/unifiedTrackCache.js` | L805-974 |
| `src/utils/cache.js` | L122-232 |
| `src/utils/unifiedTrackCache.js` | L867-980 |
| `src/utils/unifiedTrackCache.js` | L387-438 |
| `src/utils/unifiedTrackCache.js` | L38 |
| `src/utils/unifiedTrackCache.js` | L661-804 |
| `src/utils/unifiedTrackCache.js` | L561-736 |

</details>
</tool-use>

---



---


Creating a function to move an album between playlists in the unified cache. Checking what data we need to access:


---

<tool-use data-tool-type="read" data-tool-name="read_file">
<details><summary>Tool use: **read_file** • Read file: src/utils/unifiedTrackCache.js</summary>

</details>
</tool-use>

---

<tool-use data-tool-type="search" data-tool-name="grep">
<details>
<summary>Tool use: **grep** • Grep for "getInMemoryCache|loadUnifiedTrackCache|saveUnifiedTrackCache" in "src/utils/unifiedTrackCache.js" • 9 matches</summary>

Output mode: content


| File | Content | Line |
|------|------|------|
| `src/utils/unifiedTrackCache.js` | `export async function loadUnifiedTrackCache(userId, lastFmUserName) \{` | L81 |
| `src/utils/unifiedTrackCache.js` | `await saveUnifiedTrackCache(userId, true);` | L92 |
| `src/utils/unifiedTrackCache.js` | `await saveUnifiedTrackCache(userId, true);` | L116 |
| `src/utils/unifiedTrackCache.js` | `export async function saveUnifiedTrackCache(userId, immediate = false) \{` | L132 |
| `src/utils/unifiedTrackCache.js` | `function getInMemoryCache(userId) \{` | L198 |
| `src/utils/unifiedTrackCache.js` | `throw new Error(`Cache not loaded for user $\{userId\}. Call loadUnifiedTrackCache first.`);` | L201 |
| `src/utils/unifiedTrackCache.js` | `const cache = getInMemoryCache(userId);` | L287 |
| `src/utils/unifiedTrackCache.js` | `const cache = getInMemoryCache(userId);` | L317 |
| `src/utils/unifiedTrackCache.js` | `const cache = getInMemoryCache(userId);` | L345 |


</details>
</tool-use>

---

<tool-use data-tool-type="read" data-tool-name="read_file">
<details><summary>Tool use: **read_file** • Read file: src/utils/unifiedTrackCache.js</summary>

</details>
</tool-use>

---



---


To move an album from playlist 1 to playlist 2, update:

1. `cache.playlists[sourcePlaylistId].albums[albumId]` → remove
2. `cache.playlists[targetPlaylistId].albums[albumId]` → add (copy trackIds and addedAt)
3. For each track in the album: update `cache.tracks[trackId].playlistIds` (remove source, add target)
4. Ensure `cache.playlists[targetPlaylistId]` exists

Function to add to `unifiedTrackCache.js`:

```javascript:src/utils/unifiedTrackCache.js
// ... existing code ...

/**
 * Move an album from one playlist to another in the unified cache
 * @param {string} sourcePlaylistId - Source playlist ID
 * @param {string} targetPlaylistId - Target playlist ID
 * @param {string} albumId - Album ID to move
 * @param {string} userId - User ID
 * @param {string} addedAt - When album was added to target playlist (ISO string)
 */
export async function moveAlbumBetweenPlaylists(sourcePlaylistId, targetPlaylistId, albumId, userId, addedAt) {
  const cache = getInMemoryCache(userId);
  const now = Date.now();
  
  // Ensure cache is loaded
  if (!cache) {
    throw new Error(`Cache not loaded for user ${userId}`);
  }
  
  // Get the album entry from source playlist
  if (!cache.playlists[sourcePlaylistId] || !cache.playlists[sourcePlaylistId].albums[albumId]) {
    logCache(`Album ${albumId} not found in source playlist ${sourcePlaylistId}, cannot move`);
    return;
  }
  
  const albumEntry = cache.playlists[sourcePlaylistId].albums[albumId];
  const trackIds = albumEntry.trackIds || [];
  
  // Initialize target playlist if it doesn't exist
  if (!cache.playlists[targetPlaylistId]) {
    cache.playlists[targetPlaylistId] = {
      albums: {},
      lastUpdated: now,
      playlistName: ''
    };
  }
  
  const targetPlaylist = cache.playlists[targetPlaylistId];
  targetPlaylist.lastUpdated = now;
  
  // Move album entry to target playlist
  targetPlaylist.albums[albumId] = {
    trackIds: [...trackIds], // Copy trackIds array
    addedAt: addedAt || new Date().toISOString()
  };
  
  // Remove album from source playlist
  delete cache.playlists[sourcePlaylistId].albums[albumId];
  
  // Update track playlist relationships
  for (const trackId of trackIds) {
    if (!cache.tracks[trackId]) {
      // Track doesn't exist in cache - this shouldn't happen but handle gracefully
      logCache(`Warning: Track ${trackId} not found in cache when moving album ${albumId}`);
      continue;
    }
    
    const track = cache.tracks[trackId];
    
    // Remove source playlist from track's playlistIds
    if (track.playlistIds) {
      track.playlistIds = track.playlistIds.filter(pid => pid !== sourcePlaylistId);
    } else {
      track.playlistIds = [];
    }
    
    // Add target playlist to track's playlistIds (if not already present)
    if (!track.playlistIds.includes(targetPlaylistId)) {
      track.playlistIds.push(targetPlaylistId);
    }
    
    // Update track access time
    track.lastAccessed = now;
  }
  
  // Save the cache
  await saveUnifiedTrackCache(userId);
  
  logCache(`Moved album ${albumId} from playlist ${sourcePlaylistId} to ${targetPlaylistId}`);
}
```

Then call it from `handleProcessAlbum` after moving the album:

```javascript:src/views/playlists/PlaylistSingle.vue
// ... existing imports ...
import { moveAlbumBetweenPlaylists } from '@utils/unifiedTrackCache';

// ... in handleProcessAlbum, after line 1516 (after adding to collection) ...

    // 4. Update unified track cache - surgically move album from source to target playlist
    if (user.value) {
      try {
        // Ensure cache is loaded
        await loadUnifiedTrackCache(user.value.uid, userData.value?.lastFmUserName || '');
        
        // Move album in unified cache
        await moveAlbumBetweenPlaylists(
          id.value, // source playlist
          targetSpotifyPlaylistId, // target playlist
          album.id, // album ID
          user.value.uid,
          new Date().toISOString() // addedAt
        );
        
        logPlaylist(`Moved album ${album.id} in unified track cache from ${id.value} to ${targetSpotifyPlaylistId}`);
      } catch (error) {
        logPlaylist(`Error moving album in unified track cache:`, error);
        // Don't fail the whole operation if cache update fails
      }
    }
```

This updates the unified cache so the tracklist appears when viewing playlist 2.

---

_**User (2025-11-19 14:37Z)**_

ok look sgood. do it

---

_**Agent (model default, mode Agent)**_



---


Implementing the surgical cache update: adding the function and integrating it into `handleProcessAlbum`.


---

<tool-use data-tool-type="read" data-tool-name="read_file">
<details><summary>Tool use: **read_file** • Read file: src/utils/unifiedTrackCache.js</summary>

</details>
</tool-use>

---

<tool-use data-tool-type="read" data-tool-name="read_file">
<details><summary>Tool use: **read_file** • Read file: src/utils/unifiedTrackCache.js</summary>

</details>
</tool-use>

---

<tool-use data-tool-type="read" data-tool-name="read_file">
<details><summary>Tool use: **read_file** • Read file: src/views/playlists/PlaylistSingle.vue</summary>

</details>
</tool-use>

---

<tool-use data-tool-type="search" data-tool-name="grep">
<details>
<summary>Tool use: **grep** • Grep for "^export|^function" in "src/utils/unifiedTrackCache.js" • 29 matches</summary>

Output mode: content


| File | Content | Line |
|------|------|------|
| `src/utils/unifiedTrackCache.js` | `function normalizeTrackName(name) \{` | L30 |
| `src/utils/unifiedTrackCache.js` | `function normalizeArtistName(name) \{` | L37 |
| `src/utils/unifiedTrackCache.js` | `function createEmptyCache(userId, lastFmUserName) \{` | L44 |
| `src/utils/unifiedTrackCache.js` | `function validateCache(cache) \{` | L71 |
| `src/utils/unifiedTrackCache.js` | `export async function loadUnifiedTrackCache(userId, lastFmUserName) \{` | L81 |
| `src/utils/unifiedTrackCache.js` | `export async function saveUnifiedTrackCache(userId, immediate = false) \{` | L132 |
| `src/utils/unifiedTrackCache.js` | `function getInMemoryCache(userId) \{` | L198 |
| `src/utils/unifiedTrackCache.js` | `function updateTrackAccess(cache, trackId) \{` | L209 |
| `src/utils/unifiedTrackCache.js` | `function addTrackToIndexes(cache, track) \{` | L218 |
| `src/utils/unifiedTrackCache.js` | `function removeTrackFromIndexes(cache, trackId, track) \{` | L272 |
| `src/utils/unifiedTrackCache.js` | `export async function getAlbumTracks(albumId, userId) \{` | L286 |
| `src/utils/unifiedTrackCache.js` | `export async function getPlaylistAlbumTracks(playlistId, albumId, userId) \{` | L316 |
| `src/utils/unifiedTrackCache.js` | `export async function getPlaylistTracks(playlistId, userId) \{` | L344 |
| `src/utils/unifiedTrackCache.js` | `export function isTrackLoved(trackId, userId) \{` | L380 |
| `src/utils/unifiedTrackCache.js` | `export function getTrackPlaycount(trackId, userId) \{` | L388 |
| `src/utils/unifiedTrackCache.js` | `export async function updateTrackLoved(trackId, loved, userId, lastFmUserName, sessionKey, loveTrackFn, unloveTrackFn) \{` | L398 |
| `src/utils/unifiedTrackCache.js` | `export async function updateTrackPlaycount(trackId, playcount, userId) \{` | L481 |
| `src/utils/unifiedTrackCache.js` | `export async function addAlbumTracks(albumId, tracks, albumData, userId) \{` | L499 |
| `src/utils/unifiedTrackCache.js` | `export async function addPlaylistTracks(playlistId, playlistTracks, playlistName, userId) \{` | L562 |
| `src/utils/unifiedTrackCache.js` | `export async function refreshPlaycounts(trackIds, lastFmUserName, userId, progressCallback, getTrackInfoFn, forceRefresh = false) \{` | L744 |
| `src/utils/unifiedTrackCache.js` | `export async function refreshLovedTracks(lastFmUserName, userId, progressCallback, getUserLovedTracksFn) \{` | L806 |
| `src/utils/unifiedTrackCache.js` | `export async function buildPlaylistCache(` | L869 |
| `src/utils/unifiedTrackCache.js` | `export async function retryFailedSyncs(userId, lastFmUserName, sessionKey, loveTrackFn, unloveTrackFn) \{` | L982 |
| `src/utils/unifiedTrackCache.js` | `export function getUnsyncedChangesCount(userId) \{` | L1030 |
| `src/utils/unifiedTrackCache.js` | `export async function calculateAlbumLovedPercentage(albumId, userId) \{` | L1042 |
| `src/utils/unifiedTrackCache.js` | `export function getCacheStats(userId) \{` | L1067 |
| `src/utils/unifiedTrackCache.js` | `export async function clearUnifiedTrackCache(userId) \{` | L1086 |
| `src/utils/unifiedTrackCache.js` | `export function getTracklistPreference(playlistId) \{` | L1179 |
| `src/utils/unifiedTrackCache.js` | `export function setTracklistPreference(playlistId, enabled) \{` | L1188 |


</details>
</tool-use>

---



---


Adding the function and integrating it. Finding a good place to add it:


---

<tool-use data-tool-type="read" data-tool-name="read_file">
<details><summary>Tool use: **read_file** • Read file: src/utils/unifiedTrackCache.js</summary>

</details>
</tool-use>

---

<tool-use data-tool-type="read" data-tool-name="read_file">
<details><summary>Tool use: **read_file** • Read file: src/views/playlists/PlaylistSingle.vue</summary>

</details>
</tool-use>

---



---


Adding the function and integrating it:


---

<tool-use data-tool-type="write" data-tool-name="search_replace">

<details><summary>Tool use: **search_replace** • Edit file: src/utils/unifiedTrackCache.js</summary>

**Chunk 1**
Lines added: 79, lines removed: undefined

```diff
@@ -656,4 +656,83 @@
    await saveUnifiedTrackCache(userId);
  }
+ 
+ /**
+  * Move an album from one playlist to another in the unified cache
+  * @param {string} sourcePlaylistId - Source playlist ID
+  * @param {string} targetPlaylistId - Target playlist ID
+  * @param {string} albumId - Album ID to move
+  * @param {string} userId - User ID
+  * @param {string} addedAt - When album was added to target playlist (ISO string)
+  */
+ export async function moveAlbumBetweenPlaylists(sourcePlaylistId, targetPlaylistId, albumId, userId, addedAt) {
+   const cache = getInMemoryCache(userId);
+   const now = Date.now();
+   
+   // Ensure cache is loaded
+   if (!cache) {
+     throw new Error(&#96;Cache not loaded for user ${userId}&#96;);
+   }
+   
+   // Get the album entry from source playlist
+   if (!cache.playlists[sourcePlaylistId] || !cache.playlists[sourcePlaylistId].albums[albumId]) {
+     logCache(&#96;Album ${albumId} not found in source playlist ${sourcePlaylistId}, cannot move&#96;);
+     return;
+   }
+   
+   const albumEntry = cache.playlists[sourcePlaylistId].albums[albumId];
+   const trackIds = albumEntry.trackIds || [];
+   
+   // Initialize target playlist if it doesn't exist
+   if (!cache.playlists[targetPlaylistId]) {
+     cache.playlists[targetPlaylistId] = {
+       albums: {},
+       lastUpdated: now,
+       playlistName: ''
+     };
+   }
+   
+   const targetPlaylist = cache.playlists[targetPlaylistId];
+   targetPlaylist.lastUpdated = now;
+   
+   // Move album entry to target playlist
+   targetPlaylist.albums[albumId] = {
+     trackIds: [...trackIds], // Copy trackIds array
+     addedAt: addedAt || new Date().toISOString()
+   };
+   
+   // Remove album from source playlist
+   delete cache.playlists[sourcePlaylistId].albums[albumId];
+   
+   // Update track playlist relationships
+   for (const trackId of trackIds) {
+     if (!cache.tracks[trackId]) {
+       // Track doesn't exist in cache - this shouldn't happen but handle gracefully
+       logCache(&#96;Warning: Track ${trackId} not found in cache when moving album ${albumId}&#96;);
+       continue;
+     }
+     
+     const track = cache.tracks[trackId];
+     
+     // Remove source playlist from track's playlistIds
+     if (track.playlistIds) {
+       track.playlistIds = track.playlistIds.filter(pid =&gt; pid !== sourcePlaylistId);
+     } else {
+       track.playlistIds = [];
+     }
+     
+     // Add target playlist to track's playlistIds (if not already present)
+     if (!track.playlistIds.includes(targetPlaylistId)) {
+       track.playlistIds.push(targetPlaylistId);
+     }
+     
+     // Update track access time
+     track.lastAccessed = now;
+   }
+   
+   // Save the cache
+   await saveUnifiedTrackCache(userId);
+   
+   logCache(&#96;Moved album ${albumId} from playlist ${sourcePlaylistId} to ${targetPlaylistId}&#96;);
+ }
  
  /**
```

</details>

</tool-use>

---

<tool-use data-tool-type="write" data-tool-name="search_replace">

<details><summary>Tool use: **search_replace** • Edit file: src/views/playlists/PlaylistSingle.vue</summary>

**Chunk 1**
Lines added: 1, lines removed: 1

```diff
@@ -30,5 +30,5 @@
  import { useUnifiedTrackCache } from '@composables/useUnifiedTrackCache';
  import { usePlaycountTracking } from '@composables/usePlaycountTracking';
- import { loadUnifiedTrackCache } from '@utils/unifiedTrackCache';
+ import { loadUnifiedTrackCache, moveAlbumBetweenPlaylists } from '@utils/unifiedTrackCache';
  import { logPlaylist, logCache, enableDebug } from '@utils/logger';
  
```

</details>

</tool-use>

---

<tool-use data-tool-type="write" data-tool-name="search_replace">

<details><summary>Tool use: **search_replace** • Edit file: src/views/playlists/PlaylistSingle.vue</summary>

**Chunk 1**
Lines added: 22, lines removed: undefined

```diff
@@ -1515,4 +1515,26 @@
        spotifyAddedAt: new Date()
      });
+     
+     // 4. Update unified track cache - surgically move album from source to target playlist
+     if (user.value) {
+       try {
+         // Ensure cache is loaded
+         await loadUnifiedTrackCache(user.value.uid, userData.value?.lastFmUserName || '');
+         
+         // Move album in unified cache
+         await moveAlbumBetweenPlaylists(
+           id.value, // source playlist
+           targetSpotifyPlaylistId, // target playlist
+           album.id, // album ID
+           user.value.uid,
+           new Date().toISOString() // addedAt
+         );
+         
+         logPlaylist(&#96;Moved album ${album.id} in unified track cache from ${id.value} to ${targetSpotifyPlaylistId}&#96;);
+       } catch (error) {
+         logPlaylist(&#96;Error moving album in unified track cache:&#96;, error);
+         // Don't fail the whole operation if cache update fails
+       }
+     }
      
      const actionText = action === 'yes' ? 'moved to next stage' : 'terminated';
```

</details>

</tool-use>

---



---


Checking for linting errors:


---

<tool-use data-tool-type="generic" data-tool-name="read_lints">
<details>
          <summary>Tool use: **read_lints** • Read lints for 2 files</summary>
      
Lint paths:

- `src/utils/unifiedTrackCache.js`
- `src/views/playlists/PlaylistSingle.vue`

Lint results


**No lint errors found**
</details>
</tool-use>

---



---


Implemented the surgical cache update.

## Changes Made

1. **Added `moveAlbumBetweenPlaylists` function** in `src/utils/unifiedTrackCache.js`:
   - Moves the album entry from the source playlist to the target playlist in the unified cache
   - Updates track relationships (`playlistIds` arrays) for each track
   - Initializes the target playlist structure if it doesn't exist
   - Preserves track IDs and metadata

2. **Integrated into `handleProcessAlbum`** in `src/views/playlists/PlaylistSingle.vue`:
   - Calls `moveAlbumBetweenPlaylists` after adding the album to the target playlist
   - Ensures the unified track cache is loaded before moving
   - Wrapped in try/catch so cache failures don't break the operation

When you move an album from playlist 1 to playlist 2, the unified track cache is updated so the tracklist shows immediately when viewing playlist 2, without rebuilding the entire cache.

No linting errors found. Ready to test.

---

