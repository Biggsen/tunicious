<!-- Generated by SpecStory, Markdown v2.1.0 -->

<!-- cursor Session 315028bd-0840-4822-ba26-ecb925eed4ad (2025-12-05 09:31Z) -->

# Playlist track count not updating immediately (2025-12-05 09:31Z)

_**User (2025-12-05 09:10Z)**_

when I processed an album, the track count for the playlist isn't updating immediately. it updates when I refresh. I'm referring to the 97 tracks here inthe UI. can we look into where it's stored in the cache? and why it's not updating when I pricess an album

---

_**Agent (model default, mode Ask)**_



---


Investigating why the track count doesn't update immediately. Searching for where it's displayed and how it's calculated.


---

<tool-use data-tool-type="search" data-tool-name="codebase_search">
<details>
                <summary>Tool use: **codebase_search** • Searched codebase "track count display 97 tracks playlist statistics" • **15** results</summary>
            
| File | Lines |
|------|-------|
| `src/components/TrackList.vue` | L518-568 |
| `src/components/TrackList.vue` | L71-121 |
| `src/views/playlists/PlaylistSingle.vue` | L1273-1319 |
| `src/views/playlists/PlaylistSingle.vue` | L2211-2243 |
| `src/views/playlists/PlaylistSingle.vue` | L70-128 |
| `src/components/TrackList.vue` | L116-185 |
| `src/components/TrackList.vue` | L177-227 |
| `src/components/TrackList.vue` | L76 |
| `src/components/TrackList.vue` | L280-356 |
| `src/components/TrackList.vue` | L494-522 |
| `src/components/AlbumItem.vue` | L280-332 |
| `src/components/TrackList.vue` | L411-461 |
| `src/composables/useUnifiedTrackCache.js` | L30-392 |
| `src/components/SpotifyPlayerBar.vue` | L312-363 |
| `src/views/music/AlbumView.vue` | L449-493 |

</details>
</tool-use>

---

<tool-use data-tool-type="search" data-tool-name="codebase_search">
<details>
                <summary>Tool use: **codebase_search** • Searched codebase "process album update tracks cache" • **15** results</summary>
            
| File | Lines |
|------|-------|
| `src/utils/unifiedTrackCache.js` | L480-656 |
| `src/utils/unifiedTrackCache.js` | L556-665 |
| `src/utils/unifiedTrackCache.js` | L271-338 |
| `src/views/playlists/PlaylistSingle.vue` | L171-230 |
| `src/views/playlists/PlaylistSingle.vue` | L1630-1682 |
| `src/utils/unifiedTrackCache.js` | L498-656 |
| `src/utils/lastFmUtils.js` | L10-128 |
| `src/views/playlists/PlaylistSingle.vue` | L1559-1601 |
| `src/views/playlists/PlaylistSingle.vue` | L1176-1222 |
| `src/composables/useUnifiedTrackCache.js` | L30-392 |
| `src/views/playlists/PlaylistSingle.vue` | L228-279 |
| `src/utils/unifiedTrackCache.js` | L561-735 |
| `src/utils/unifiedTrackCache.js` | L665-815 |
| `tasks/unified-track-cache-spec.md` | L54 |
| `src/utils/unifiedTrackCache.js` | L285-374 |

</details>
</tool-use>

---

<tool-use data-tool-type="search" data-tool-name="grep">
<details>
<summary>Tool use: **grep** • Grep for "tracks.*in db|tracks" • 767 matches</summary>

Output mode: content


| File | Content | Line |
|------|------|------|
| `.\tasks\tunicious-project-summary.md` | `- **100-Track Limit**: Transient playlists capped at 100 tracks to force decision-making` | L57 |
| `.\tasks\tunicious-project-summary.md` | `- Album Tracking: Tracks album progression through playlists` | L62 |
| `.\tasks\tunicious-project-summary.md` | `- Last.fm Integration: Loved tracks and playcounts` | L63 |
| `.\tasks\tunicious-project-summary.md` | `- [x] Album Tracking - Tracks album progression through playlists` | L108 |
| `.\tasks\tunicious-project-summary.md` | `- [x] Last.fm Integration - Loved tracks and playcounts` | L109 |
| `.\tasks\unified-track-cache-spec.md` | `This document specifies the design and implementation of a unified, user-specific cache system that consolidates all track-related data (tracks, loved status, playcounts) into a single, highly efficient cache structure. This eliminates data duplication across multiple cache keys and provides a cache-first approach where updates happen in the cache without requiring API calls after the initial fetch.` | L5 |
| `.\tasks\unified-track-cache-spec.md` | `- `albumTracks_$\{albumId\}` - Full track objects per album` | L12 |
| `.\tasks\unified-track-cache-spec.md` | `- `playlist_tracks_$\{playlistId\}` - Track IDs only per playlist` | L13 |
| `.\tasks\unified-track-cache-spec.md` | `- `lovedTracks_$\{lastFmUserName\}` - Separate array of loved tracks` | L14 |
| `.\tasks\unified-track-cache-spec.md` | `- In-memory `albumTracks.value[albumId]` - Not persisted` | L15 |
| `.\tasks\unified-track-cache-spec.md` | `- Updating loved tracks array` | L23 |
| `.\tasks\unified-track-cache-spec.md` | `albumTracks_$\{albumId\} = [/* full track objects */]` | L35 |
| `.\tasks\unified-track-cache-spec.md` | `playlist_tracks_$\{playlistId\} = \{ albumId: \{ trackId: true \} \}` | L36 |
| `.\tasks\unified-track-cache-spec.md` | `lovedTracks_$\{lastFmUserName\} = [/* loved track objects */]` | L37 |
| `.\tasks\unified-track-cache-spec.md` | `A **single unified cache** (`user_tracks_$\{userId\}`) that stores:` | L45 |
| `.\tasks\unified-track-cache-spec.md` | `4. **Incremental Updates**: New tracks added as discovered, existing tracks updated in place` | L57 |
| `.\tasks\unified-track-cache-spec.md` | `user_tracks_$\{userId\}` | L65 |
| `.\tasks\unified-track-cache-spec.md` | `totalTracks: number;           // Total unique tracks` | L80 |
| `.\tasks\unified-track-cache-spec.md` | `unsyncedLovedTracks: Array<\{   // Failed sync operations` | L83 |
| `.\tasks\unified-track-cache-spec.md` | `// Tracks indexed by Spotify track ID (primary data store)` | L91 |
| `.\tasks\unified-track-cache-spec.md` | `tracks: \{` | L92 |
| `.\tasks\unified-track-cache-spec.md` | `lastUpdated: number;                // When album tracks were last fetched` | L129 |
| `.\tasks\unified-track-cache-spec.md` | `trackIds: string[];             // Tracks from this album in playlist` | L140 |
| `.\tasks\unified-track-cache-spec.md` | `lastUpdated: number;                // When playlist tracks were last fetched` | L144 |
| `.\tasks\unified-track-cache-spec.md` | `// Track name + artist lookup (for loved tracks matching)` | L151 |
| `.\tasks\unified-track-cache-spec.md` | `// Loved tracks lookup (for quick filtering)` | L163 |
| `.\tasks\unified-track-cache-spec.md` | `* Get tracks for an album` | L200 |
| `.\tasks\unified-track-cache-spec.md` | `export async function getAlbumTracks(albumId)` | L204 |
| `.\tasks\unified-track-cache-spec.md` | `* Get tracks for an album within a playlist context` | L207 |
| `.\tasks\unified-track-cache-spec.md` | `export async function getPlaylistAlbumTracks(playlistId, albumId)` | L212 |
| `.\tasks\unified-track-cache-spec.md` | `* Get all tracks for a playlist` | L215 |
| `.\tasks\unified-track-cache-spec.md` | `export async function getPlaylistTracks(playlistId)` | L219 |
| `.\tasks\unified-track-cache-spec.md` | `* Add tracks from an album to cache` | L252 |
| `.\tasks\unified-track-cache-spec.md` | `* @param \{Array<Track>\} tracks - Track objects from Spotify API` | L254 |
| `.\tasks\unified-track-cache-spec.md` | `export async function addAlbumTracks(albumId, tracks, albumData)` | L258 |
| `.\tasks\unified-track-cache-spec.md` | `* Add tracks from a playlist to cache` | L261 |
| `.\tasks\unified-track-cache-spec.md` | `* @param \{Array<PlaylistTrackItem>\} playlistTracks - Tracks from playlist API` | L263 |
| `.\tasks\unified-track-cache-spec.md` | `export async function addPlaylistTracks(playlistId, playlistTracks, playlistName)` | L267 |
| `.\tasks\unified-track-cache-spec.md` | `* Refresh playcounts for tracks (from Last.fm API)` | L280 |
| `.\tasks\unified-track-cache-spec.md` | `* Refresh loved tracks (from Last.fm API)` | L288 |
| `.\tasks\unified-track-cache-spec.md` | `export async function refreshLovedTracks(lastFmUserName)` | L292 |
| `.\tasks\unified-track-cache-spec.md` | `* Retry failed sync operations (loved/unloved tracks)` | L295 |
| `.\tasks\unified-track-cache-spec.md` | `- If enabled, automatically show tracklist and load cached tracks` | L350 |
| `.\tasks\unified-track-cache-spec.md` | `1. **Phase 1 (Primary):** Fetch playlist tracks` | L358 |
| `.\tasks\unified-track-cache-spec.md` | `- Fetch all tracks from Spotify playlist API` | L359 |
| `.\tasks\unified-track-cache-spec.md` | `- Extract unique tracks and albums` | L360 |
| `.\tasks\unified-track-cache-spec.md` | `2. **Phase 2 (Secondary):** Match loved tracks` | L368 |
| `.\tasks\unified-track-cache-spec.md` | `- Fetch loved tracks from Last.fm API (if not already cached)` | L369 |
| `.\tasks\unified-track-cache-spec.md` | `- Batch fetch playcounts for tracks (50-100 per batch)` | L378 |
| `.\tasks\unified-track-cache-spec.md` | `- "Loading tracks for [Playlist Name]..."` | L384 |
| `.\tasks\unified-track-cache-spec.md` | `- "Matching loved tracks (X of Y)..."` | L385 |
| `.\tasks\unified-track-cache-spec.md` | `- Loved tracks fetch fails: Retry 3 times, then continue without loved status (can refresh later)` | L391 |
| `.\tasks\unified-track-cache-spec.md` | `1. Fetch album tracks from Spotify API` | L396 |
| `.\tasks\unified-track-cache-spec.md` | `1. Update `tracks[trackId].loved` immediately (cache-first)` | L404 |
| `.\tasks\unified-track-cache-spec.md` | `- If sync succeeds: Remove from `metadata.unsyncedLovedTracks` (if present)` | L408 |
| `.\tasks\unified-track-cache-spec.md` | `- If sync fails: Add to `metadata.unsyncedLovedTracks` with retryCount: 0` | L409 |
| `.\tasks\unified-track-cache-spec.md` | `- Store failed syncs in `metadata.unsyncedLovedTracks`` | L415 |
| `.\tasks\unified-track-cache-spec.md` | `3. Update `tracks[trackId].playcount`` | L448 |
| `.\tasks\unified-track-cache-spec.md` | `4. Update `tracks[trackId].lastPlaycountUpdate`` | L449 |
| `.\tasks\unified-track-cache-spec.md` | `5. Update `tracks[trackId].lastAccessed` (for LRU eviction)` | L450 |
| `.\tasks\unified-track-cache-spec.md` | `- Last.fm uses a scrobbling threshold: tracks must be played for ~50% duration or 4 minutes (whichever is shorter) to count as a play` | L455 |
| `.\tasks\unified-track-cache-spec.md` | `- Tracks played for less than the threshold don't register as scrobbles` | L456 |
| `.\tasks\unified-track-cache-spec.md` | `- Can be matched later when loved tracks are refreshed` | L480 |
| `.\tasks\unified-track-cache-spec.md` | `Indexes are updated automatically when tracks are added/updated:` | L488 |
| `.\tasks\unified-track-cache-spec.md` | `- **albumsByArtist**: Updated when album tracks are added` | L493 |
| `.\tasks\unified-track-cache-spec.md` | `- Cache key: `user_tracks_$\{userId\}`` | L499 |
| `.\tasks\unified-track-cache-spec.md` | `- Tracks persist indefinitely (evict only via LRU on storage limits)` | L501 |
| `.\tasks\unified-track-cache-spec.md` | `- Tracks remain in cache indefinitely` | L532 |
| `.\tasks\unified-track-cache-spec.md` | `- 1000 tracks: ~500 KB` | L560 |
| `.\tasks\unified-track-cache-spec.md` | `- 5000 tracks: ~2.5 MB` | L561 |
| `.\tasks\unified-track-cache-spec.md` | `- 10000 tracks: ~5 MB` | L562 |
| `.\tasks\unified-track-cache-spec.md` | `1. **Orphaned tracks** (not in any `playlistIds` array) - lowest priority` | L574 |
| `.\tasks\unified-track-cache-spec.md` | `2. Among orphaned tracks, evict **oldest by `lastAccessed`** timestamp` | L575 |
| `.\tasks\unified-track-cache-spec.md` | `3. If still not enough space, evict **non-loved tracks** by `lastAccessed` (but always keep loved tracks)` | L576 |
| `.\tasks\unified-track-cache-spec.md` | `- **Always keep:** Loved tracks (`loved: true`)` | L580 |
| `.\tasks\unified-track-cache-spec.md` | `- **Always keep:** Tracks in playlists (`playlistIds.length > 0`)` | L581 |
| `.\tasks\unified-track-cache-spec.md` | `1. Find tracks where `playlistIds.length === 0` (orphaned)` | L585 |
| `.\tasks\unified-track-cache-spec.md` | `3. Evict oldest orphaned tracks` | L587 |
| `.\tasks\unified-track-cache-spec.md` | `4. If still failing, evict non-loved tracks by `lastAccessed`` | L588 |
| `.\tasks\unified-track-cache-spec.md` | `3. Split cache if needed (tracks vs. indexes)` | L602 |
| `.\tasks\unified-track-cache-spec.md` | `- `albumTracks_$\{albumId\}`` | L626 |
| `.\tasks\unified-track-cache-spec.md` | `- `playlist_tracks_$\{playlistId\}`` | L627 |
| `.\tasks\unified-track-cache-spec.md` | `- `lovedTracks_$\{lastFmUserName\}`` | L628 |
| `.\tasks\unified-track-cache-spec.md` | `- **Tracks by album**: O(1) - Direct album lookup, then track IDs` | L655 |
| `.\tasks\unified-track-cache-spec.md` | `- **Tracks by playlist**: O(1) - Direct playlist lookup` | L656 |
| `.\tasks\unified-track-cache-spec.md` | `- **Loved tracks**: O(1) - Pre-computed array` | L657 |
| `.\tasks\unified-track-cache-spec.md` | `- **Add album tracks**: O(n) - n = number of tracks` | L665 |
| `.\tasks\unified-track-cache-spec.md` | `- Load time: <100ms for 10,000 tracks (JSON parse)` | L675 |
| `.\tasks\unified-track-cache-spec.md` | `- Save time: <200ms for 10,000 tracks (JSON stringify)` | L676 |
| `.\tasks\unified-track-cache-spec.md` | `- Mark tracks as needing refresh` | L688 |
| `.\tasks\unified-track-cache-spec.md` | `- Show loading indicator: "Loading tracks..."` | L725 |
| `.\tasks\unified-track-cache-spec.md` | `- Show progress: "Matching loved tracks (X of Y)..."` | L726 |
| `.\tasks\unified-track-cache-spec.md` | `1. **Incremental Sync**: Only fetch new/updated tracks` | L752 |
| `.\tasks\unified-track-cache-spec.md` | `3. How should we handle tracks that are removed from playlists? (Mark as orphaned, evict after X days?)` | L815 |
| `.\tasks\unified-track-cache-spec.md` | `5. How often should we refresh playcounts for cached tracks? (Background job?)` | L817 |
| `.\src\views\playlists\PlaylistSingle.vue` | `import \{ getCachedLovedTracks, calculateLovedTrackPercentage \} from '@utils/lastFmUtils';` | L24 |
| `.\src\views\playlists\PlaylistSingle.vue` | `const \{ getPlaylist, getPlaylistAlbumsWithDates, loadAlbumsBatched, addAlbumToPlaylist, removeAlbumFromPlaylist: removeFromSpotify, loading: spotifyLoading, error: spotifyError, getAlbumTracks, getAllArtistAlbums, getAllPlaylistTracks \} = useUserSpotifyApi();` | L40 |
| `.\src\views\playlists\PlaylistSingle.vue` | `getAlbumTracksForPlaylist,` | L46 |
| `.\src\views\playlists\PlaylistSingle.vue` | `refreshLovedTracksForUser,` | L50 |
| `.\src\views\playlists\PlaylistSingle.vue` | `refreshPlaycountsForTracks,` | L51 |
| `.\src\views\playlists\PlaylistSingle.vue` | `const totalTracks = ref(0);` | L73 |
| `.\src\views\playlists\PlaylistSingle.vue` | `const tracksLoading = ref(false);` | L106 |
| `.\src\views\playlists\PlaylistSingle.vue` | `// Computed property to get tracks for each album from unified cache` | L109 |
| `.\src\views\playlists\PlaylistSingle.vue` | `const albumTracks = computed(() => \{` | L110 |
| `.\src\views\playlists\PlaylistSingle.vue` | `const tracksMap = \{};` | L113 |
| `.\src\views\playlists\PlaylistSingle.vue` | `// For now, return empty - tracks will be loaded via buildCacheForPlaylist` | L116 |
| `.\src\views\playlists\PlaylistSingle.vue` | `return tracksMap;` | L118 |
| `.\src\views\playlists\PlaylistSingle.vue` | `// Reactive tracks storage (populated from cache)` | L121 |
| `.\src\views\playlists\PlaylistSingle.vue` | `const albumTracksData = ref(\{});` | L122 |
| `.\src\views\playlists\PlaylistSingle.vue` | `// Update track playcount in albumTracksData when playcount changes` | L127 |
| `.\src\views\playlists\PlaylistSingle.vue` | `Object.keys(albumTracksData.value).forEach(albumId => \{` | L130 |
| `.\src\views\playlists\PlaylistSingle.vue` | `const tracks = albumTracksData.value[albumId];` | L131 |
| `.\src\views\playlists\PlaylistSingle.vue` | `if (Array.isArray(tracks)) \{` | L132 |
| `.\src\views\playlists\PlaylistSingle.vue` | `const trackIndex = tracks.findIndex(t => t.id === trackId);` | L133 |
| `.\src\views\playlists\PlaylistSingle.vue` | `albumTracksData.value[albumId] = [` | L136 |
| `.\src\views\playlists\PlaylistSingle.vue` | `...tracks.slice(0, trackIndex),` | L137 |
| `.\src\views\playlists\PlaylistSingle.vue` | `...tracks[trackIndex],` | L139 |
| `.\src\views\playlists\PlaylistSingle.vue` | `...tracks.slice(trackIndex + 1)` | L142 |
| `.\src\views\playlists\PlaylistSingle.vue` | `// Fetch tracks for all albums when tracklists are enabled (using unified cache)` | L175 |
| `.\src\views\playlists\PlaylistSingle.vue` | `const fetchAlbumTracks = async () => \{` | L176 |
| `.\src\views\playlists\PlaylistSingle.vue` | `logPlaylist('Skipping fetchAlbumTracks:', \{` | L178 |
| `.\src\views\playlists\PlaylistSingle.vue` | `logPlaylist('Fetching album tracks:', \{` | L186 |
| `.\src\views\playlists\PlaylistSingle.vue` | `tracksLoading.value = true;` | L191 |
| `.\src\views\playlists\PlaylistSingle.vue` | `// Check if we have albums and at least one has tracks` | L203 |
| `.\src\views\playlists\PlaylistSingle.vue` | `const hasTracks = albumKeys.some(albumId => \{` | L204 |
| `.\src\views\playlists\PlaylistSingle.vue` | `if (hasTracks) \{` | L209 |
| `.\src\views\playlists\PlaylistSingle.vue` | `// Load tracks from unified cache for each album` | L228 |
| `.\src\views\playlists\PlaylistSingle.vue` | `logPlaylist('Loading tracks for albums from cache');` | L229 |
| `.\src\views\playlists\PlaylistSingle.vue` | `logCache('Fetching tracks for album:', \{ playlistId: id.value, albumId: album.id, albumName: album.name \});` | L232 |
| `.\src\views\playlists\PlaylistSingle.vue` | `const tracks = await getAlbumTracksForPlaylist(id.value, album.id);` | L233 |
| `.\src\views\playlists\PlaylistSingle.vue` | `albumTracksData.value[album.id] = tracks;` | L234 |
| `.\src\views\playlists\PlaylistSingle.vue` | `logCache('Loaded tracks for album:', \{ albumId: album.id, trackCount: tracks.length \});` | L235 |
| `.\src\views\playlists\PlaylistSingle.vue` | `logPlaylist(`Failed to get tracks for album $\{album.id\}:`, error);` | L237 |
| `.\src\views\playlists\PlaylistSingle.vue` | `albumTracksData.value[album.id] = [];` | L238 |
| `.\src\views\playlists\PlaylistSingle.vue` | `logPlaylist('All album tracks fetched successfully');` | L243 |
| `.\src\views\playlists\PlaylistSingle.vue` | `logPlaylist('Error building cache or fetching tracks:', error);` | L245 |
| `.\src\views\playlists\PlaylistSingle.vue` | `tracksLoading.value = false;` | L247 |
| `.\src\views\playlists\PlaylistSingle.vue` | `// Watch for showTracklists changes - fetch tracks and persist per-playlist preference` | L252 |
| `.\src\views\playlists\PlaylistSingle.vue` | `// Fetch tracks if enabled` | L259 |
| `.\src\views\playlists\PlaylistSingle.vue` | `fetchAlbumTracks();` | L261 |
| `.\src\views\playlists\PlaylistSingle.vue` | `// Clear tracks data when disabled` | L263 |
| `.\src\views\playlists\PlaylistSingle.vue` | `albumTracksData.value = \{};` | L264 |
| `.\src\views\playlists\PlaylistSingle.vue` | `fetchAlbumTracks();` | L273 |
| `.\src\views\playlists\PlaylistSingle.vue` | `// Optimistic UI update: update track in albumTracksData immediately` | L283 |
| `.\src\views\playlists\PlaylistSingle.vue` | `if (albumTracksData.value[album.id]) \{` | L284 |
| `.\src\views\playlists\PlaylistSingle.vue` | `const trackIndex = albumTracksData.value[album.id].findIndex(t => t.id === track.id);` | L285 |
| `.\src\views\playlists\PlaylistSingle.vue` | `albumTracksData.value[album.id] = [` | L288 |
| `.\src\views\playlists\PlaylistSingle.vue` | `...albumTracksData.value[album.id].slice(0, trackIndex),` | L289 |
| `.\src\views\playlists\PlaylistSingle.vue` | `...albumTracksData.value[album.id][trackIndex],` | L291 |
| `.\src\views\playlists\PlaylistSingle.vue` | `...albumTracksData.value[album.id].slice(trackIndex + 1)` | L294 |
| `.\src\views\playlists\PlaylistSingle.vue` | `if (albumTracksData.value[album.id]) \{` | L315 |
| `.\src\views\playlists\PlaylistSingle.vue` | `const trackIndex = albumTracksData.value[album.id].findIndex(t => t.id === track.id);` | L316 |
| `.\src\views\playlists\PlaylistSingle.vue` | `albumTracksData.value[album.id] = [` | L319 |
| `.\src\views\playlists\PlaylistSingle.vue` | `...albumTracksData.value[album.id].slice(0, trackIndex),` | L320 |
| `.\src\views\playlists\PlaylistSingle.vue` | `...albumTracksData.value[album.id][trackIndex],` | L322 |
| `.\src\views\playlists\PlaylistSingle.vue` | `...albumTracksData.value[album.id].slice(trackIndex + 1)` | L325 |
| `.\src\views\playlists\PlaylistSingle.vue` | `// On error, refresh loved tracks from Last.fm` | L330 |
| `.\src\views\playlists\PlaylistSingle.vue` | `await refreshLovedTracksForUser();` | L333 |
| `.\src\views\playlists\PlaylistSingle.vue` | `logPlaylist('Error refreshing loved tracks:', refreshError);` | L344 |
| `.\src\views\playlists\PlaylistSingle.vue` | `// Optimistic UI update: update track in albumTracksData immediately` | L354 |
| `.\src\views\playlists\PlaylistSingle.vue` | `if (albumTracksData.value[album.id]) \{` | L355 |
| `.\src\views\playlists\PlaylistSingle.vue` | `const trackIndex = albumTracksData.value[album.id].findIndex(t => t.id === track.id);` | L356 |
| `.\src\views\playlists\PlaylistSingle.vue` | `albumTracksData.value[album.id] = [` | L359 |
| `.\src\views\playlists\PlaylistSingle.vue` | `...albumTracksData.value[album.id].slice(0, trackIndex),` | L360 |
| `.\src\views\playlists\PlaylistSingle.vue` | `...albumTracksData.value[album.id][trackIndex],` | L362 |
| `.\src\views\playlists\PlaylistSingle.vue` | `...albumTracksData.value[album.id].slice(trackIndex + 1)` | L365 |
| `.\src\views\playlists\PlaylistSingle.vue` | `if (albumTracksData.value[album.id]) \{` | L386 |
| `.\src\views\playlists\PlaylistSingle.vue` | `const trackIndex = albumTracksData.value[album.id].findIndex(t => t.id === track.id);` | L387 |
| `.\src\views\playlists\PlaylistSingle.vue` | `albumTracksData.value[album.id] = [` | L390 |
| `.\src\views\playlists\PlaylistSingle.vue` | `...albumTracksData.value[album.id].slice(0, trackIndex),` | L391 |
| `.\src\views\playlists\PlaylistSingle.vue` | `...albumTracksData.value[album.id][trackIndex],` | L393 |
| `.\src\views\playlists\PlaylistSingle.vue` | `...albumTracksData.value[album.id].slice(trackIndex + 1)` | L396 |
| `.\src\views\playlists\PlaylistSingle.vue` | `// On error, refresh loved tracks from Last.fm` | L401 |
| `.\src\views\playlists\PlaylistSingle.vue` | `await refreshLovedTracksForUser();` | L404 |
| `.\src\views\playlists\PlaylistSingle.vue` | `logPlaylist('Error refreshing loved tracks:', refreshError);` | L415 |
| `.\src\views\playlists\PlaylistSingle.vue` | `// Manual refresh of loved tracks and playcounts from Last.fm` | L421 |
| `.\src\views\playlists\PlaylistSingle.vue` | `const refreshingLovedTracks = ref(false);` | L422 |
| `.\src\views\playlists\PlaylistSingle.vue` | `const refreshLovedTracks = async () => \{` | L423 |
| `.\src\views\playlists\PlaylistSingle.vue` | `refreshingLovedTracks.value = true;` | L427 |
| `.\src\views\playlists\PlaylistSingle.vue` | `// Refresh loved tracks from Last.fm using unified cache` | L429 |
| `.\src\views\playlists\PlaylistSingle.vue` | `await refreshLovedTracksForUser();` | L430 |
| `.\src\views\playlists\PlaylistSingle.vue` | `// Reload tracks from cache to reflect updated loved status` | L432 |
| `.\src\views\playlists\PlaylistSingle.vue` | `// Reload tracks for all albums to get fresh loved status from cache` | L434 |
| `.\src\views\playlists\PlaylistSingle.vue` | `const tracks = await getAlbumTracksForPlaylist(id.value, album.id);` | L437 |
| `.\src\views\playlists\PlaylistSingle.vue` | `albumTracksData.value[album.id] = tracks;` | L438 |
| `.\src\views\playlists\PlaylistSingle.vue` | `logPlaylist(`Failed to reload tracks for album $\{album.id\}:`, error);` | L440 |
| `.\src\views\playlists\PlaylistSingle.vue` | `const trackIds = Object.values(albumTracksData.value)` | L460 |
| `.\src\views\playlists\PlaylistSingle.vue` | `await refreshPlaycountsForTracks(trackIds);` | L468 |
| `.\src\views\playlists\PlaylistSingle.vue` | `// Reload tracks from cache to reflect updated playcounts` | L470 |
| `.\src\views\playlists\PlaylistSingle.vue` | `const tracks = await getAlbumTracksForPlaylist(id.value, album.id);` | L473 |
| `.\src\views\playlists\PlaylistSingle.vue` | `albumTracksData.value[album.id] = tracks;` | L474 |
| `.\src\views\playlists\PlaylistSingle.vue` | `logPlaylist(`Failed to reload tracks for album $\{album.id\}:`, error);` | L476 |
| `.\src\views\playlists\PlaylistSingle.vue` | `logPlaylist('Error refreshing loved tracks and playcounts:', error);` | L487 |
| `.\src\views\playlists\PlaylistSingle.vue` | `refreshingLovedTracks.value = false;` | L489 |
| `.\src\views\playlists\PlaylistSingle.vue` | `await fetchAlbumTracks();` | L615 |
| `.\src\views\playlists\PlaylistSingle.vue` | `// Last.fm loved tracks data` | L780 |
| `.\src\views\playlists\PlaylistSingle.vue` | `const lovedTracksLoadingStarted = ref(false);` | L781 |
| `.\src\views\playlists\PlaylistSingle.vue` | `if (!userData.value?.lastFmUserName \|\| lovedTracksLoadingStarted.value) \{` | L796 |
| `.\src\views\playlists\PlaylistSingle.vue` | `lovedTracksLoadingStarted.value = true;` | L801 |
| `.\src\views\playlists\PlaylistSingle.vue` | `if (!lovedTracksLoadingStarted.value) \{` | L1003 |
| `.\src\views\playlists\PlaylistSingle.vue` | `// Clear playlist tracks cache` | L1029 |
| `.\src\views\playlists\PlaylistSingle.vue` | `await clearCache(`playlist_tracks_$\{id.value\}`);` | L1031 |
| `.\src\views\playlists\PlaylistSingle.vue` | `// Clear tracks data` | L1067 |
| `.\src\views\playlists\PlaylistSingle.vue` | `albumTracksData.value = \{};` | L1068 |
| `.\src\views\playlists\PlaylistSingle.vue` | `// Clear loved tracks data` | L1070 |
| `.\src\views\playlists\PlaylistSingle.vue` | `lovedTracksLoadingStarted.value = false;` | L1071 |
| `.\src\views\playlists\PlaylistSingle.vue` | `// Clear loved tracks cache if exists` | L1074 |
| `.\src\views\playlists\PlaylistSingle.vue` | `await clearCache(`lovedTracks_$\{userData.value.lastFmUserName\}`);` | L1076 |
| `.\src\views\playlists\PlaylistSingle.vue` | `await fetchAlbumTracks();` | L1083 |
| `.\src\views\playlists\PlaylistSingle.vue` | `await fetchAlbumTracks();` | L1158 |
| `.\src\views\playlists\PlaylistSingle.vue` | `await fetchAlbumTracks();` | L1173 |
| `.\src\views\playlists\PlaylistSingle.vue` | `totalTracks.value = playlistResponse.tracks?.total \|\| 0;` | L1270 |
| `.\src\views\playlists\PlaylistSingle.vue` | `logPlaylist('Playlist details fetched:', \{ name: playlistName.value, totalTracks: totalTracks.value \});` | L1271 |
| `.\src\views\playlists\PlaylistSingle.vue` | `if (user.value && totalTracks.value === 0) \{` | L1278 |
| `.\src\views\playlists\PlaylistSingle.vue` | `if (cachedPlaylist?.tracks?.total !== undefined) \{` | L1289 |
| `.\src\views\playlists\PlaylistSingle.vue` | `totalTracks.value = cachedPlaylist.tracks.total;` | L1290 |
| `.\src\views\playlists\PlaylistSingle.vue` | `logPlaylist('Track count loaded from playlist_summaries cache:', totalTracks.value);` | L1291 |
| `.\src\views\playlists\PlaylistSingle.vue` | `if (totalTracks.value === 0) \{` | L1302 |
| `.\src\views\playlists\PlaylistSingle.vue` | `totalTracks.value = playlistResponse.tracks?.total \|\| 0;` | L1306 |
| `.\src\views\playlists\PlaylistSingle.vue` | `logPlaylist('Track count fetched from Spotify API:', totalTracks.value);` | L1307 |
| `.\src\views\playlists\PlaylistSingle.vue` | `const tracks = albumTracksData.value[alb.id] \|\| [];` | L1347 |
| `.\src\views\playlists\PlaylistSingle.vue` | `return tracks.some(t =>` | L1348 |
| `.\src\views\playlists\PlaylistSingle.vue` | `const tracks = albumTracksData.value[alb.id] \|\| [];` | L1369 |
| `.\src\views\playlists\PlaylistSingle.vue` | `return tracks.some(t =>` | L1370 |
| `.\src\views\playlists\PlaylistSingle.vue` | `fetchAlbumTracks();` | L1412 |
| `.\src\views\playlists\PlaylistSingle.vue` | `@click="refreshLovedTracks"` | L2172 |
| `.\src\views\playlists\PlaylistSingle.vue` | `:disabled="refreshingLovedTracks"` | L2173 |
| `.\src\views\playlists\PlaylistSingle.vue` | `title="Refresh loved tracks and playcounts with Last.fm"` | L2174 |
| `.\src\views\playlists\PlaylistSingle.vue` | `<HeartIcon class="h-5 w-5" :class="\{ 'animate-spin': refreshingLovedTracks \}" />` | L2177 |
| `.\src\views\playlists\PlaylistSingle.vue` | `\{{ refreshingLovedTracks ? 'Refreshing...' : 'Refresh' \}}` | L2179 |
| `.\src\views\playlists\PlaylistSingle.vue` | `<p class="text-lg mb-4"><span class="text-2xl font-bold">\{{ totalTracks \}}</span> tracks</p>` | L2227 |
| `.\src\views\playlists\PlaylistSingle.vue` | `<div v-if="tracksLoading" class="mb-4 text-center">` | L2583 |
| `.\src\views\playlists\PlaylistSingle.vue` | `:tracks="albumTracksData[album.id] \|\| []"` | L2608 |
| `.\src\utils\unifiedTrackCache.js` | `const CACHE_KEY_PREFIX = 'user_tracks_';` | L9 |
| `.\src\utils\unifiedTrackCache.js` | `totalTracks: 0,` | L51 |
| `.\src\utils\unifiedTrackCache.js` | `unsyncedLovedTracks: []` | L54 |
| `.\src\utils\unifiedTrackCache.js` | `tracks: \{},` | L56 |
| `.\src\utils\unifiedTrackCache.js` | `if (!cache.metadata \|\| !cache.tracks \|\| !cache.albums \|\| !cache.playlists \|\| !cache.indexes) return false;` | L73 |
| `.\src\utils\unifiedTrackCache.js` | `logCache(`Loaded unified track cache for user $\{userId\}: $\{cachedData.metadata.totalTracks\} tracks`);` | L110 |
| `.\src\utils\unifiedTrackCache.js` | `cache.metadata.totalTracks = Object.keys(cache.tracks).length;` | L149 |
| `.\src\utils\unifiedTrackCache.js` | `await evictLRUTracks(userId);` | L158 |
| `.\src\utils\unifiedTrackCache.js` | `if (cache.tracks[trackId]) \{` | L210 |
| `.\src\utils\unifiedTrackCache.js` | `cache.tracks[trackId].lastAccessed = Date.now();` | L211 |
| `.\src\utils\unifiedTrackCache.js` | `* Get tracks for an album` | L284 |
| `.\src\utils\unifiedTrackCache.js` | `export async function getAlbumTracks(albumId, userId) \{` | L286 |
| `.\src\utils\unifiedTrackCache.js` | `const tracks = trackIds` | L294 |
| `.\src\utils\unifiedTrackCache.js` | `.map(trackId => cache.tracks[trackId])` | L295 |
| `.\src\utils\unifiedTrackCache.js` | `return tracks;` | L310 |
| `.\src\utils\unifiedTrackCache.js` | `* Get tracks for an album within a playlist context` | L314 |
| `.\src\utils\unifiedTrackCache.js` | `export async function getPlaylistAlbumTracks(playlistId, albumId, userId) \{` | L316 |
| `.\src\utils\unifiedTrackCache.js` | `const tracks = trackIds` | L324 |
| `.\src\utils\unifiedTrackCache.js` | `.map(trackId => cache.tracks[trackId])` | L325 |
| `.\src\utils\unifiedTrackCache.js` | `return tracks;` | L338 |
| `.\src\utils\unifiedTrackCache.js` | `* Get all tracks for a playlist` | L342 |
| `.\src\utils\unifiedTrackCache.js` | `export async function getPlaylistTracks(playlistId, userId) \{` | L344 |
| `.\src\utils\unifiedTrackCache.js` | `const tracks = Array.from(allTrackIds)` | L360 |
| `.\src\utils\unifiedTrackCache.js` | `.map(trackId => cache.tracks[trackId])` | L361 |
| `.\src\utils\unifiedTrackCache.js` | `return tracks;` | L374 |
| `.\src\utils\unifiedTrackCache.js` | `return cache.tracks[trackId]?.loved \|\| false;` | L382 |
| `.\src\utils\unifiedTrackCache.js` | `return cache.tracks[trackId]?.playcount \|\| 0;` | L390 |
| `.\src\utils\unifiedTrackCache.js` | `if (!cache.tracks[trackId]) \{` | L401 |
| `.\src\utils\unifiedTrackCache.js` | `const track = cache.tracks[trackId];` | L406 |
| `.\src\utils\unifiedTrackCache.js` | `cache.metadata.unsyncedLovedTracks = cache.metadata.unsyncedLovedTracks.filter(` | L450 |
| `.\src\utils\unifiedTrackCache.js` | `const existingIndex = cache.metadata.unsyncedLovedTracks.findIndex(item => item.trackId === trackId);` | L460 |
| `.\src\utils\unifiedTrackCache.js` | `cache.metadata.unsyncedLovedTracks[existingIndex].retryCount++;` | L463 |
| `.\src\utils\unifiedTrackCache.js` | `cache.metadata.unsyncedLovedTracks.push(\{` | L465 |
| `.\src\utils\unifiedTrackCache.js` | `if (!cache.tracks[trackId]) \{` | L484 |
| `.\src\utils\unifiedTrackCache.js` | `cache.tracks[trackId].playcount = playcount;` | L489 |
| `.\src\utils\unifiedTrackCache.js` | `cache.tracks[trackId].lastPlaycountUpdate = Date.now();` | L490 |
| `.\src\utils\unifiedTrackCache.js` | `* Add tracks from an album to cache` | L497 |
| `.\src\utils\unifiedTrackCache.js` | `export async function addAlbumTracks(albumId, tracks, albumData, userId) \{` | L499 |
| `.\src\utils\unifiedTrackCache.js` | `for (const track of tracks) \{` | L518 |
| `.\src\utils\unifiedTrackCache.js` | `if (!cache.tracks[trackId]) \{` | L522 |
| `.\src\utils\unifiedTrackCache.js` | `cache.tracks[trackId] = \{` | L523 |
| `.\src\utils\unifiedTrackCache.js` | `if (!cache.tracks[trackId].albumIds.includes(albumId)) \{` | L543 |
| `.\src\utils\unifiedTrackCache.js` | `cache.tracks[trackId].albumIds.push(albumId);` | L544 |
| `.\src\utils\unifiedTrackCache.js` | `addTrackToIndexes(cache, cache.tracks[trackId]);` | L553 |
| `.\src\utils\unifiedTrackCache.js` | `* Add tracks from a playlist to cache` | L560 |
| `.\src\utils\unifiedTrackCache.js` | `export async function addPlaylistTracks(playlistId, playlistTracks, playlistName, userId) \{` | L562 |
| `.\src\utils\unifiedTrackCache.js` | `// Group tracks by album` | L579 |
| `.\src\utils\unifiedTrackCache.js` | `for (const playlistTrack of playlistTracks) \{` | L582 |
| `.\src\utils\unifiedTrackCache.js` | `if (!cache.tracks[trackId]) \{` | L603 |
| `.\src\utils\unifiedTrackCache.js` | `cache.tracks[trackId] = \{` | L604 |
| `.\src\utils\unifiedTrackCache.js` | `if (!cache.tracks[trackId].albumIds.includes(albumId)) \{` | L624 |
| `.\src\utils\unifiedTrackCache.js` | `cache.tracks[trackId].albumIds.push(albumId);` | L625 |
| `.\src\utils\unifiedTrackCache.js` | `if (!cache.tracks[trackId].playlistIds.includes(playlistId)) \{` | L627 |
| `.\src\utils\unifiedTrackCache.js` | `cache.tracks[trackId].playlistIds.push(playlistId);` | L628 |
| `.\src\utils\unifiedTrackCache.js` | `addTrackToIndexes(cache, cache.tracks[trackId]);` | L632 |
| `.\src\utils\unifiedTrackCache.js` | `if (!cache.tracks[trackId]) \{` | L708 |
| `.\src\utils\unifiedTrackCache.js` | `const track = cache.tracks[trackId];` | L714 |
| `.\src\utils\unifiedTrackCache.js` | `* Match loved tracks to cached tracks` | L739 |
| `.\src\utils\unifiedTrackCache.js` | `async function matchLovedTracks(cache, lovedTracks, progressCallback) \{` | L741 |
| `.\src\utils\unifiedTrackCache.js` | `const totalTracks = Object.keys(cache.tracks).length;` | L743 |
| `.\src\utils\unifiedTrackCache.js` | `for (const lovedTrack of lovedTracks) \{` | L745 |
| `.\src\utils\unifiedTrackCache.js` | `if (cache.tracks[trackId] && !cache.tracks[trackId].loved) \{` | L758 |
| `.\src\utils\unifiedTrackCache.js` | `cache.tracks[trackId].loved = true;` | L759 |
| `.\src\utils\unifiedTrackCache.js` | `cache.tracks[trackId].lastLovedUpdate = Date.now();` | L760 |
| `.\src\utils\unifiedTrackCache.js` | `for (const trackId in cache.tracks) \{` | L775 |
| `.\src\utils\unifiedTrackCache.js` | `const track = cache.tracks[trackId];` | L776 |
| `.\src\utils\unifiedTrackCache.js` | `total: lovedTracks.length,` | L809 |
| `.\src\utils\unifiedTrackCache.js` | `message: `Matching loved tracks ($\{matchedCount\} of $\{lovedTracks.length\})...`` | L810 |
| `.\src\utils\unifiedTrackCache.js` | `* Refresh playcounts for tracks (from Last.fm API)` | L819 |
| `.\src\utils\unifiedTrackCache.js` | `// Batch process tracks (50 at a time to avoid rate limits)` | L829 |
| `.\src\utils\unifiedTrackCache.js` | `const track = cache.tracks[trackId];` | L835 |
| `.\src\utils\unifiedTrackCache.js` | `* Refresh loved tracks (from Last.fm API)` | L882 |
| `.\src\utils\unifiedTrackCache.js` | `* @param \{Function\} getUserLovedTracksFn - Function to get user's loved tracks from Last.fm` | L883 |
| `.\src\utils\unifiedTrackCache.js` | `export async function refreshLovedTracks(lastFmUserName, userId, progressCallback, getUserLovedTracksFn) \{` | L885 |
| `.\src\utils\unifiedTrackCache.js` | `if (!getUserLovedTracksFn) \{` | L888 |
| `.\src\utils\unifiedTrackCache.js` | `throw new Error('getUserLovedTracks function is required');` | L889 |
| `.\src\utils\unifiedTrackCache.js` | `// This handles cases where tracks were unloved on Last.fm` | L894 |
| `.\src\utils\unifiedTrackCache.js` | `for (const trackId in cache.tracks) \{` | L895 |
| `.\src\utils\unifiedTrackCache.js` | `if (cache.tracks[trackId].loved) \{` | L896 |
| `.\src\utils\unifiedTrackCache.js` | `cache.tracks[trackId].loved = false;` | L897 |
| `.\src\utils\unifiedTrackCache.js` | `// Fetch all loved tracks (paginated)` | L903 |
| `.\src\utils\unifiedTrackCache.js` | `let allLovedTracks = [];` | L904 |
| `.\src\utils\unifiedTrackCache.js` | `const response = await getUserLovedTracksFn(lastFmUserName, limit, page);` | L909 |
| `.\src\utils\unifiedTrackCache.js` | `const lovedTracks = response.lovedtracks?.track \|\| [];` | L910 |
| `.\src\utils\unifiedTrackCache.js` | `if (!lovedTracks.length) break;` | L912 |
| `.\src\utils\unifiedTrackCache.js` | `allLovedTracks = allLovedTracks.concat(lovedTracks);` | L914 |
| `.\src\utils\unifiedTrackCache.js` | `const totalPages = Math.ceil((response.lovedtracks?.['@attr']?.total \|\| 0) / limit);` | L917 |
| `.\src\utils\unifiedTrackCache.js` | `// Match loved tracks to cached tracks` | L923 |
| `.\src\utils\unifiedTrackCache.js` | `const matchedCount = await matchLovedTracks(cache, allLovedTracks, progressCallback);` | L924 |
| `.\src\utils\unifiedTrackCache.js` | `totalLovedTracks: allLovedTracks.length,` | L932 |
| `.\src\utils\unifiedTrackCache.js` | `logCache('Error refreshing loved tracks:', error);` | L936 |
| `.\src\utils\unifiedTrackCache.js` | `* @param \{Function\} getAllPlaylistTracksFn - Function to get all playlist tracks from Spotify` | L943 |
| `.\src\utils\unifiedTrackCache.js` | `* @param \{Function\} getUserLovedTracksFn - Function to get user's loved tracks from Last.fm` | L945 |
| `.\src\utils\unifiedTrackCache.js` | `getAllPlaylistTracksFn,` | L953 |
| `.\src\utils\unifiedTrackCache.js` | `getUserLovedTracksFn,` | L955 |
| `.\src\utils\unifiedTrackCache.js` | `if (!getAllPlaylistTracksFn \|\| !getPlaylistFn) \{` | L960 |
| `.\src\utils\unifiedTrackCache.js` | `// 3. At least one album has tracks (not empty)` | L968 |
| `.\src\utils\unifiedTrackCache.js` | `// Check if we have albums and at least one has tracks` | L972 |
| `.\src\utils\unifiedTrackCache.js` | `const hasTracks = albumKeys.some(albumId => \{` | L973 |
| `.\src\utils\unifiedTrackCache.js` | `if (hasTracks) \{` | L978 |
| `.\src\utils\unifiedTrackCache.js` | `// If playlist exists but has no tracks, log and rebuild` | L989 |
| `.\src\utils\unifiedTrackCache.js` | `logCache(`Playlist $\{playlistId\} exists but has no tracks, rebuilding cache`);` | L990 |
| `.\src\utils\unifiedTrackCache.js` | `// Phase 1: Fetch playlist tracks` | L994 |
| `.\src\utils\unifiedTrackCache.js` | `message: `Loading tracks for playlist...`` | L998 |
| `.\src\utils\unifiedTrackCache.js` | `const playlistTracks = await getAllPlaylistTracksFn(playlistId);` | L1002 |
| `.\src\utils\unifiedTrackCache.js` | `await addPlaylistTracks(playlistId, playlistTracks, playlist.name, userId);` | L1005 |
| `.\src\utils\unifiedTrackCache.js` | `message: `Loaded $\{playlistTracks.length\} tracks`` | L1010 |
| `.\src\utils\unifiedTrackCache.js` | `// Phase 2: Match loved tracks` | L1014 |
| `.\src\utils\unifiedTrackCache.js` | `if (lastFmUserName && getUserLovedTracksFn) \{` | L1015 |
| `.\src\utils\unifiedTrackCache.js` | `message: `Matching loved tracks...`` | L1019 |
| `.\src\utils\unifiedTrackCache.js` | `await refreshLovedTracks(lastFmUserName, userId, progressCallback, getUserLovedTracksFn);` | L1023 |
| `.\src\utils\unifiedTrackCache.js` | `const trackIds = Object.keys(cache.tracks).filter(trackId => \{` | L1027 |
| `.\src\utils\unifiedTrackCache.js` | `const track = cache.tracks[trackId];` | L1028 |
| `.\src\utils\unifiedTrackCache.js` | `* Retry failed sync operations (loved/unloved tracks)` | L1057 |
| `.\src\utils\unifiedTrackCache.js` | `if (!cache.metadata.unsyncedLovedTracks.length) \{` | L1064 |
| `.\src\utils\unifiedTrackCache.js` | `const unsynced = cache.metadata.unsyncedLovedTracks.filter(item => item.retryCount < 10);` | L1073 |
| `.\src\utils\unifiedTrackCache.js` | `const track = cache.tracks[item.trackId];` | L1078 |
| `.\src\utils\unifiedTrackCache.js` | `return cache.metadata.unsyncedLovedTracks.length;` | L1112 |
| `.\src\utils\unifiedTrackCache.js` | `if (cache.tracks[trackId]?.loved) \{` | L1132 |
| `.\src\utils\unifiedTrackCache.js` | `totalTracks: cache.metadata.totalTracks,` | L1150 |
| `.\src\utils\unifiedTrackCache.js` | `lovedTracks: cache.indexes.lovedTrackIds.length,` | L1153 |
| `.\src\utils\unifiedTrackCache.js` | `unsyncedChanges: cache.metadata.unsyncedLovedTracks.length,` | L1154 |
| `.\src\utils\unifiedTrackCache.js` | `* LRU Eviction: Evict orphaned tracks when storage quota is exceeded` | L1177 |
| `.\src\utils\unifiedTrackCache.js` | `async function evictLRUTracks(userId) \{` | L1179 |
| `.\src\utils\unifiedTrackCache.js` | `// Find orphaned tracks (not in any playlist)` | L1182 |
| `.\src\utils\unifiedTrackCache.js` | `const orphanedTracks = Object.keys(cache.tracks).filter(trackId => \{` | L1183 |
| `.\src\utils\unifiedTrackCache.js` | `const track = cache.tracks[trackId];` | L1184 |
| `.\src\utils\unifiedTrackCache.js` | `orphanedTracks.sort((a, b) => \{` | L1189 |
| `.\src\utils\unifiedTrackCache.js` | `const trackA = cache.tracks[a];` | L1190 |
| `.\src\utils\unifiedTrackCache.js` | `const trackB = cache.tracks[b];` | L1191 |
| `.\src\utils\unifiedTrackCache.js` | `// Evict orphaned tracks (oldest first)` | L1197 |
| `.\src\utils\unifiedTrackCache.js` | `for (const trackId of orphanedTracks) \{` | L1199 |


</details>
</tool-use>

---



---


Checking where albums are processed and how the track count cache is updated:


---

<tool-use data-tool-type="read" data-tool-name="read_file">
<details><summary>Tool use: **read_file** • Read file: src/views/playlists/PlaylistSingle.vue</summary>

</details>
</tool-use>

---

<tool-use data-tool-type="search" data-tool-name="codebase_search">
<details>
                <summary>Tool use: **codebase_search** • Searched codebase "playlist_summaries cache update track count total" • **15** results</summary>
            
| File | Lines |
|------|-------|
| `src/views/playlists/PlaylistSingle.vue` | L1273-1319 |
| `src/views/playlists/AddPlaylistView.vue` | L376-425 |
| `src/utils/unifiedTrackCache.js` | L498-656 |
| `src/views/playlists/PlaylistSingle.vue` | L1598-1633 |
| `src/views/playlists/PlaylistView.vue` | L155-199 |
| `src/views/playlists/PlaylistSingle.vue` | L1241-1278 |
| `src/utils/unifiedTrackCache.js` | L740-883 |
| `src/utils/unifiedTrackCache.js` | L439-556 |
| `src/utils/unifiedTrackCache.js` | L946-1059 |
| `tasks/unified-track-cache-spec.md` | L339-395 |
| `src/composables/useUnifiedTrackCache.js` | L30-392 |
| `src/composables/usePlaycountTracking.js` | L16-219 |
| `src/views/playlists/PlaylistSingle.vue` | L1429-1476 |
| `src/utils/unifiedTrackCache.js` | L315-382 |
| `src/composables/usePlaylistUpdates.js` | L9-135 |

</details>
</tool-use>

---

<tool-use data-tool-type="search" data-tool-name="grep">
<details>
<summary>Tool use: **grep** • Grep for "playlist_summaries" • 11 matches</summary>

Output mode: content


| File | Content | Line |
|------|------|------|
| `.\src\views\playlists\PlaylistSingle.vue` | `// Always try to get track count from playlist_summaries_ cache` | L1277 |
| `.\src\views\playlists\PlaylistSingle.vue` | `const playlistViewCacheKey = `playlist_summaries_$\{user.value.uid\}`;` | L1280 |
| `.\src\views\playlists\PlaylistSingle.vue` | `logPlaylist('Track count loaded from playlist_summaries cache:', totalTracks.value);` | L1291 |
| `.\src\views\playlists\PlaylistSingle.vue` | `logPlaylist('Error loading track count from playlist_summaries cache:', error);` | L1297 |
| `.\src\views\playlists\PlaylistSingle.vue` | `const playlistViewCacheKey = `playlist_summaries_$\{user.value.uid\}`;` | L1466 |
| `.\src\views\playlists\PlaylistSingle.vue` | `const playlistViewCacheKey = `playlist_summaries_$\{user.value.uid\}`;` | L1501 |
| `.\src\views\playlists\PlaylistSingle.vue` | `const playlistViewCacheKey = `playlist_summaries_$\{user.value.uid\}`;` | L1601 |
| `.\src\views\playlists\PlaylistView.vue` | `const cacheKey = computed(() => user.value ? `playlist_summaries_$\{user.value.uid\}` : null);` | L35 |
| `.\src\views\playlists\AddPlaylistView.vue` | `const playlistViewCacheKey = `playlist_summaries_$\{user.value.uid\}`;` | L383 |
| `.\src\utils\cache.js` | `* @param \{string\} cacheKey - The cache key (e.g., 'playlist_summaries_userId')` | L183 |
| `.\src\utils\cache.js` | `* @param \{string\} cacheKey - The cache key (e.g., 'playlist_summaries_userId')` | L231 |


</details>
</tool-use>

---



---


Checking where albums are processed and whether the cache is updated:


---

<tool-use data-tool-type="read" data-tool-name="read_file">
<details><summary>Tool use: **read_file** • Read file: src/views/playlists/PlaylistSingle.vue</summary>

</details>
</tool-use>

---

<tool-use data-tool-type="search" data-tool-name="codebase_search">
<details>
                <summary>Tool use: **codebase_search** • Searched codebase "refreshSpecificPlaylists update playlist_summaries cache track count" • **12** results</summary>
            
| File | Lines |
|------|-------|
| `src/views/playlists/PlaylistSingle.vue` | L1598-1633 |
| `src/composables/usePlaylistUpdates.js` | L9-135 |
| `src/views/playlists/PlaylistSingle.vue` | L1273-1319 |
| `src/composables/usePlaylistUpdates.js` | L135 |
| `src/views/playlists/AddPlaylistView.vue` | L376-425 |
| `src/utils/unifiedTrackCache.js` | L740-883 |
| `src/views/playlists/PlaylistView.vue` | L196-260 |
| `src/views/playlists/PlaylistView.vue` | L44 |
| `src/views/playlists/PlaylistView.vue` | L155-199 |
| `src/utils/unifiedTrackCache.js` | L946-1059 |
| `src/utils/unifiedTrackCache.js` | L498-656 |
| `src/utils/cache.js` | L122-232 |

</details>
</tool-use>

---



---


Checking how `totalTracks` is updated and whether it listens to cache changes:


---

<tool-use data-tool-type="read" data-tool-name="read_file">
<details><summary>Tool use: **read_file** • Read file: src/views/playlists/PlaylistSingle.vue</summary>

</details>
</tool-use>

---

<tool-use data-tool-type="search" data-tool-name="grep">
<details>
<summary>Tool use: **grep** • Grep for "totalTracks\.value\s*=" • 5 matches</summary>

Output mode: content


| File | Content | Line |
|------|------|------|
| `.\src\views\playlists\PlaylistSingle.vue` | `totalTracks.value = playlistResponse.tracks?.total \|\| 0;` | L1270 |
| `.\src\views\playlists\PlaylistSingle.vue` | `if (user.value && totalTracks.value === 0) \{` | L1278 |
| `.\src\views\playlists\PlaylistSingle.vue` | `totalTracks.value = cachedPlaylist.tracks.total;` | L1290 |
| `.\src\views\playlists\PlaylistSingle.vue` | `if (totalTracks.value === 0) \{` | L1302 |
| `.\src\views\playlists\PlaylistSingle.vue` | `totalTracks.value = playlistResponse.tracks?.total \|\| 0;` | L1306 |


</details>
</tool-use>

---

<tool-use data-tool-type="search" data-tool-name="codebase_search">
<details>
                <summary>Tool use: **codebase_search** • Searched codebase "playlist-albums-updated event listener totalTracks update" • **15** results</summary>
            
| File | Lines |
|------|-------|
| `src/views/playlists/PlaylistSingle.vue` | L1316-1363 |
| `src/views/playlists/PlaylistSingle.vue` | L70-128 |
| `src/views/playlists/PlaylistSingle.vue` | L1380-1435 |
| `src/views/playlists/PlaylistManagementView.vue` | L372-421 |
| `src/views/playlists/PlaylistSingle.vue` | L2211-2243 |
| `src/views/playlists/PlaylistSingle.vue` | L2580-2624 |
| `src/views/playlists/PlaylistSingle.vue` | L1598-1633 |
| `src/views/playlists/PlaylistSingle.vue` | L1273-1319 |
| `src/views/playlists/AddPlaylistView.vue` | L376-425 |
| `src/components/TrackList.vue` | L280-356 |
| `src/views/playlists/PlaylistView.vue` | L256-324 |
| `src/components/TrackList.vue` | L76 |
| `src/composables/useUserSpotifyApi.js` | L5-654 |
| `src/views/playlists/PlaylistSingle.vue` | L126-176 |
| `src/composables/usePlaycountTracking.js` | L16-219 |

</details>
</tool-use>

---



---


## The Problem

The track count (`totalTracks`) is stored in the `playlist_summaries_${userId}` cache and displayed in the UI. When you process an album:

1. The cache is updated via `refreshSpecificPlaylists()` (lines 1609-1618 in `PlaylistSingle.vue`)
2. The `totalTracks` ref in the component is not updated after the cache refresh

The component only reads the track count during initial load in `loadPlaylistPage()` (lines 1278-1299), so it doesn't reflect cache updates after processing.

## The Solution

After `refreshSpecificPlaylists` updates the cache in `handleProcessAlbum`, also update `totalTracks.value` by reading from the updated cache or fetching from Spotify.

Here's the fix to add after line 1618 in `handleProcessAlbum`:

```javascript:src/views/playlists/PlaylistSingle.vue
// ... existing code at line 1618 ...
      logPlaylist(`Cache saved successfully`);
      
      // Update totalTracks in the UI from the updated cache
      try {
        const updatedCache = await getCache(playlistViewCacheKey);
        if (updatedCache) {
          for (const group of Object.keys(updatedCache)) {
            const groupPlaylists = updatedCache[group] || [];
            const cachedPlaylist = groupPlaylists.find(p => p.id === id.value);
            if (cachedPlaylist?.tracks?.total !== undefined) {
              totalTracks.value = cachedPlaylist.tracks.total;
              logPlaylist('Track count updated from cache after processing:', totalTracks.value);
              break;
            }
          }
        }
      } catch (error) {
        logPlaylist('Error updating track count from cache:', error);
        // Fallback: fetch directly from Spotify
        try {
          const playlistResponse = await getPlaylist(id.value);
          totalTracks.value = playlistResponse.tracks?.total || 0;
          logPlaylist('Track count fetched from Spotify API as fallback:', totalTracks.value);
        } catch (spotifyError) {
          logPlaylist('Error fetching track count from Spotify API:', spotifyError);
        }
      }
    } else {
// ... rest of existing code ...
```

This reads the updated track count from the cache after processing and updates the UI immediately, so a refresh isn't needed.

Should I apply this change?

---

_**User (2025-12-05 09:10Z)**_

apply it

---

_**Agent (model default, mode Agent)**_



---


Applying the fix. Checking the current state of the file:


---

<tool-use data-tool-type="read" data-tool-name="read_file">
<details><summary>Tool use: **read_file** • Read file: src/views/playlists/PlaylistSingle.vue</summary>

</details>
</tool-use>

---



---


Checking imports to ensure we have the necessary functions:


---

<tool-use data-tool-type="read" data-tool-name="read_file">
<details><summary>Tool use: **read_file** • Read file: src/views/playlists/PlaylistSingle.vue</summary>

</details>
</tool-use>

---



---


Adding code to update `totalTracks` after the cache is saved:


---

<tool-use data-tool-type="write" data-tool-name="search_replace">

<details><summary>Tool use: **search_replace** • Edit file: src/views/playlists/PlaylistSingle.vue</summary>

**Chunk 1**
Lines added: 23, lines removed: undefined

```diff
@@ -1618,4 +1618,27 @@
          await setCache(playlistViewCacheKey, updatedState);
          logPlaylist(&#96;Cache saved successfully&#96;);
+         
+         // Update totalTracks in the UI from the updated cache
+         try {
+           for (const group of Object.keys(updatedState)) {
+             const groupPlaylists = updatedState[group] || [];
+             const cachedPlaylist = groupPlaylists.find(p =&gt; p.id === id.value);
+             if (cachedPlaylist?.tracks?.total !== undefined) {
+               totalTracks.value = cachedPlaylist.tracks.total;
+               logPlaylist('Track count updated from cache after processing:', totalTracks.value);
+               break;
+             }
+           }
+         } catch (error) {
+           logPlaylist('Error updating track count from cache:', error);
+           // Fallback: fetch directly from Spotify
+           try {
+             const playlistResponse = await getPlaylist(id.value);
+             totalTracks.value = playlistResponse.tracks?.total || 0;
+             logPlaylist('Track count fetched from Spotify API as fallback:', totalTracks.value);
+           } catch (spotifyError) {
+             logPlaylist('Error fetching track count from Spotify API:', spotifyError);
+           }
+         }
        } else {
          logPlaylist(&#96;WARNING: Updated state is empty, not saving to cache&#96;);
```

</details>

</tool-use>

---



---


Checking if `handleAddAlbum` and `handleRemoveAlbum` need the same fix:


---

<tool-use data-tool-type="read" data-tool-name="read_file">
<details><summary>Tool use: **read_file** • Read file: src/views/playlists/PlaylistSingle.vue</summary>

</details>
</tool-use>

---



---


Checking for linting errors:


---

<tool-use data-tool-type="generic" data-tool-name="read_lints">
<details>
          <summary>Tool use: **read_lints** • Read lints for 1 file</summary>
      
Lint paths:

- `src/views/playlists/PlaylistSingle.vue`

Lint results

Lint errors for `src/views/playlists/PlaylistSingle.vue`


| Message | Range | Severity |
|-------|-------|----------|
| Unknown at rule @apply | 2770:3-2770:9 | DIAGNOSTIC_SEVERITY_WARNING |
| Unknown at rule @apply | 2766:3-2766:9 | DIAGNOSTIC_SEVERITY_WARNING |
| Unknown at rule @apply | 2762:3-2762:9 | DIAGNOSTIC_SEVERITY_WARNING |
| Unknown at rule @apply | 2756:3-2756:9 | DIAGNOSTIC_SEVERITY_WARNING |
| Unknown at rule @apply | 2752:3-2752:9 | DIAGNOSTIC_SEVERITY_WARNING |
| 'useRouter' is declared but its value is never read. | 3:20-3:29 | DIAGNOSTIC_SEVERITY_HINT |
| 'BarsArrowUpIcon' is declared but its value is never read. | 17:37-17:52 | DIAGNOSTIC_SEVERITY_HINT |
| 'BarsArrowDownIcon' is declared but its value is never read. | 17:54-17:71 | DIAGNOSTIC_SEVERITY_HINT |
| 'MusicalNoteIcon' is declared but its value is never read. | 18:1-18:60 | DIAGNOSTIC_SEVERITY_HINT |
| All imports in import declaration are unused. | 24:1-24:90 | DIAGNOSTIC_SEVERITY_HINT |
| 'getAlbumTracks' is declared but its value is never read. | 40:179-40:193 | DIAGNOSTIC_SEVERITY_HINT |
| 'getAllPlaylistTracks' is declared but its value is never read. | 40:215-40:235 | DIAGNOSTIC_SEVERITY_HINT |
| 'getCurrentPlaylistInfo' is declared but its value is never read. | 42:9-42:31 | DIAGNOSTIC_SEVERITY_HINT |
| 'getAlbumRatingData' is declared but its value is never read. | 42:110-42:128 | DIAGNOSTIC_SEVERITY_HINT |
| 'searchAlbumsByTitleAndArtist' is declared but its value is never read. | 42:177-42:205 | DIAGNOSTIC_SEVERITY_HINT |
| 'isAlternateId' is declared but its value is never read. | 43:23-43:36 | DIAGNOSTIC_SEVERITY_HINT |
| All destructured elements are unused. | 44:7-44:33 | DIAGNOSTIC_SEVERITY_HINT |
| 'cacheLoading' is declared but its value is never read. | 54:12-54:24 | DIAGNOSTIC_SEVERITY_HINT |
| 'cacheBuildProgress' is declared but its value is never read. | 55:18-55:36 | DIAGNOSTIC_SEVERITY_HINT |
| 'albumTracks' is declared but its value is never read. | 110:7-110:18 | DIAGNOSTIC_SEVERITY_HINT |
| 'album' is declared but its value is never read. | 114:14-114:19 | DIAGNOSTIC_SEVERITY_HINT |
| 'targetPlaylistId' is declared but its value is never read. | 1522:9-1522:25 | DIAGNOSTIC_SEVERITY_HINT |
| 'cancelBatchProcessing' is declared but its value is never read. | 1801:7-1801:28 | DIAGNOSTIC_SEVERITY_HINT |


</details>
</tool-use>

---



---


The lint warnings are CSS-related (Tailwind `@apply`) and not related to our change. Verifying the fix was applied correctly:


---

<tool-use data-tool-type="read" data-tool-name="read_file">
<details><summary>Tool use: **read_file** • Read file: src/views/playlists/PlaylistSingle.vue</summary>

</details>
</tool-use>

---



---


Fix applied. After processing an album, the track count updates immediately.

**What was fixed:**
- After `refreshSpecificPlaylists` updates the cache, the code reads the updated track count from `updatedState` (already in memory) and updates `totalTracks.value` immediately
- Includes a fallback to fetch from the Spotify API if there's an error reading from the cache
- The UI now shows the correct track count without requiring a page refresh

The track count (e.g., "97 tracks") will update immediately when you process an album, reflecting the new count after the album is moved to another playlist.

---

