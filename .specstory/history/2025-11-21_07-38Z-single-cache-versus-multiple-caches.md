<!-- Generated by SpecStory, Markdown v2.1.0 -->

<!-- cursor Session 28674389-7c10-4ccd-998f-86270b418586 (2025-11-21 07:38Z) -->

# Single cache versus multiple caches (2025-11-21 07:38Z)

_**User (2025-11-19 14:37Z)**_

we still have a lot of different caches handling different data. we still have alot of overlaps and redundancies. is it good practice to have a single cache to work with? or are multipe caches better?

---

_**Agent (model default, mode Agent)**_



---


Reviewing the current cache implementation to identify overlaps and redundancies.


---

<tool-use data-tool-type="search" data-tool-name="codebase_search">
<details>
                <summary>Tool use: **codebase_search** • Searched codebase "What cache implementations exist in the codebase?" • **15** results</summary>
            
| File | Lines |
|------|-------|
| `tasks/unified-track-cache-spec.md` | L54 |
| `tasks/unified-track-cache-spec.md` | L490-536 |
| `src/utils/cache.js` | L65 |
| `tasks/unified-track-cache-spec.md` | L48-91 |
| `src/utils/unifiedTrackCache.js` | L38 |
| `src/composables/useCache.js` | L59 |
| `tasks/unified-track-cache-spec.md` | L533-584 |
| `tasks/unified-track-cache-spec.md` | L719-775 |
| `tasks/unified-track-cache-spec.md` | L582-641 |
| `src/utils/unifiedTrackCache.js` | L80-203 |
| `src/utils/unifiedTrackCache.js` | L70-192 |
| `tasks/unified-track-cache-spec.md` | L274-344 |
| `tasks/unified-track-cache-spec.md` | L638-721 |
| `tasks/unified-track-cache-spec.md` | L773-818 |
| `src/utils/cache.js` | L5-77 |

</details>
</tool-use>

---

<tool-use data-tool-type="search" data-tool-name="grep">
<details>
<summary>Tool use: **grep** • Grep for "cache|Cache" • 822 matches</summary>

Output mode: content


| File | Content | Line |
|------|------|------|
| `.\src\views\playlists\PlaylistSingle.vue` | `import \{ setCache, getCache, clearCache \} from "@utils/cache";` | L4 |
| `.\src\views\playlists\PlaylistSingle.vue` | `import \{ getCachedLovedTracks, calculateLovedTrackPercentage \} from '@utils/lastFmUtils';` | L24 |
| `.\src\views\playlists\PlaylistSingle.vue` | `import \{ useUnifiedTrackCache \} from '@composables/useUnifiedTrackCache';` | L30 |
| `.\src\views\playlists\PlaylistSingle.vue` | `import \{ loadUnifiedTrackCache, moveAlbumBetweenPlaylists, saveUnifiedTrackCache \} from '@utils/unifiedTrackCache';` | L32 |
| `.\src\views\playlists\PlaylistSingle.vue` | `import \{ logPlaylist, logCache, enableDebug \} from '@utils/logger';` | L33 |
| `.\src\views\playlists\PlaylistSingle.vue` | `buildCacheForPlaylist,` | L49 |
| `.\src\views\playlists\PlaylistSingle.vue` | `loading: cacheLoading,` | L54 |
| `.\src\views\playlists\PlaylistSingle.vue` | `buildProgress: cacheBuildProgress` | L55 |
| `.\src\views\playlists\PlaylistSingle.vue` | `\} = useUnifiedTrackCache();` | L56 |
| `.\src\views\playlists\PlaylistSingle.vue` | `const cacheCleared = ref(false);` | L67 |
| `.\src\views\playlists\PlaylistSingle.vue` | `const cacheBuilding = ref(false);` | L107 |
| `.\src\views\playlists\PlaylistSingle.vue` | `// Computed property to get tracks for each album from unified cache` | L109 |
| `.\src\views\playlists\PlaylistSingle.vue` | `// For now, return empty - tracks will be loaded via buildCacheForPlaylist` | L116 |
| `.\src\views\playlists\PlaylistSingle.vue` | `// Reactive tracks storage (populated from cache)` | L121 |
| `.\src\views\playlists\PlaylistSingle.vue` | `// Fetch tracks for all albums when tracklists are enabled (using unified cache)` | L175 |
| `.\src\views\playlists\PlaylistSingle.vue` | `cacheBuilding.value = true;` | L192 |
| `.\src\views\playlists\PlaylistSingle.vue` | `// Check if playlist is already cached before building` | L195 |
| `.\src\views\playlists\PlaylistSingle.vue` | `const cache = await loadUnifiedTrackCache(user.value.uid, userData.value?.lastFmUserName \|\| '');` | L199 |
| `.\src\views\playlists\PlaylistSingle.vue` | `const existingPlaylist = cache?.playlists[id.value];` | L200 |
| `.\src\views\playlists\PlaylistSingle.vue` | `logCache(`Playlist $\{id.value\} already cached, skipping cache build`);` | L210 |
| `.\src\views\playlists\PlaylistSingle.vue` | `logCache('Error checking cache for playlist:', error);` | L215 |
| `.\src\views\playlists\PlaylistSingle.vue` | `// Only build cache if it doesn't exist` | L219 |
| `.\src\views\playlists\PlaylistSingle.vue` | `logCache('Building cache for playlist:', id.value);` | L221 |
| `.\src\views\playlists\PlaylistSingle.vue` | `await buildCacheForPlaylist(id.value, (progress) => \{` | L222 |
| `.\src\views\playlists\PlaylistSingle.vue` | `logPlaylist('Cache build progress:', progress);` | L223 |
| `.\src\views\playlists\PlaylistSingle.vue` | `logCache('Cache build complete for playlist:', id.value);` | L225 |
| `.\src\views\playlists\PlaylistSingle.vue` | `// Load tracks from unified cache for each album` | L228 |
| `.\src\views\playlists\PlaylistSingle.vue` | `logPlaylist('Loading tracks for albums from cache');` | L229 |
| `.\src\views\playlists\PlaylistSingle.vue` | `logCache('Fetching tracks for album:', \{ playlistId: id.value, albumId: album.id, albumName: album.name \});` | L232 |
| `.\src\views\playlists\PlaylistSingle.vue` | `logCache('Loaded tracks for album:', \{ albumId: album.id, trackCount: tracks.length \});` | L235 |
| `.\src\views\playlists\PlaylistSingle.vue` | `logPlaylist('Error building cache or fetching tracks:', error);` | L245 |
| `.\src\views\playlists\PlaylistSingle.vue` | `cacheBuilding.value = false;` | L248 |
| `.\src\views\playlists\PlaylistSingle.vue` | `// Handle track loving/unloving with unified cache` | L278 |
| `.\src\views\playlists\PlaylistSingle.vue` | `// Update loved status in unified cache (optimistic update with background sync)` | L299 |
| `.\src\views\playlists\PlaylistSingle.vue` | `// Update loved status in unified cache (optimistic update with background sync)` | L370 |
| `.\src\views\playlists\PlaylistSingle.vue` | `// Refresh loved tracks from Last.fm using unified cache` | L429 |
| `.\src\views\playlists\PlaylistSingle.vue` | `// Reload tracks from cache to reflect updated loved status` | L432 |
| `.\src\views\playlists\PlaylistSingle.vue` | `// Reload tracks for all albums to get fresh loved status from cache` | L434 |
| `.\src\views\playlists\PlaylistSingle.vue` | `// Recalculate all loved track percentages using unified cache` | L447 |
| `.\src\views\playlists\PlaylistSingle.vue` | `// Reload tracks from cache to reflect updated playcounts` | L470 |
| `.\src\views\playlists\PlaylistSingle.vue` | `const detailsArr = await Promise.all(batch.map(id => getCachedAlbumDetails(id)));` | L508 |
| `.\src\views\playlists\PlaylistSingle.vue` | `const detailsArr = await Promise.all(batch.map(id => getCachedAlbumDetails(id)));` | L537 |
| `.\src\views\playlists\PlaylistSingle.vue` | `// Calculate loved track percentages for all albums using unified cache` | L568 |
| `.\src\views\playlists\PlaylistSingle.vue` | `// Update cache keys` | L743 |
| `.\src\views\playlists\PlaylistSingle.vue` | `const albumIdListCacheKey = computed(() => `playlist_$\{id.value\}_albumsWithDates`);` | L744 |
| `.\src\views\playlists\PlaylistSingle.vue` | `const pageCacheKey = (page) => `playlist_$\{id.value\}_page_$\{page\}_$\{sortMode.value\}_$\{sortDirection.value\}`;` | L745 |
| `.\src\views\playlists\PlaylistSingle.vue` | `// Add a cache utility for album root details` | L784 |
| `.\src\views\playlists\PlaylistSingle.vue` | `async function getCachedAlbumDetails(albumId) \{` | L785 |
| `.\src\views\playlists\PlaylistSingle.vue` | `const cacheKey = `albumRootData_$\{albumId\}`;` | L786 |
| `.\src\views\playlists\PlaylistSingle.vue` | `let cached = await getCache(cacheKey);` | L787 |
| `.\src\views\playlists\PlaylistSingle.vue` | `if (cached) return cached;` | L788 |
| `.\src\views\playlists\PlaylistSingle.vue` | `if (details) await setCache(cacheKey, details);` | L790 |
| `.\src\views\playlists\PlaylistSingle.vue` | `// Progressive loading of loved track percentages (using unified cache)` | L794 |
| `.\src\views\playlists\PlaylistSingle.vue` | `// Calculate percentages progressively for each album using unified cache` | L813 |
| `.\src\views\playlists\PlaylistSingle.vue` | `// Calculate percentages for new albums using unified cache` | L870 |
| `.\src\views\playlists\PlaylistSingle.vue` | `logPlaylist('Fetching album ID list:', \{ playlistId, cacheKey: albumIdListCacheKey.value \});` | L913 |
| `.\src\views\playlists\PlaylistSingle.vue` | `let albumsWithDatesData = await getCache(albumIdListCacheKey.value);` | L914 |
| `.\src\views\playlists\PlaylistSingle.vue` | `logCache('Cache miss for album ID list, fetching from Spotify');` | L916 |
| `.\src\views\playlists\PlaylistSingle.vue` | `logCache('Caching album ID list:', \{ count: albumsWithDatesData.length \});` | L918 |
| `.\src\views\playlists\PlaylistSingle.vue` | `await setCache(albumIdListCacheKey.value, albumsWithDatesData);` | L919 |
| `.\src\views\playlists\PlaylistSingle.vue` | `logCache('Cache hit for album ID list:', \{ count: albumsWithDatesData.length \});` | L921 |
| `.\src\views\playlists\PlaylistSingle.vue` | `// Check cache first` | L942 |
| `.\src\views\playlists\PlaylistSingle.vue` | `let pageAlbums = await getCache(pageCacheKey(page));` | L943 |
| `.\src\views\playlists\PlaylistSingle.vue` | `// Cache the combined result` | L967 |
| `.\src\views\playlists\PlaylistSingle.vue` | `await setCache(pageCacheKey(page), pageAlbums);` | L968 |
| `.\src\views\playlists\PlaylistSingle.vue` | `const rootDetailsArr = await Promise.all(albumData.value.map(a => getCachedAlbumDetails(a.id)));` | L981 |
| `.\src\views\playlists\PlaylistSingle.vue` | `async function handleClearCache() \{` | L1013 |
| `.\src\views\playlists\PlaylistSingle.vue` | `// Clear all related cache keys for this playlist` | L1014 |
| `.\src\views\playlists\PlaylistSingle.vue` | `await clearCache(albumIdListCacheKey.value);` | L1015 |
| `.\src\views\playlists\PlaylistSingle.vue` | `// Clear page caches for all sort modes and directions` | L1017 |
| `.\src\views\playlists\PlaylistSingle.vue` | `await clearCache(`playlist_$\{id.value\}_page_$\{page\}_$\{mode\}_$\{dir\}`);` | L1024 |
| `.\src\views\playlists\PlaylistSingle.vue` | `// Clear playlist tracks cache` | L1029 |
| `.\src\views\playlists\PlaylistSingle.vue` | `await clearCache(`playlist_tracks_$\{id.value\}`);` | L1031 |
| `.\src\views\playlists\PlaylistSingle.vue` | `// Also clear albumDbData cache for all albums on the current page` | L1034 |
| `.\src\views\playlists\PlaylistSingle.vue` | `await clearCache(`albumDbData_$\{album.id\}_$\{user.value.uid\}`);` | L1037 |
| `.\src\views\playlists\PlaylistSingle.vue` | `// Clear album root data cache as well` | L1038 |
| `.\src\views\playlists\PlaylistSingle.vue` | `await clearCache(`albumRootData_$\{album.id\}`);` | L1039 |
| `.\src\views\playlists\PlaylistSingle.vue` | `// Clear the playlist from unified track cache to force full rebuild` | L1043 |
| `.\src\views\playlists\PlaylistSingle.vue` | `const cache = await loadUnifiedTrackCache(user.value.uid, userData.value?.lastFmUserName \|\| '');` | L1046 |
| `.\src\views\playlists\PlaylistSingle.vue` | `if (cache?.playlists[id.value]) \{` | L1047 |
| `.\src\views\playlists\PlaylistSingle.vue` | `delete cache.playlists[id.value];` | L1048 |
| `.\src\views\playlists\PlaylistSingle.vue` | `await saveUnifiedTrackCache(user.value.uid, true);` | L1049 |
| `.\src\views\playlists\PlaylistSingle.vue` | `logCache(`Removed playlist $\{id.value\} from unified cache to force rebuild`);` | L1050 |
| `.\src\views\playlists\PlaylistSingle.vue` | `logCache('Error removing playlist from unified cache:', error);` | L1053 |
| `.\src\views\playlists\PlaylistSingle.vue` | `cacheCleared.value = true;` | L1057 |
| `.\src\views\playlists\PlaylistSingle.vue` | `// Clear loved tracks cache if exists` | L1074 |
| `.\src\views\playlists\PlaylistSingle.vue` | `await clearCache(`lovedTracks_$\{userData.value.lastFmUserName\}`);` | L1076 |
| `.\src\views\playlists\PlaylistSingle.vue` | `// Clear the cache for this album to ensure fresh data` | L1189 |
| `.\src\views\playlists\PlaylistSingle.vue` | `const cacheKey = `albumRootData_$\{albumId\}`;` | L1190 |
| `.\src\views\playlists\PlaylistSingle.vue` | `await clearCache(cacheKey);` | L1191 |
| `.\src\views\playlists\PlaylistSingle.vue` | `await setCache(cacheKey, details);` | L1197 |
| `.\src\views\playlists\PlaylistSingle.vue` | `cacheCleared.value = false;` | L1244 |
| `.\src\views\playlists\PlaylistSingle.vue` | `// Check unified track cache for playlist name first` | L1251 |
| `.\src\views\playlists\PlaylistSingle.vue` | `const cache = await loadUnifiedTrackCache(user.value.uid, userData.value?.lastFmUserName \|\| '');` | L1254 |
| `.\src\views\playlists\PlaylistSingle.vue` | `const cachedPlaylist = cache?.playlists[id.value];` | L1255 |
| `.\src\views\playlists\PlaylistSingle.vue` | `if (cachedPlaylist?.playlistName) \{` | L1256 |
| `.\src\views\playlists\PlaylistSingle.vue` | `playlistName.value = cachedPlaylist.playlistName;` | L1257 |
| `.\src\views\playlists\PlaylistSingle.vue` | `logCache('Playlist name loaded from unified cache:', playlistName.value);` | L1258 |
| `.\src\views\playlists\PlaylistSingle.vue` | `logCache('Error loading playlist name from cache:', error);` | L1261 |
| `.\src\views\playlists\PlaylistSingle.vue` | `// Only fetch from API if not found in cache` | L1265 |
| `.\src\views\playlists\PlaylistSingle.vue` | `logPlaylist('Playlist name not in cache, fetching playlist details from Spotify');` | L1267 |
| `.\src\views\playlists\PlaylistSingle.vue` | `logPlaylist('Playlist name loaded from cache, skipping API call');` | L1273 |
| `.\src\views\playlists\PlaylistSingle.vue` | `// Always try to get track count from playlist_summaries_ cache` | L1277 |
| `.\src\views\playlists\PlaylistSingle.vue` | `const playlistViewCacheKey = `playlist_summaries_$\{user.value.uid\}`;` | L1280 |
| `.\src\views\playlists\PlaylistSingle.vue` | `const playlistSummariesCache = await getCache(playlistViewCacheKey);` | L1281 |
| `.\src\views\playlists\PlaylistSingle.vue` | `if (playlistSummariesCache) \{` | L1283 |
| `.\src\views\playlists\PlaylistSingle.vue` | `for (const group of Object.keys(playlistSummariesCache)) \{` | L1285 |
| `.\src\views\playlists\PlaylistSingle.vue` | `const groupPlaylists = playlistSummariesCache[group] \|\| [];` | L1286 |
| `.\src\views\playlists\PlaylistSingle.vue` | `const cachedPlaylist = groupPlaylists.find(p => p.id === id.value);` | L1287 |
| `.\src\views\playlists\PlaylistSingle.vue` | `if (cachedPlaylist?.tracks?.total !== undefined) \{` | L1289 |
| `.\src\views\playlists\PlaylistSingle.vue` | `totalTracks.value = cachedPlaylist.tracks.total;` | L1290 |
| `.\src\views\playlists\PlaylistSingle.vue` | `logPlaylist('Track count loaded from playlist_summaries cache:', totalTracks.value);` | L1291 |
| `.\src\views\playlists\PlaylistSingle.vue` | `logPlaylist('Error loading track count from playlist_summaries cache:', error);` | L1297 |
| `.\src\views\playlists\PlaylistSingle.vue` | `logPlaylist('Track count not in cache, fetching from Spotify API');` | L1304 |
| `.\src\views\playlists\PlaylistSingle.vue` | `error.value = "Browser storage is full. Please go to Account > Cache Management to clear some cache data, then try again.";` | L1321 |
| `.\src\views\playlists\PlaylistSingle.vue` | `// Use the existing handler which will update unified cache and recalculate percentages` | L1355 |
| `.\src\views\playlists\PlaylistSingle.vue` | `// If album not found but we have track ID, update unified cache directly` | L1358 |
| `.\src\views\playlists\PlaylistSingle.vue` | `// Use the existing handler which will update unified cache and recalculate percentages` | L1377 |
| `.\src\views\playlists\PlaylistSingle.vue` | `// If album not found but we have track ID, update unified cache directly` | L1380 |
| `.\src\views\playlists\PlaylistSingle.vue` | `enableDebug('app:playlist,app:cache');` | L1387 |
| `.\src\views\playlists\PlaylistSingle.vue` | `logPlaylist('PlaylistSingle mounted - logging enabled for playlist and cache');` | L1388 |
| `.\src\views\playlists\PlaylistSingle.vue` | `// Unified cache is automatically initialized by useUnifiedTrackCache composable` | L1403 |
| `.\src\views\playlists\PlaylistSingle.vue` | `// Clear cache and reload the playlist to show the new album` | L1458 |
| `.\src\views\playlists\PlaylistSingle.vue` | `await handleClearCache();` | L1459 |
| `.\src\views\playlists\PlaylistSingle.vue` | `// Also clear the PlaylistView cache to update track counts` | L1464 |
| `.\src\views\playlists\PlaylistSingle.vue` | `const playlistViewCacheKey = `playlist_summaries_$\{user.value.uid\}`;` | L1466 |
| `.\src\views\playlists\PlaylistSingle.vue` | `await clearCache(playlistViewCacheKey);` | L1467 |
| `.\src\views\playlists\PlaylistSingle.vue` | `// Clear cache and reload the playlist to reflect the removal` | L1493 |
| `.\src\views\playlists\PlaylistSingle.vue` | `await handleClearCache();` | L1494 |
| `.\src\views\playlists\PlaylistSingle.vue` | `// Also clear the PlaylistView cache to update track counts` | L1499 |
| `.\src\views\playlists\PlaylistSingle.vue` | `const playlistViewCacheKey = `playlist_summaries_$\{user.value.uid\}`;` | L1501 |
| `.\src\views\playlists\PlaylistSingle.vue` | `await clearCache(playlistViewCacheKey);` | L1502 |
| `.\src\views\playlists\PlaylistSingle.vue` | `// 4. Update unified track cache - surgically move album from source to target playlist` | L1568 |
| `.\src\views\playlists\PlaylistSingle.vue` | `// Ensure cache is loaded` | L1571 |
| `.\src\views\playlists\PlaylistSingle.vue` | `await loadUnifiedTrackCache(user.value.uid, userData.value?.lastFmUserName \|\| '');` | L1572 |
| `.\src\views\playlists\PlaylistSingle.vue` | `// Move album in unified cache` | L1574 |
| `.\src\views\playlists\PlaylistSingle.vue` | `logPlaylist(`Moved album $\{album.id\} in unified track cache from $\{id.value\} to $\{targetSpotifyPlaylistId\}`);` | L1583 |
| `.\src\views\playlists\PlaylistSingle.vue` | `logPlaylist(`Error moving album in unified track cache:`, error);` | L1585 |
| `.\src\views\playlists\PlaylistSingle.vue` | `// Don't fail the whole operation if cache update fails` | L1586 |
| `.\src\views\playlists\PlaylistSingle.vue` | `// Clear cache and reload the current playlist to reflect the changes` | L1593 |
| `.\src\views\playlists\PlaylistSingle.vue` | `await handleClearCache();` | L1594 |
| `.\src\views\playlists\PlaylistSingle.vue` | `// Refresh only the affected playlists in PlaylistView cache (source and target)` | L1599 |
| `.\src\views\playlists\PlaylistSingle.vue` | `const playlistViewCacheKey = `playlist_summaries_$\{user.value.uid\}`;` | L1601 |
| `.\src\views\playlists\PlaylistSingle.vue` | `// Get current cache state so we can properly update it` | L1603 |
| `.\src\views\playlists\PlaylistSingle.vue` | `const currentCacheState = await getCache(playlistViewCacheKey) \|\| \{};` | L1604 |
| `.\src\views\playlists\PlaylistSingle.vue` | `logPlaylist(`Cache state retrieved: $\{Object.keys(currentCacheState).length\} groups, playlists:`,` | L1605 |
| `.\src\views\playlists\PlaylistSingle.vue` | `Object.keys(currentCacheState).map(g => `$\{g\}: $\{currentCacheState[g]?.length \|\| 0\}`).join(', '));` | L1606 |
| `.\src\views\playlists\PlaylistSingle.vue` | `// Refresh both playlists from Spotify and update cache` | L1608 |
| `.\src\views\playlists\PlaylistSingle.vue` | `currentCacheState, // Pass cache state so it can be properly updated` | L1611 |
| `.\src\views\playlists\PlaylistSingle.vue` | `playlistViewCacheKey` | L1612 |
| `.\src\views\playlists\PlaylistSingle.vue` | `// Explicitly save the updated state to ensure cache is persisted` | L1615 |
| `.\src\views\playlists\PlaylistSingle.vue` | `logPlaylist(`Saving updated state to cache with $\{Object.keys(updatedState).length\} groups`);` | L1617 |
| `.\src\views\playlists\PlaylistSingle.vue` | `await setCache(playlistViewCacheKey, updatedState);` | L1618 |
| `.\src\views\playlists\PlaylistSingle.vue` | `logPlaylist(`Cache saved successfully`);` | L1619 |
| `.\src\views\playlists\PlaylistSingle.vue` | `logPlaylist(`WARNING: Updated state is empty, not saving to cache`);` | L1621 |
| `.\src\views\playlists\PlaylistSingle.vue` | `// Update target playlist's album cache` | L1629 |
| `.\src\views\playlists\PlaylistSingle.vue` | `const targetAlbumCacheKey = `playlist_$\{targetSpotifyPlaylistId\}_albumsWithDates`;` | L1630 |
| `.\src\views\playlists\PlaylistSingle.vue` | `const targetAlbumsCache = await getCache(targetAlbumCacheKey);` | L1631 |
| `.\src\views\playlists\PlaylistSingle.vue` | `if (targetAlbumsCache && Array.isArray(targetAlbumsCache)) \{` | L1633 |
| `.\src\views\playlists\PlaylistSingle.vue` | `// Check if album already exists in cache` | L1634 |
| `.\src\views\playlists\PlaylistSingle.vue` | `const albumExists = targetAlbumsCache.some(a => a.id === album.id);` | L1635 |
| `.\src\views\playlists\PlaylistSingle.vue` | `targetAlbumsCache.push(\{` | L1638 |
| `.\src\views\playlists\PlaylistSingle.vue` | `await setCache(targetAlbumCacheKey, targetAlbumsCache);` | L1642 |
| `.\src\views\playlists\PlaylistSingle.vue` | `logPlaylist(`Added album $\{album.id\} to target playlist cache`);` | L1643 |
| `.\src\views\playlists\PlaylistSingle.vue` | `// Cache doesn't exist, fetch fresh data` | L1646 |
| `.\src\views\playlists\PlaylistSingle.vue` | `await setCache(targetAlbumCacheKey, freshAlbums);` | L1648 |
| `.\src\views\playlists\PlaylistSingle.vue` | `logPlaylist(`Fetched and cached fresh album list for target playlist`);` | L1649 |
| `.\src\views\playlists\PlaylistSingle.vue` | `// Clear page caches for target playlist (album list changed)` | L1652 |
| `.\src\views\playlists\PlaylistSingle.vue` | `await clearCache(`playlist_$\{targetSpotifyPlaylistId\}_page_$\{page\}_$\{mode\}_$\{dir\}`);` | L1658 |
| `.\src\views\playlists\PlaylistSingle.vue` | `handleClearCache();` | L1765 |
| `.\src\views\playlists\PlaylistSingle.vue` | `<BaseButton variant="secondary" @click.prevent="handleClearCache" class="w-fit">` | L2181 |
| `.\src\views\playlists\PlaylistSingle.vue` | `<p v-if="cacheCleared" class="mb-4 text-green-500">` | L2336 |
| `.\src\views\playlists\PlaylistSingle.vue` | `Cache cleared! Reloading playlist...` | L2337 |
| `.\src\utils\unifiedTrackCache.js` | `import \{ getCache, setCache, clearCache \} from './cache';` | L1 |
| `.\src\utils\unifiedTrackCache.js` | `import \{ logCache \} from './logger';` | L2 |
| `.\src\utils\unifiedTrackCache.js` | `// Cache schema version (increment for migrations)` | L5 |
| `.\src\utils\unifiedTrackCache.js` | `// Cache key prefix` | L8 |
| `.\src\utils\unifiedTrackCache.js` | `// Debounce delay for cache saves` | L18 |
| `.\src\utils\unifiedTrackCache.js` | `// In-memory cache storage (per user)` | L21 |
| `.\src\utils\unifiedTrackCache.js` | `const inMemoryCache = new Map();` | L22 |
| `.\src\utils\unifiedTrackCache.js` | `* Create empty cache structure` | L42 |
| `.\src\utils\unifiedTrackCache.js` | `function createEmptyCache(userId, lastFmUserName) \{` | L44 |
| `.\src\utils\unifiedTrackCache.js` | `* Validate cache structure` | L69 |
| `.\src\utils\unifiedTrackCache.js` | `function validateCache(cache) \{` | L71 |
| `.\src\utils\unifiedTrackCache.js` | `if (!cache \|\| typeof cache !== 'object') return false;` | L72 |
| `.\src\utils\unifiedTrackCache.js` | `if (!cache.metadata \|\| !cache.tracks \|\| !cache.albums \|\| !cache.playlists \|\| !cache.indexes) return false;` | L73 |
| `.\src\utils\unifiedTrackCache.js` | `if (cache.metadata.version !== CACHE_VERSION) return false;` | L74 |
| `.\src\utils\unifiedTrackCache.js` | `* Initialize or load the unified track cache` | L79 |
| `.\src\utils\unifiedTrackCache.js` | `export async function loadUnifiedTrackCache(userId, lastFmUserName) \{` | L81 |
| `.\src\utils\unifiedTrackCache.js` | `// Check in-memory cache first` | L86 |
| `.\src\utils\unifiedTrackCache.js` | `if (inMemoryCache.has(userId)) \{` | L87 |
| `.\src\utils\unifiedTrackCache.js` | `const cache = inMemoryCache.get(userId);` | L88 |
| `.\src\utils\unifiedTrackCache.js` | `if (lastFmUserName && cache.metadata.lastFmUserName !== lastFmUserName) \{` | L90 |
| `.\src\utils\unifiedTrackCache.js` | `cache.metadata.lastFmUserName = lastFmUserName;` | L91 |
| `.\src\utils\unifiedTrackCache.js` | `await saveUnifiedTrackCache(userId, true);` | L92 |
| `.\src\utils\unifiedTrackCache.js` | `return cache;` | L94 |
| `.\src\utils\unifiedTrackCache.js` | `const cacheKey = `$\{CACHE_KEY_PREFIX\}$\{userId\}`;` | L97 |
| `.\src\utils\unifiedTrackCache.js` | `const cachedData = getCache(cacheKey);` | L100 |
| `.\src\utils\unifiedTrackCache.js` | `if (cachedData && validateCache(cachedData)) \{` | L102 |
| `.\src\utils\unifiedTrackCache.js` | `if (lastFmUserName && cachedData.metadata.lastFmUserName !== lastFmUserName) \{` | L104 |
| `.\src\utils\unifiedTrackCache.js` | `cachedData.metadata.lastFmUserName = lastFmUserName;` | L105 |
| `.\src\utils\unifiedTrackCache.js` | `inMemoryCache.set(userId, cachedData);` | L109 |
| `.\src\utils\unifiedTrackCache.js` | `logCache(`Loaded unified track cache for user $\{userId\}: $\{cachedData.metadata.totalTracks\} tracks`);` | L110 |
| `.\src\utils\unifiedTrackCache.js` | `return cachedData;` | L111 |
| `.\src\utils\unifiedTrackCache.js` | `// Create new cache` | L113 |
| `.\src\utils\unifiedTrackCache.js` | `const newCache = createEmptyCache(userId, lastFmUserName);` | L114 |
| `.\src\utils\unifiedTrackCache.js` | `inMemoryCache.set(userId, newCache);` | L115 |
| `.\src\utils\unifiedTrackCache.js` | `await saveUnifiedTrackCache(userId, true);` | L116 |
| `.\src\utils\unifiedTrackCache.js` | `logCache(`Created new unified track cache for user $\{userId\}`);` | L117 |
| `.\src\utils\unifiedTrackCache.js` | `return newCache;` | L118 |
| `.\src\utils\unifiedTrackCache.js` | `logCache('Error loading unified track cache:', error);` | L121 |
| `.\src\utils\unifiedTrackCache.js` | `// Create new cache on error` | L122 |
| `.\src\utils\unifiedTrackCache.js` | `const newCache = createEmptyCache(userId, lastFmUserName);` | L123 |
| `.\src\utils\unifiedTrackCache.js` | `inMemoryCache.set(userId, newCache);` | L124 |
| `.\src\utils\unifiedTrackCache.js` | `return newCache;` | L125 |
| `.\src\utils\unifiedTrackCache.js` | `* Save unified track cache to localStorage (debounced)` | L130 |
| `.\src\utils\unifiedTrackCache.js` | `export async function saveUnifiedTrackCache(userId, immediate = false) \{` | L132 |
| `.\src\utils\unifiedTrackCache.js` | `const cache = inMemoryCache.get(userId);` | L137 |
| `.\src\utils\unifiedTrackCache.js` | `if (!cache) \{` | L138 |
| `.\src\utils\unifiedTrackCache.js` | `logCache(`No in-memory cache found for user $\{userId\}, skipping save`);` | L139 |
| `.\src\utils\unifiedTrackCache.js` | `const cacheKey = `$\{CACHE_KEY_PREFIX\}$\{userId\}`;` | L143 |
| `.\src\utils\unifiedTrackCache.js` | `cache.metadata.lastUpdated = Date.now();` | L148 |
| `.\src\utils\unifiedTrackCache.js` | `cache.metadata.totalTracks = Object.keys(cache.tracks).length;` | L149 |
| `.\src\utils\unifiedTrackCache.js` | `cache.metadata.totalAlbums = Object.keys(cache.albums).length;` | L150 |
| `.\src\utils\unifiedTrackCache.js` | `cache.metadata.totalPlaylists = Object.keys(cache.playlists).length;` | L151 |
| `.\src\utils\unifiedTrackCache.js` | `setCache(cacheKey, cache);` | L153 |
| `.\src\utils\unifiedTrackCache.js` | `logCache(`Saved unified track cache for user $\{userId\}`);` | L154 |
| `.\src\utils\unifiedTrackCache.js` | `logCache('Storage quota exceeded, attempting LRU eviction...');` | L157 |
| `.\src\utils\unifiedTrackCache.js` | `setCache(cacheKey, cache);` | L161 |
| `.\src\utils\unifiedTrackCache.js` | `logCache('Successfully saved cache after eviction');` | L162 |
| `.\src\utils\unifiedTrackCache.js` | `logCache('Failed to save cache even after eviction:', retryError);` | L164 |
| `.\src\utils\unifiedTrackCache.js` | `// Continue with in-memory cache` | L165 |
| `.\src\utils\unifiedTrackCache.js` | `logCache('Error saving unified track cache:', error);` | L168 |
| `.\src\utils\unifiedTrackCache.js` | `* Get in-memory cache (for internal use)` | L196 |
| `.\src\utils\unifiedTrackCache.js` | `function getInMemoryCache(userId) \{` | L198 |
| `.\src\utils\unifiedTrackCache.js` | `const cache = inMemoryCache.get(userId);` | L199 |
| `.\src\utils\unifiedTrackCache.js` | `if (!cache) \{` | L200 |
| `.\src\utils\unifiedTrackCache.js` | `throw new Error(`Cache not loaded for user $\{userId\}. Call loadUnifiedTrackCache first.`);` | L201 |
| `.\src\utils\unifiedTrackCache.js` | `return cache;` | L203 |
| `.\src\utils\unifiedTrackCache.js` | `function updateTrackAccess(cache, trackId) \{` | L209 |
| `.\src\utils\unifiedTrackCache.js` | `if (cache.tracks[trackId]) \{` | L210 |
| `.\src\utils\unifiedTrackCache.js` | `cache.tracks[trackId].lastAccessed = Date.now();` | L211 |
| `.\src\utils\unifiedTrackCache.js` | `function addTrackToIndexes(cache, track) \{` | L218 |
| `.\src\utils\unifiedTrackCache.js` | `if (!cache.indexes.byTrackName[normalizedTrackName]) \{` | L223 |
| `.\src\utils\unifiedTrackCache.js` | `cache.indexes.byTrackName[normalizedTrackName] = \{};` | L224 |
| `.\src\utils\unifiedTrackCache.js` | `if (!cache.indexes.byArtist[artist.id]) \{` | L230 |
| `.\src\utils\unifiedTrackCache.js` | `cache.indexes.byArtist[artist.id] = [];` | L231 |
| `.\src\utils\unifiedTrackCache.js` | `if (!cache.indexes.byArtist[artist.id].includes(trackId)) \{` | L233 |
| `.\src\utils\unifiedTrackCache.js` | `cache.indexes.byArtist[artist.id].push(trackId);` | L234 |
| `.\src\utils\unifiedTrackCache.js` | `if (!cache.indexes.byTrackName[normalizedTrackName][normalizedArtistName]) \{` | L239 |
| `.\src\utils\unifiedTrackCache.js` | `cache.indexes.byTrackName[normalizedTrackName][normalizedArtistName] = [];` | L240 |
| `.\src\utils\unifiedTrackCache.js` | `if (!cache.indexes.byTrackName[normalizedTrackName][normalizedArtistName].includes(trackId)) \{` | L242 |
| `.\src\utils\unifiedTrackCache.js` | `cache.indexes.byTrackName[normalizedTrackName][normalizedArtistName].push(trackId);` | L243 |
| `.\src\utils\unifiedTrackCache.js` | `if (!cache.indexes.albumsByArtist[artist.id]) \{` | L253 |
| `.\src\utils\unifiedTrackCache.js` | `cache.indexes.albumsByArtist[artist.id] = [];` | L254 |
| `.\src\utils\unifiedTrackCache.js` | `if (!cache.indexes.albumsByArtist[artist.id].includes(albumId)) \{` | L256 |
| `.\src\utils\unifiedTrackCache.js` | `cache.indexes.albumsByArtist[artist.id].push(albumId);` | L257 |
| `.\src\utils\unifiedTrackCache.js` | `if (track.loved && !cache.indexes.lovedTrackIds.includes(trackId)) \{` | L264 |
| `.\src\utils\unifiedTrackCache.js` | `cache.indexes.lovedTrackIds.push(trackId);` | L265 |
| `.\src\utils\unifiedTrackCache.js` | `function removeTrackFromIndexes(cache, trackId, track) \{` | L272 |
| `.\src\utils\unifiedTrackCache.js` | `const lovedIndex = cache.indexes.lovedTrackIds.indexOf(trackId);` | L274 |
| `.\src\utils\unifiedTrackCache.js` | `cache.indexes.lovedTrackIds.splice(lovedIndex, 1);` | L276 |
| `.\src\utils\unifiedTrackCache.js` | `// Indexes will be rebuilt if needed or cleaned up during cache rebuild` | L280 |
| `.\src\utils\unifiedTrackCache.js` | `const cache = getInMemoryCache(userId);` | L287 |
| `.\src\utils\unifiedTrackCache.js` | `if (!cache.albums[albumId]) \{` | L289 |
| `.\src\utils\unifiedTrackCache.js` | `const trackIds = cache.albums[albumId].trackIds \|\| [];` | L293 |
| `.\src\utils\unifiedTrackCache.js` | `.map(trackId => cache.tracks[trackId])` | L295 |
| `.\src\utils\unifiedTrackCache.js` | `updateTrackAccess(cache, track.id);` | L299 |
| `.\src\utils\unifiedTrackCache.js` | `const isLoved = track.loved === true \|\| (track.loved === undefined && cache.indexes.lovedTrackIds.includes(track.id));` | L301 |
| `.\src\utils\unifiedTrackCache.js` | `const cache = getInMemoryCache(userId);` | L317 |
| `.\src\utils\unifiedTrackCache.js` | `if (!cache.playlists[playlistId] \|\| !cache.playlists[playlistId].albums[albumId]) \{` | L319 |
| `.\src\utils\unifiedTrackCache.js` | `const trackIds = cache.playlists[playlistId].albums[albumId].trackIds \|\| [];` | L323 |
| `.\src\utils\unifiedTrackCache.js` | `.map(trackId => cache.tracks[trackId])` | L325 |
| `.\src\utils\unifiedTrackCache.js` | `updateTrackAccess(cache, track.id);` | L328 |
| `.\src\utils\unifiedTrackCache.js` | `const isLoved = track.loved === true \|\| (track.loved === undefined && cache.indexes.lovedTrackIds.includes(track.id));` | L330 |
| `.\src\utils\unifiedTrackCache.js` | `const cache = getInMemoryCache(userId);` | L345 |
| `.\src\utils\unifiedTrackCache.js` | `if (!cache.playlists[playlistId]) \{` | L347 |
| `.\src\utils\unifiedTrackCache.js` | `Object.values(cache.playlists[playlistId].albums).forEach(albumData => \{` | L354 |
| `.\src\utils\unifiedTrackCache.js` | `.map(trackId => cache.tracks[trackId])` | L361 |
| `.\src\utils\unifiedTrackCache.js` | `updateTrackAccess(cache, track.id);` | L364 |
| `.\src\utils\unifiedTrackCache.js` | `const isLoved = track.loved === true \|\| (track.loved === undefined && cache.indexes.lovedTrackIds.includes(track.id));` | L366 |
| `.\src\utils\unifiedTrackCache.js` | `const cache = getInMemoryCache(userId);` | L381 |
| `.\src\utils\unifiedTrackCache.js` | `return cache.tracks[trackId]?.loved \|\| false;` | L382 |
| `.\src\utils\unifiedTrackCache.js` | `const cache = getInMemoryCache(userId);` | L389 |
| `.\src\utils\unifiedTrackCache.js` | `return cache.tracks[trackId]?.playcount \|\| 0;` | L390 |
| `.\src\utils\unifiedTrackCache.js` | `* Update track loved status (cache-first, syncs to Last.fm in background)` | L394 |
| `.\src\utils\unifiedTrackCache.js` | `const cache = getInMemoryCache(userId);` | L399 |
| `.\src\utils\unifiedTrackCache.js` | `if (!cache.tracks[trackId]) \{` | L401 |
| `.\src\utils\unifiedTrackCache.js` | `logCache(`Track $\{trackId\} not found in cache, cannot update loved status`);` | L402 |
| `.\src\utils\unifiedTrackCache.js` | `const track = cache.tracks[trackId];` | L406 |
| `.\src\utils\unifiedTrackCache.js` | `// Update cache immediately (optimistic update)` | L408 |
| `.\src\utils\unifiedTrackCache.js` | `updateTrackAccess(cache, trackId);` | L411 |
| `.\src\utils\unifiedTrackCache.js` | `if (loved && !cache.indexes.lovedTrackIds.includes(trackId)) \{` | L414 |
| `.\src\utils\unifiedTrackCache.js` | `cache.indexes.lovedTrackIds.push(trackId);` | L415 |
| `.\src\utils\unifiedTrackCache.js` | `const index = cache.indexes.lovedTrackIds.indexOf(trackId);` | L417 |
| `.\src\utils\unifiedTrackCache.js` | `cache.indexes.lovedTrackIds.splice(index, 1);` | L419 |
| `.\src\utils\unifiedTrackCache.js` | `// Save cache immediately (critical operation)` | L423 |
| `.\src\utils\unifiedTrackCache.js` | `await saveUnifiedTrackCache(userId, true);` | L424 |
| `.\src\utils\unifiedTrackCache.js` | `logCache('Background sync of loved status failed:', error);` | L430 |
| `.\src\utils\unifiedTrackCache.js` | `const cache = getInMemoryCache(userId);` | L449 |
| `.\src\utils\unifiedTrackCache.js` | `cache.metadata.unsyncedLovedTracks = cache.metadata.unsyncedLovedTracks.filter(` | L450 |
| `.\src\utils\unifiedTrackCache.js` | `logCache(`Successfully synced loved status for track $\{trackId\} to Last.fm`);` | L454 |
| `.\src\utils\unifiedTrackCache.js` | `logCache(`Failed to sync loved status for track $\{trackId\}:`, error);` | L456 |
| `.\src\utils\unifiedTrackCache.js` | `const cache = getInMemoryCache(userId);` | L459 |
| `.\src\utils\unifiedTrackCache.js` | `const existingIndex = cache.metadata.unsyncedLovedTracks.findIndex(item => item.trackId === trackId);` | L460 |
| `.\src\utils\unifiedTrackCache.js` | `cache.metadata.unsyncedLovedTracks[existingIndex].retryCount++;` | L463 |
| `.\src\utils\unifiedTrackCache.js` | `cache.metadata.unsyncedLovedTracks.push(\{` | L465 |
| `.\src\utils\unifiedTrackCache.js` | `await saveUnifiedTrackCache(userId);` | L473 |
| `.\src\utils\unifiedTrackCache.js` | `* Update track playcount (cache-first)` | L479 |
| `.\src\utils\unifiedTrackCache.js` | `const cache = getInMemoryCache(userId);` | L482 |
| `.\src\utils\unifiedTrackCache.js` | `if (!cache.tracks[trackId]) \{` | L484 |
| `.\src\utils\unifiedTrackCache.js` | `logCache(`Track $\{trackId\} not found in cache, cannot update playcount`);` | L485 |
| `.\src\utils\unifiedTrackCache.js` | `cache.tracks[trackId].playcount = playcount;` | L489 |
| `.\src\utils\unifiedTrackCache.js` | `cache.tracks[trackId].lastPlaycountUpdate = Date.now();` | L490 |
| `.\src\utils\unifiedTrackCache.js` | `updateTrackAccess(cache, trackId);` | L491 |
| `.\src\utils\unifiedTrackCache.js` | `await saveUnifiedTrackCache(userId);` | L493 |
| `.\src\utils\unifiedTrackCache.js` | `* Add tracks from an album to cache` | L497 |
| `.\src\utils\unifiedTrackCache.js` | `const cache = getInMemoryCache(userId);` | L500 |
| `.\src\utils\unifiedTrackCache.js` | `if (!cache.albums[albumId]) \{` | L504 |
| `.\src\utils\unifiedTrackCache.js` | `cache.albums[albumId] = \{` | L505 |
| `.\src\utils\unifiedTrackCache.js` | `const album = cache.albums[albumId];` | L513 |
| `.\src\utils\unifiedTrackCache.js` | `// Add or update track in cache` | L521 |
| `.\src\utils\unifiedTrackCache.js` | `if (!cache.tracks[trackId]) \{` | L522 |
| `.\src\utils\unifiedTrackCache.js` | `cache.tracks[trackId] = \{` | L523 |
| `.\src\utils\unifiedTrackCache.js` | `if (!cache.tracks[trackId].albumIds.includes(albumId)) \{` | L543 |
| `.\src\utils\unifiedTrackCache.js` | `cache.tracks[trackId].albumIds.push(albumId);` | L544 |
| `.\src\utils\unifiedTrackCache.js` | `addTrackToIndexes(cache, cache.tracks[trackId]);` | L553 |
| `.\src\utils\unifiedTrackCache.js` | `await saveUnifiedTrackCache(userId);` | L556 |
| `.\src\utils\unifiedTrackCache.js` | `* Add tracks from a playlist to cache` | L560 |
| `.\src\utils\unifiedTrackCache.js` | `const cache = getInMemoryCache(userId);` | L563 |
| `.\src\utils\unifiedTrackCache.js` | `if (!cache.playlists[playlistId]) \{` | L567 |
| `.\src\utils\unifiedTrackCache.js` | `cache.playlists[playlistId] = \{` | L568 |
| `.\src\utils\unifiedTrackCache.js` | `const playlist = cache.playlists[playlistId];` | L575 |
| `.\src\utils\unifiedTrackCache.js` | `// Add track to cache if not exists` | L602 |
| `.\src\utils\unifiedTrackCache.js` | `if (!cache.tracks[trackId]) \{` | L603 |
| `.\src\utils\unifiedTrackCache.js` | `cache.tracks[trackId] = \{` | L604 |
| `.\src\utils\unifiedTrackCache.js` | `if (!cache.tracks[trackId].albumIds.includes(albumId)) \{` | L624 |
| `.\src\utils\unifiedTrackCache.js` | `cache.tracks[trackId].albumIds.push(albumId);` | L625 |
| `.\src\utils\unifiedTrackCache.js` | `if (!cache.tracks[trackId].playlistIds.includes(playlistId)) \{` | L627 |
| `.\src\utils\unifiedTrackCache.js` | `cache.tracks[trackId].playlistIds.push(playlistId);` | L628 |
| `.\src\utils\unifiedTrackCache.js` | `addTrackToIndexes(cache, cache.tracks[trackId]);` | L632 |
| `.\src\utils\unifiedTrackCache.js` | `// Update album metadata in cache.albums` | L644 |
| `.\src\utils\unifiedTrackCache.js` | `if (!cache.albums[albumId]) \{` | L646 |
| `.\src\utils\unifiedTrackCache.js` | `cache.albums[albumId] = \{` | L647 |
| `.\src\utils\unifiedTrackCache.js` | `await saveUnifiedTrackCache(userId);` | L656 |
| `.\src\utils\unifiedTrackCache.js` | `* Move an album from one playlist to another in the unified cache` | L660 |
| `.\src\utils\unifiedTrackCache.js` | `const cache = getInMemoryCache(userId);` | L668 |


</details>
</tool-use>

---

<tool-use data-tool-type="read" data-tool-name="read_file">
<details><summary>Tool use: **read_file** • Read file: src/utils/cache.js</summary>

</details>
</tool-use>

---

<tool-use data-tool-type="read" data-tool-name="read_file">
<details><summary>Tool use: **read_file** • Read file: src/utils/unifiedTrackCache.js</summary>

</details>
</tool-use>

---

<tool-use data-tool-type="read" data-tool-name="read_file">
<details><summary>Tool use: **read_file** • Read file: src/composables/useCache.js</summary>

</details>
</tool-use>

---



---


Searching for additional cache usage patterns:


---

<tool-use data-tool-type="search" data-tool-name="grep">
<details>
<summary>Tool use: **grep** • Grep for "albumTracks_|playlist_tracks_|lovedTracks_|albumRootData_|playlist_summaries_|albumDbData_" • 10 matches</summary>

Output mode: files_with_matches


| File |
|------|
| `.\src\views\playlists\PlaylistSingle.vue` |
| `.\src\components\SpotifyPlayerBar.vue` |
| `.\tasks\unified-track-cache-spec.md` |
| `.\src\composables\useAlbumsData.js` |
| `.\src\views\music\ArtistView.vue` |
| `.\src\views\music\SearchView.vue` |
| `.\src\utils\cache.js` |
| `.\src\views\playlists\PlaylistView.vue` |
| `.\src\views\playlists\AddPlaylistView.vue` |
| `.\src\utils\lastFmUtils.js` |


</details>
</tool-use>

---

<tool-use data-tool-type="read" data-tool-name="read_file">
<details><summary>Tool use: **read_file** • Read file: tasks/unified-track-cache-spec.md</summary>

</details>
</tool-use>

---

<tool-use data-tool-type="search" data-tool-name="codebase_search">
<details>
                <summary>Tool use: **codebase_search** • Searched codebase "What are all the different cache keys being used throughout the application?" • **15** results</summary>
            
| File | Lines |
|------|-------|
| `tasks/unified-track-cache-spec.md` | L54 |
| `src/utils/unifiedTrackCache.js` | L38 |
| `tasks/unified-track-cache-spec.md` | L48-91 |
| `src/utils/unifiedTrackCache.js` | L70-192 |
| `src/composables/useCache.js` | L59 |
| `src/composables/useUnifiedTrackCache.js` | L392 |
| `tasks/unified-track-cache-spec.md` | L490-536 |
| `src/utils/cache.js` | L65 |
| `src/views/playlists/PlaylistSingle.vue` | L1007-1073 |
| `tasks/unified-track-cache-spec.md` | L339-395 |
| `src/utils/unifiedTrackCache.js` | L80-203 |
| `tasks/unified-track-cache-spec.md` | L533-584 |
| `src/composables/useUnifiedTrackCache.js` | L30-392 |
| `src/components/common/CacheManager.vue` | L105-177 |
| `src/utils/cache.js` | L5-77 |

</details>
</tool-use>

---



---


Checking specific cache keys in use:


---

<tool-use data-tool-type="search" data-tool-name="grep">
<details>
<summary>Tool use: **grep** • Grep for "albumRootData_|playlist_summaries_|albumDbData_|playlist_.*_page_|playlist_.*_albumsWithDates" in "src/views/playlists" • 16 matches</summary>

Output mode: content


| File | Content | Line |
|------|------|------|
| `src/views/playlists\PlaylistSingle.vue` | `const albumIdListCacheKey = computed(() => `playlist_$\{id.value\}_albumsWithDates`);` | L744 |
| `src/views/playlists\PlaylistSingle.vue` | `const pageCacheKey = (page) => `playlist_$\{id.value\}_page_$\{page\}_$\{sortMode.value\}_$\{sortDirection.value\}`;` | L745 |
| `src/views/playlists\PlaylistSingle.vue` | `const cacheKey = `albumRootData_$\{albumId\}`;` | L786 |
| `src/views/playlists\PlaylistSingle.vue` | `await clearCache(`playlist_$\{id.value\}_page_$\{page\}_$\{mode\}_$\{dir\}`);` | L1024 |
| `src/views/playlists\PlaylistSingle.vue` | `await clearCache(`albumDbData_$\{album.id\}_$\{user.value.uid\}`);` | L1037 |
| `src/views/playlists\PlaylistSingle.vue` | `await clearCache(`albumRootData_$\{album.id\}`);` | L1039 |
| `src/views/playlists\PlaylistSingle.vue` | `const cacheKey = `albumRootData_$\{albumId\}`;` | L1190 |
| `src/views/playlists\PlaylistSingle.vue` | `// Always try to get track count from playlist_summaries_ cache` | L1277 |
| `src/views/playlists\PlaylistSingle.vue` | `const playlistViewCacheKey = `playlist_summaries_$\{user.value.uid\}`;` | L1280 |
| `src/views/playlists\PlaylistSingle.vue` | `const playlistViewCacheKey = `playlist_summaries_$\{user.value.uid\}`;` | L1466 |
| `src/views/playlists\PlaylistSingle.vue` | `const playlistViewCacheKey = `playlist_summaries_$\{user.value.uid\}`;` | L1501 |
| `src/views/playlists\PlaylistSingle.vue` | `const playlistViewCacheKey = `playlist_summaries_$\{user.value.uid\}`;` | L1601 |
| `src/views/playlists\PlaylistSingle.vue` | `const targetAlbumCacheKey = `playlist_$\{targetSpotifyPlaylistId\}_albumsWithDates`;` | L1630 |
| `src/views/playlists\PlaylistSingle.vue` | `await clearCache(`playlist_$\{targetSpotifyPlaylistId\}_page_$\{page\}_$\{mode\}_$\{dir\}`);` | L1658 |
| `src/views/playlists\PlaylistView.vue` | `const cacheKey = computed(() => user.value ? `playlist_summaries_$\{user.value.uid\}` : null);` | L35 |
| `src/views/playlists\AddPlaylistView.vue` | `const playlistViewCacheKey = `playlist_summaries_$\{user.value.uid\}`;` | L383 |


</details>
</tool-use>

---

<tool-use data-tool-type="read" data-tool-name="read_file">
<details><summary>Tool use: **read_file** • Read file: src/composables/usePlaylistData.js</summary>

</details>
</tool-use>

---



---


## Current Cache Situation

You have multiple overlapping caches:

**Track-related:**
- `user_tracks_${userId}` (unified track cache)
- `albumTracks_${albumId}` (legacy)
- `playlist_tracks_${playlistId}` (legacy)
- `lovedTracks_${lastFmUserName}` (legacy)

**Album-related:**
- `albumRootData_${albumId}` (Spotify album details)
- `albumDbData_${albumId}_${userId}` (Firestore album data)
- Unified cache also stores album metadata

**Playlist-related:**
- `playlist_summaries_${userId}` (playlist list view)
- `playlist_${playlistId}_albumsWithDates` (album list per playlist)
- `playlist_${playlistId}_page_${page}_${sortMode}_${sortDirection}` (paginated/sorted views)
- Unified cache also stores playlist structure

## Single vs Multiple Caches: Best Practice

Use a hybrid approach: one primary cache per domain, with separate caches for different concerns.

### Recommended Architecture

1. Unified track cache (keep and expand)
   - All track data, loved status, playcounts
   - Single source of truth for tracks

2. Separate cache for playlist summaries
   - Purpose: list view metadata (name, track count, etc.)
   - Reason: Different access pattern, different refresh needs

3. Separate cache for paginated/sorted views
   - Purpose: UI state (sorting, pagination)
   - Reason: Ephemeral, view-specific, not core data

4. Album metadata cache (consolidate)
   - Merge `albumRootData_` and `albumDbData_` into one
   - Or move into unified cache if it fits the access pattern

### Why not a single cache?

- Different refresh needs (tracks vs summaries vs pagination)
- Different eviction policies (tracks persist, pagination can expire)
- Different access patterns (random track lookup vs sequential list)
- Performance: smaller, focused caches are faster to load/save
- Separation of concerns: UI state vs core data

### Action Plan

1. Keep unified track cache as the single source for tracks
2. Keep `playlist_summaries_` separate (different purpose)
3. Consolidate album caches into one `album_${albumId}_${userId}`
4. Remove legacy track caches (`albumTracks_`, `playlist_tracks_`, `lovedTracks_`)
5. Keep pagination caches separate (they’re view state, not data)

Should I create a migration plan to consolidate these caches?

---

