<!-- Generated by SpecStory, Markdown v2.1.0 -->

<!-- cursor Session bd20b50e-14fc-4d30-8d56-663f4eadade8 (2025-11-02 13:58Z) -->

# Investigate missing playlists issue (2025-11-02 13:58Z)

_**User (2025-11-14 10:38Z)**_

ok, so I added a new playlist, but for some reason all my playlists in the playlists view have disappeared. we need to investigate. prob some data issue.

---

_**Agent (model default, mode Ask)**_



---


Investigating why playlists disappeared. Checking the playlists view and related data fetching logic.


---

<tool-use data-tool-type="read" data-tool-name="read_file">
<details><summary>Tool use: **read_file** • Read file: src/views/playlists/PlaylistView.vue</summary>

</details>
</tool-use>

---

<tool-use data-tool-type="read" data-tool-name="read_file">
<details><summary>Tool use: **read_file** • Read file: src/composables/usePlaylistData.js</summary>

</details>
</tool-use>

---

<tool-use data-tool-type="read" data-tool-name="read_file">
<details><summary>Tool use: **read_file** • Read file: src/views/playlists/AddPlaylistView.vue</summary>

</details>
</tool-use>

---



---


Checking how the query is structured and whether there are any data inconsistencies.


---

<tool-use data-tool-type="search" data-tool-name="grep">
<details>
<summary>Tool use: **grep** • Grep for "orderBy\('priority'\)" in "src/composables" • 1 match</summary>

Output mode: content


| File | Content | Line |
|------|------|------|
| `src/composables\usePlaylistData.js` | `orderBy('priority')` | L104 |


</details>
</tool-use>

---

<tool-use data-tool-type="search" data-tool-name="codebase_search">
<details>
                <summary>Tool use: **codebase_search** • Searched codebase "How are playlists queried from Firestore? What fields are required for the query to work?" • **14** results</summary>
            
| File | Lines |
|------|-------|
| `src/composables/usePlaylistData.js` | L50-158 |
| `src/composables/usePlaylistData.js` | L38 |
| `src/views/playlists/EditPlaylistView.vue` | L122-168 |
| `src/views/playlists/PlaylistView.vue` | L155-199 |
| `.cursor/rules/data-structures.mdc` | L76 |
| `src/composables/usePlaylistData.js` | L39-158 |
| `src/views/playlists/PlaylistView.vue` | L98-159 |
| `firestore.rules` | L44 |
| `src/views/playlists/EditPlaylistView.vue` | L63 |
| `src/views/playlists/AddPlaylistView.vue` | L371-451 |
| `src/views/playlists/EditPlaylistView.vue` | L61-126 |
| `src/views/playlists/AddPlaylistView.vue` | L310-373 |
| `tasks/pipeline-playlist-spec.md` | L60 |
| `src/views/playlists/PlaylistSingle.vue` | L603-665 |

</details>
</tool-use>

---

<tool-use data-tool-type="read" data-tool-name="read_file">
<details><summary>Tool use: **read_file** • Read file: firestore.indexes.json</summary>

</details>
</tool-use>

---



---


The query in `usePlaylistData.js` uses `where('userId', '==', userId)` with `orderBy('priority')`, which requires a composite index. `firestore.indexes.json` has no index for the playlists collection, so the query likely fails.

Checking if the new playlist has all required fields:


---

<tool-use data-tool-type="read" data-tool-name="read_file">
<details><summary>Tool use: **read_file** • Read file: src/views/playlists/AddPlaylistView.vue</summary>

</details>
</tool-use>

---



---


The issue is a missing Firestore composite index. The query in `usePlaylistData.js` uses `where('userId', '==', userId)` with `orderBy('priority')`, which requires a composite index. Without it, the query fails and returns no results.

**The Problem:**
```95:105:src/composables/usePlaylistData.js
  const fetchUserPlaylists = async (userId) => {
    loading.value = true;
    error.value = null;

    try {
      const playlistsRef = collection(db, 'playlists');
      const q = query(
        playlistsRef,
        where('userId', '==', userId),
        orderBy('priority')
      );
```

**The Fix:**

Add this composite index to `firestore.indexes.json`:

```json
{
  "indexes": [
    {
      "collectionGroup": "playlists",
      "queryScope": "COLLECTION",
      "fields": [
        {
          "fieldPath": "userId",
          "order": "ASCENDING"
        },
        {
          "fieldPath": "priority",
          "order": "ASCENDING"
        }
      ]
    }
  ],
  "fieldOverrides": [
    {
      "collectionGroup": "albums",
      "fieldPath": "artistNameLower",
      "indexes": [
        { "order": "ASCENDING", "queryScope": "COLLECTION" },
        { "order": "DESCENDING", "queryScope": "COLLECTION" }
      ]
    }
  ]
}
```

After updating the file, deploy the indexes:
```bash
firebase deploy --only firestore:indexes
```

**Alternative Quick Fix (if you can't deploy indexes right now):**

Remove `orderBy('priority')` from the query and sort in memory instead:

```javascript
const q = query(
  playlistsRef,
  where('userId', '==', userId)
  // Remove orderBy('priority') - we'll sort in memory
);

// Then after fetching, sort the results:
const allPlaylists = [];
querySnapshot.forEach((doc) => {
  // ... existing code ...
  allPlaylists.push({...});
});

// Sort by priority
allPlaylists.sort((a, b) => (a.priority || 0) - (b.priority || 0));
```

The index approach is preferred for performance. The quick fix works but is less efficient with many playlists.

Should I apply the index fix, or do you want to handle it?

---

_**User (2025-11-14 10:38Z)**_

so the composite index would handle new playlists being added? I'm confused why the playlists were fine before,but the disapppeared when I aded a new one.

---

_**Agent (model default, mode Ask)**_



---


Investigating why it worked before. Checking if the new playlist is missing required fields or has a different structure.


---

<tool-use data-tool-type="read" data-tool-name="read_file">
<details><summary>Tool use: **read_file** • Read file: src/views/playlists/AddPlaylistView.vue</summary>

</details>
</tool-use>

---

<tool-use data-tool-type="search" data-tool-name="codebase_search">
<details>
                <summary>Tool use: **codebase_search** • Searched codebase "What happens when a Firestore query fails due to missing index or missing fields?" • **10** results</summary>
            
| File | Lines |
|------|-------|
| `firestore.indexes.json` | L13 |
| `src/composables/usePlaylistData.js` | L50-158 |
| `src/composables/useLatestMovements.js` | L182 |
| `src/composables/useUserData.js` | L97 |
| `src/composables/useAlbumsData.js` | L25-651 |
| `src/main.js` | L48 |
| `src/composables/useAlbumMappings.js` | L132 |
| `src/composables/useUserSpotifyApi.js` | L4-653 |
| `firestore.rules` | L44 |
| `firebase.json` | L57 |

</details>
</tool-use>

---

<tool-use data-tool-type="search" data-tool-name="grep">
<details>
<summary>Tool use: **grep** • Grep for "console\.(log|error|warn).*playlist" in "src/composables/usePlaylistData.js" • 4 matches</summary>

Output mode: content


| File | Content | Line |
|------|------|------|
| `src/composables/usePlaylistData.js` | `console.log('Fetching playlists for user:', userId);` | L107 |
| `src/composables/usePlaylistData.js` | `console.log('Processing playlist:', playlist);` | L116 |
| `src/composables/usePlaylistData.js` | `console.log('Final grouped playlists:', grouped);` | L141 |
| `src/composables/usePlaylistData.js` | `console.error('Error fetching playlists:', e);` | L144 |


</details>
</tool-use>

---



---


Firestore can allow queries without a composite index on small datasets, but once the dataset grows or the query becomes more complex, it enforces the index requirement. Adding a new playlist likely triggered this.

Also, if the new playlist is missing the `priority` field (or it's `null`/`undefined`), `orderBy('priority')` can fail.

Checking the browser console for errors. The error handling in `usePlaylistData.js` catches errors, but we should verify what's happening:


---

<tool-use data-tool-type="read" data-tool-name="read_file">
<details><summary>Tool use: **read_file** • Read file: src/composables/usePlaylistData.js</summary>

</details>
</tool-use>

---



---


**Why it worked before but broke now:**

1. Firestore can allow queries without a composite index on small datasets, but once the dataset grows or becomes more complex, it enforces the index requirement. Adding a new playlist likely crossed that threshold.

2. The new playlist might be missing the `priority` field. The form sets `priority: 0` initially, but if `formData` doesn't include it when spreading, the document might not have it. If any document is missing the field used in `orderBy`, the query can fail.

**To diagnose:**

Check the browser console (F12) when loading the playlists view. You should see either:
- An error about a missing index (with a link to create it)
- An error about ordering by a field that doesn't exist

**Quick fixes:**

1. Ensure the new playlist has `priority`. The form validation doesn't check `priority`, so verify it's being saved.

2. Add the composite index (recommended). This is the proper fix and will prevent future issues.

3. Temporary workaround: Remove `orderBy('priority')` from the query and sort in memory instead. This avoids the index requirement but is less efficient.

The composite index is the right solution. Firestore's lenient behavior on small datasets is why it worked before; adding the playlist likely triggered the requirement.

Can you check the browser console and share the exact error message? That will confirm whether it's the index or a missing field.

---

_**User (2025-11-14 10:38Z)**_

this is the data for the new playlist

---

_**Agent (model default, mode Ask)**_



---


The new playlist data looks correct: `priority: 0` is present, and `userId` is set. The issue is likely the missing composite index.

Noticing a potential issue: the `category` is `"session"`, which isn't in the expected categories list. Checking how the code handles this:


---

<tool-use data-tool-type="read" data-tool-name="read_file">
<details><summary>Tool use: **read_file** • Read file: src/composables/usePlaylistData.js</summary>

</details>
</tool-use>

---



---


The code handles dynamic categories (lines 126-128), so `"session"` is fine. The issue is the missing composite index.

The query uses `where('userId', '==', userId)` with `orderBy('priority')`, which requires a composite index. Firestore may allow this on small datasets, but adding a playlist likely triggered the requirement.

**The fix:** Add the composite index to `firestore.indexes.json`:

```json
{
  "indexes": [
    {
      "collectionGroup": "playlists",
      "queryScope": "COLLECTION",
      "fields": [
        {
          "fieldPath": "userId",
          "order": "ASCENDING"
        },
        {
          "fieldPath": "priority",
          "order": "ASCENDING"
        }
      ]
    }
  ],
  "fieldOverrides": [
    {
      "collectionGroup": "albums",
      "fieldPath": "artistNameLower",
      "indexes": [
        { "order": "ASCENDING", "queryScope": "COLLECTION" },
        { "order": "DESCENDING", "queryScope": "COLLECTION" }
      ]
    }
  ]
}
```

Then deploy:
```bash
firebase deploy --only firestore:indexes
```

**Alternative quick fix** (if you can't deploy right now): Remove `orderBy('priority')` from the query and sort in memory. This avoids the index requirement but is less efficient.

The composite index is the proper solution. Should I show the code change to remove the `orderBy` as a temporary workaround, or do you want to add the index?

---

_**User (2025-11-14 10:38Z)**_

can I safely revert if it's not right?

---

_**Agent (model default, mode Ask)**_



---


Yes, you can safely revert it. Firestore indexes are safe to add and remove.

**To revert:**
1. Remove the index entry from `firestore.indexes.json` (or restore the file from git)
2. Deploy again: `firebase deploy --only firestore:indexes`

Or delete it in the Firebase Console:
- Go to Firestore → Indexes
- Find the index and delete it

**Notes:**
- Adding an index doesn't change your data
- Removing an index only affects queries that require it
- If you remove the index, queries using `where('userId')` + `orderBy('priority')` will fail until you either:
  - Re-add the index, or
  - Modify the query to not require it

**Before adding the index:**
Check the browser console (F12) when loading the playlists view. If you see an error like:
- "The query requires an index"
- A link to create the index

That confirms the index is needed. The index I suggested matches your query structure, so it should work.

If you want, I can show the exact change to make to `firestore.indexes.json`.

---

_**User (2025-11-14 10:38Z)**_

ok, do it

---

_**Agent (model default, mode Agent)**_



---


Adding the composite index to `firestore.indexes.json`.


---

<tool-use data-tool-type="read" data-tool-name="read_file">
<details><summary>Tool use: **read_file** • Read file: firestore.indexes.json</summary>

</details>
</tool-use>

---



---

<tool-use data-tool-type="write" data-tool-name="search_replace">

<details><summary>Tool use: **search_replace** • Edit file: firestore.indexes.json</summary>

**Chunk 1**
Lines added: 16, lines removed: 1

```diff
@@ -1,4 +1,19 @@
  {
-   "indexes": [],
+   "indexes": [
+     {
+       "collectionGroup": "playlists",
+       "queryScope": "COLLECTION",
+       "fields": [
+         {
+           "fieldPath": "userId",
+           "order": "ASCENDING"
+         },
+         {
+           "fieldPath": "priority",
+           "order": "ASCENDING"
+         }
+       ]
+     }
+   ],
    "fieldOverrides": [
      {
```

</details>

</tool-use>

---





---



---


Added the composite index. Deploying it to Firestore:


---

<tool-use data-tool-type="shell" data-tool-name="run_terminal_cmd">
<details><summary>Tool use: **run_terminal_cmd** • Run command: firebase deploy --only firestore:indexes</summary>

```bash
firebase deploy --only firestore:indexes
```

```

=== Deploying to 'audiofoodie-d5b2c'...

i  deploying firestore
i  firestore: reading indexes from firestore.indexes.json...
i  cloud.firestore: checking firestore.rules for compilation errors...
+  cloud.firestore: rules file firestore.rules compiled successfully
i  firestore: deploying indexes...
+  firestore: deployed indexes in firestore.indexes.json successfully for (default) database

+  Deploy complete!

Project Console: https://console.firebase.google.com/project/audiofoodie-d5b2c/overview

```
</details>
</tool-use>

---



---


Index deployed. Firestore is building it; this can take a few minutes, especially with existing data.

**What to expect:**
- The index appears in the Firebase Console under Firestore → Indexes
- Status will show "Building" until it's ready
- Once it's ready (status changes to "Enabled"), your playlists should load

**To check status:**
1. Go to the [Firebase Console](https://console.firebase.google.com/project/audiofoodie-d5b2c/firestore/indexes)
2. Look for the index on `playlists` with fields `userId` (Ascending) and `priority` (Ascending)
3. Wait until it shows "Enabled"

**Once the index is ready:**
- Refresh your playlists view
- All playlists, including the new one, should appear

If playlists still don't show after the index is enabled, check the browser console for errors and share them.

---

_**User (2025-11-14 10:38Z)**_

still the same. here's console log. looks ok.

---

_**Agent (model default, mode Ask)**_



---


The query is working; playlists are being processed. The issue is `allPlaylistsLoaded: false`, so the UI condition isn't met and nothing renders. Checking the `allPlaylistsLoaded` logic:


---

<tool-use data-tool-type="read" data-tool-name="read_file">
<details><summary>Tool use: **read_file** • Read file: src/views/playlists/PlaylistView.vue</summary>

</details>
</tool-use>

---



---


The issue is in `allPlaylistsLoaded`: the "Sharing" group has 0 cached playlists, but the new playlist is in that group. The logic on line 81 returns false when a group has playlists in data but none loaded yet.

Checking the template condition:


---

<tool-use data-tool-type="read" data-tool-name="read_file">
<details><summary>Tool use: **read_file** • Read file: src/views/playlists/PlaylistView.vue</summary>

</details>
</tool-use>

---



---


The issue is that `allPlaylistsLoaded` is `false`, so the template condition on line 287 prevents rendering. The cache shows `Sharing: Array(0)`, but the new playlist is in the "Sharing" group, so the cache is stale.

**The problem:**
1. The cache was created before the new playlist was added
2. The "Sharing" group has a playlist in Firestore but 0 in the cache
3. `allPlaylistsLoaded` returns `false` because "Sharing" has data but nothing loaded
4. The UI condition requires `allPlaylistsLoaded` to be `true`, so nothing displays

**Quick fix:** Clear the cache using the "Reload" button in the UI, or clear it programmatically.

**Better fix:** Adjust the `allPlaylistsLoaded` logic to allow display when groups are partially loaded, or handle groups that have data but haven't loaded from Spotify yet.

The logic on line 81 is too strict:
```javascript
return groupPlaylists.length > 0 && groupPlaylists.every(p => p.id != null);
```

If a group has playlists in Firestore but they haven't been loaded into `playlists.value` yet (or failed to load), this returns `false` and blocks the UI.

**Proposed fix:** Modify `allPlaylistsLoaded` to:
1. Allow display if at least one group is fully loaded, OR
2. Consider a group "loaded" if it has no playlists in data (empty groups), OR if all its playlists have been attempted to load (even if some failed)

Should I update the logic to handle this case, or do you want to clear the cache first to see if that resolves it?

---

_**User (2025-11-14 10:38Z)**_

reloading didn't help. Sharing is empty. we need to understand why

---

_**Agent (model default, mode Ask)**_



---


Tracing why the "Sharing" group playlist isn't loading. Checking the data flow:


---

<tool-use data-tool-type="read" data-tool-name="read_file">
<details><summary>Tool use: **read_file** • Read file: src/views/playlists/PlaylistView.vue</summary>

</details>
</tool-use>

---

<tool-use data-tool-type="read" data-tool-name="read_file">
<details><summary>Tool use: **read_file** • Read file: src/composables/usePlaylistData.js</summary>

</details>
</tool-use>

---



---


The issue is in `getAvailableCategories`: it only returns categories from `ALL_CATEGORIES` (`['queued', 'curious', 'interested', 'great', 'excellent', 'wonderful', 'end']`), but the new playlist has category `"session"`, which isn't in that list.

So when loading playlists for "Sharing", `"session"` isn't included, and the playlist is skipped.

Checking the exact logic:


---

<tool-use data-tool-type="read" data-tool-name="read_file">
<details><summary>Tool use: **read_file** • Read file: src/composables/usePlaylistData.js</summary>

</details>
</tool-use>

---



---


The issue: `getAvailableCategories` only returns categories from `ALL_CATEGORIES`, but the new playlist uses `"session"`, which isn't in that list. So `"session"` is never returned, and the playlist is skipped.

**The fix:** Change `getAvailableCategories` to return all categories that have playlists, not just those in `ALL_CATEGORIES`.

Here's the fix for `src/composables/usePlaylistData.js`:

```javascript
const getAvailableCategories = (group) => {
  console.log(`Getting available categories for group ${group}:`, {
    playlistsValue: playlists.value,
    groupData: playlists.value[group],
  });
  
  // Get ALL categories that have playlists, not just predefined ones
  if (!playlists.value[group]) return [];
  
  return Object.keys(playlists.value[group]).filter(category => 
    playlists.value[group][category]?.length > 0
  );
};
```

This returns all categories that have playlists in the data, including `"session"` and any other custom categories.

Should I apply this fix?

---

_**User (2025-11-14 10:38Z)**_

yes do it

---

_**Agent (model default, mode Agent)**_



---


Updating `getAvailableCategories` to return all categories that have playlists:


---

<tool-use data-tool-type="read" data-tool-name="read_file">
<details><summary>Tool use: **read_file** • Read file: src/composables/usePlaylistData.js</summary>

</details>
</tool-use>

---



---

<tool-use data-tool-type="write" data-tool-name="search_replace">

<details><summary>Tool use: **search_replace** • Edit file: src/composables/usePlaylistData.js</summary>

**Chunk 1**
Lines added: 6, lines removed: 7

```diff
@@ -64,12 +64,11 @@
        playlistsValue: playlists.value,
        groupData: playlists.value[group],
-       categories: ALL_CATEGORIES.filter(category =&gt; 
-         playlists.value[group]?.[category]?.length &gt; 0
-       )
-     });
+     });
+     
+     // Get ALL categories that have playlists, not just predefined ones
+     if (!playlists.value[group]) return [];
      
-     // Get categories that have playlists
-     return ALL_CATEGORIES.filter(category =&gt; 
-       playlists.value[group]?.[category]?.length &gt; 0
+     return Object.keys(playlists.value[group]).filter(category =&gt; 
+       playlists.value[group][category]?.length &gt; 0
      );
    };
```

</details>

</tool-use>

---





---



---

<tool-use data-tool-type="generic" data-tool-name="read_lints">
<details>
          <summary>Tool use: **read_lints** • Read lints for 1 file</summary>
      
Lint paths:

- `src/composables/usePlaylistData.js`

Lint results


**No lint errors found**
</details>
</tool-use>

---





---



---


Fix applied. `getAvailableCategories` now returns all categories that have playlists, not just those in `ALL_CATEGORIES`. This includes `"session"` and any other custom categories.

**What changed:**
- Before: Only returned categories from the predefined `ALL_CATEGORIES` array
- After: Returns all categories that exist in the data and have playlists

**To test:**
1. Refresh the playlists view
2. Clear the cache if needed (use the "Reload" button)
3. The "Sharing" group should now show the playlist with category "session"

The function now iterates over the actual keys in `playlists.value[group]` instead of filtering a predefined list, so it will discover any category that exists in your data.

---

