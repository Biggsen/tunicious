<!-- Generated by SpecStory, Markdown v2.1.0 -->

<!-- cursor Session 902d84ea-81c1-4c26-9ba2-f9f86c54f94d (2025-11-19 20:35Z) -->

# Album data caching and storage (2025-11-19 20:35Z)

_**User (2025-11-19 14:37Z)**_

of all the albums data here in each album item, what is the caching of this data? where is it stored?

---

_**Agent (model default, mode Ask)**_



---


Tracing the caching for album data in LatestMovements. Examining relevant files.


---

<tool-use data-tool-type="read" data-tool-name="read_file">
<details><summary>Tool use: **read_file** • Read file: src/components/LatestMovements.vue</summary>

</details>
</tool-use>

---

<tool-use data-tool-type="read" data-tool-name="read_file">
<details><summary>Tool use: **read_file** • Read file: src/composables/useAlbumsData.js</summary>

</details>
</tool-use>

---

<tool-use data-tool-type="read" data-tool-name="read_file">
<details><summary>Tool use: **read_file** • Read file: src/composables/useCache.js</summary>

</details>
</tool-use>

---

<tool-use data-tool-type="read" data-tool-name="read_file">
<details><summary>Tool use: **read_file** • Read file: src/utils/cache.js</summary>

</details>
</tool-use>

---

<tool-use data-tool-type="read" data-tool-name="read_file">
<details><summary>Tool use: **read_file** • Read file: src/composables/useLatestMovements.js</summary>

</details>
</tool-use>

---



---


Checking how album data is used in the component and what gets cached:


---

<tool-use data-tool-type="search" data-tool-name="codebase_search">
<details>
                <summary>Tool use: **codebase_search** • Searched codebase "How is album data cached when displaying album items with track information?" • **13** results</summary>
            
| File | Lines |
|------|-------|
| `src/composables/useAlbumsData.js` | L24-664 |
| `src/views/music/ArtistView.vue` | L143-200 |
| `src/views/playlists/PlaylistSingle.vue` | L103-164 |
| `src/views/playlists/PlaylistSingle.vue` | L744-788 |
| `src/views/music/ArtistView.vue` | L99-149 |
| `src/views/playlists/PlaylistSingle.vue` | L781-828 |
| `src/utils/lastFmUtils.js` | L10-128 |
| `src/views/music/AlbumView.vue` | L298-361 |
| `src/views/music/AlbumView.vue` | L41 |
| `src/views/music/ArtistView.vue` | L47-103 |
| `src/views/playlists/PlaylistSingle.vue` | L498-563 |
| `src/composables/useAlbumsData.js` | L664 |
| `src/views/playlists/PlaylistSingle.vue` | L561-600 |

</details>
</tool-use>

---

<tool-use data-tool-type="search" data-tool-name="grep">
<details>
<summary>Tool use: **grep** • Grep for "albumRootData|albumDbData" in "src" • 45 matches</summary>

Output mode: content


| File | Content | Line |
|------|------|------|
| `src\views\playlists\PlaylistSingle.vue` | `// For year sorting in computed, we use available data from albumRootDataMap` | L468 |
| `src\views\playlists\PlaylistSingle.vue` | `const rootA = albumRootDataMap.value[a.id];` | L470 |
| `src\views\playlists\PlaylistSingle.vue` | `const rootB = albumRootDataMap.value[b.id];` | L471 |
| `src\views\playlists\PlaylistSingle.vue` | `const rootA = albumRootDataMap.value[a.id];` | L485 |
| `src\views\playlists\PlaylistSingle.vue` | `const rootB = albumRootDataMap.value[b.id];` | L486 |
| `src\views\playlists\PlaylistSingle.vue` | `const rootA = albumRootDataMap.value[a.id];` | L494 |
| `src\views\playlists\PlaylistSingle.vue` | `const rootB = albumRootDataMap.value[b.id];` | L495 |
| `src\views\playlists\PlaylistSingle.vue` | `// Map to album objects with id, artists, artistName from albumData or albumRootDataMap` | L520 |
| `src\views\playlists\PlaylistSingle.vue` | `const rootData = albumRootDataMap.value[albumWithDate.id];` | L529 |
| `src\views\playlists\PlaylistSingle.vue` | `const albumDbDataMap = ref(\{});` | L554 |
| `src\views\playlists\PlaylistSingle.vue` | `const albumRootDataMap = ref(\{});` | L555 |
| `src\views\playlists\PlaylistSingle.vue` | `const cacheKey = `albumRootData_$\{albumId\}`;` | L591 |
| `src\views\playlists\PlaylistSingle.vue` | `albumDbDataMap.value = await fetchAlbumsData(albumData.value.map(a => a.id));` | L793 |
| `src\views\playlists\PlaylistSingle.vue` | `albumRootDataMap.value = Object.fromEntries(albumData.value.map((a, i) => [a.id, rootDetailsArr[i]]));` | L795 |
| `src\views\playlists\PlaylistSingle.vue` | `inCollectionMap.value = albumDbDataMap.value;` | L797 |
| `src\views\playlists\PlaylistSingle.vue` | `const userData = albumDbDataMap.value[album.id];` | L800 |
| `src\views\playlists\PlaylistSingle.vue` | `// Also clear albumDbData cache for all albums on the current page` | L848 |
| `src\views\playlists\PlaylistSingle.vue` | `await clearCache(`albumDbData_$\{album.id\}_$\{user.value.uid\}`);` | L851 |
| `src\views\playlists\PlaylistSingle.vue` | `await clearCache(`albumRootData_$\{album.id\}`);` | L853 |
| `src\views\playlists\PlaylistSingle.vue` | `const cacheKey = `albumRootData_$\{albumId\}`;` | L969 |
| `src\views\playlists\PlaylistSingle.vue` | `albumRootDataMap.value = \{ ...albumRootDataMap.value, [albumId]: details \};` | L975 |
| `src\views\playlists\PlaylistSingle.vue` | `// Manually trigger needsUpdate recalculation after updating albumRootDataMap` | L979 |
| `src\views\playlists\PlaylistSingle.vue` | `const details = albumRootDataMap.value[album.id];` | L988 |
| `src\composables\useAlbumsData.js` | `const cacheKey = `albumDbData_$\{albumId\}_$\{user.value.uid\}`;` | L42 |
| `src\composables\useAlbumsData.js` | `const cacheKey = `albumRootData_$\{albumId\}`;` | L476 |
| `src\composables\useAlbumsData.js` | `const cacheKey = `albumDbData_$\{albumId\}_$\{user.value.uid\}`;` | L631 |
| `src\views\music\ArtistView.vue` | `const albumDbDataMap = ref(\{});` | L32 |
| `src\views\music\ArtistView.vue` | `const albumRootDataMap = ref(\{});` | L33 |
| `src\views\music\ArtistView.vue` | `const cacheKey = `albumRootData_$\{albumId\}`;` | L105 |
| `src\views\music\ArtistView.vue` | `albumDbDataMap.value = await fetchAlbumsData(albumData.value.map(a => a.id));` | L120 |
| `src\views\music\ArtistView.vue` | `albumRootDataMap.value = Object.fromEntries(albumData.value.map((a, i) => [a.id, rootDetailsArr[i]]));` | L122 |
| `src\views\music\ArtistView.vue` | `albumsStatus.value = albumDbDataMap.value;` | L123 |
| `src\views\music\ArtistView.vue` | `const userData = albumDbDataMap.value[album.id];` | L126 |
| `src\views\music\ArtistView.vue` | `albumDbDataMap.value = await fetchAlbumsData(albumData.value.map(a => a.id));` | L164 |
| `src\views\music\ArtistView.vue` | `albumRootDataMap.value = Object.fromEntries(albumData.value.map((a, i) => [a.id, rootDetailsArr[i]]));` | L166 |
| `src\views\music\ArtistView.vue` | `albumsStatus.value = albumDbDataMap.value;` | L167 |
| `src\views\music\ArtistView.vue` | `const userData = albumDbDataMap.value[album.id];` | L170 |
| `src\views\music\SearchView.vue` | `const albumDbDataMap = ref(\{});` | L51 |
| `src\views\music\SearchView.vue` | `const albumRootDataMap = ref(\{});` | L52 |
| `src\views\music\SearchView.vue` | `const cacheKey = `albumRootData_$\{albumId\}`;` | L72 |
| `src\views\music\SearchView.vue` | `albumDbDataMap.value = \{};` | L84 |
| `src\views\music\SearchView.vue` | `albumRootDataMap.value = \{};` | L85 |
| `src\views\music\SearchView.vue` | `albumDbDataMap.value = await fetchAlbumsData(results.value.map(album => album.id));` | L99 |
| `src\views\music\SearchView.vue` | `albumRootDataMap.value = Object.fromEntries(results.value.map((album, i) => [album.id, rootDetailsArr[i]]));` | L101 |
| `src\views\music\SearchView.vue` | `const userData = albumDbDataMap.value[album.id];` | L105 |


</details>
</tool-use>

---



---


## Caching for Album Data

Two cache keys are used for album data:

### 1. User-specific album data
- Cache key: `albumDbData_${albumId}_${user.uid}`
- Stored in: `localStorage` (via `src/utils/cache.js`)
- Contains: User's playlist history, `createdAt`, `updatedAt`
- Used by: `fetchUserAlbumData()` in `useAlbumsData.js`

```42:44:src/composables/useAlbumsData.js
    const cacheKey = `albumDbData_${albumId}_${user.value.uid}`;
    let cached = await getCache(cacheKey);
    if (cached) return cached;
```

### 2. Root-level album details
- Cache key: `albumRootData_${albumId}`
- Stored in: `localStorage`
- Contains: `albumTitle`, `artistName`, `albumCover`, `artistId`, `releaseYear`
- Used by: `getAlbumsDetailsBatch()` in `useAlbumsData.js`

```476:478:src/composables/useAlbumsData.js
        const cacheKey = `albumRootData_${albumId}`;
        let cached = await getCache(cacheKey);
        if (cached) {
```

## Cache Storage Details

All cache data is stored in `localStorage` via `src/utils/cache.js`:
- Format: `{ data: <actual data>, timestamp: <Date.now()> }`
- Expiration: 24 hours
- Max entries: 100 (with automatic cleanup)
- Location: Browser's `localStorage`

## Note on LatestMovements

The `LatestMovements` component doesn't use these caches directly. It fetches all albums from Firestore and processes them in memory. The caches are used by other views (PlaylistSingle, AlbumView, ArtistView) that display detailed album information.

If you want `LatestMovements` to use caching, it would need to call `getAlbumsDetailsBatch()` or `fetchUserAlbumData()` instead of querying Firestore directly.

---

_**User (2025-11-19 14:37Z)**_

no, this is not the latestmovements. this is the albumItem component in the @PlaylistSingle.vue .

---

_**Agent (model default, mode Ask)**_



---


Examining the AlbumItem component to see what album data it displays and how it's cached.


---

<tool-use data-tool-type="read" data-tool-name="read_file">
<details><summary>Tool use: **read_file** • Read file: src/components/AlbumItem.vue</summary>

</details>
</tool-use>

---

<tool-use data-tool-type="search" data-tool-name="codebase_search">
<details>
                <summary>Tool use: **codebase_search** • Searched codebase "How is album data cached when displaying in AlbumItem component with tracks and loved tracks?" • **14** results</summary>
            
| File | Lines |
|------|-------|
| `src/composables/useAlbumsData.js` | L24-664 |
| `src/views/playlists/PlaylistSingle.vue` | L103-164 |
| `src/views/music/AlbumView.vue` | L298-361 |
| `src/components/AlbumItem.vue` | L37-129 |
| `src/views/music/ArtistView.vue` | L143-200 |
| `src/views/music/AlbumView.vue` | L245-305 |
| `src/views/playlists/PlaylistSingle.vue` | L781-828 |
| `src/views/music/ArtistView.vue` | L99-149 |
| `src/views/music/AlbumView.vue` | L41 |
| `src/views/playlists/PlaylistSingle.vue` | L561-600 |
| `src/views/music/AlbumView.vue` | L37-83 |
| `src/components/AlbumItem.vue` | L272-321 |
| `src/utils/lastFmUtils.js` | L10-128 |
| `src/views/playlists/PlaylistSingle.vue` | L598-657 |

</details>
</tool-use>

---



---


Checking how tracks are cached:


---

<tool-use data-tool-type="read" data-tool-name="read_file">
<details><summary>Tool use: **read_file** • Read file: src/composables/useUserSpotifyApi.js</summary>

</details>
</tool-use>

---

<tool-use data-tool-type="search" data-tool-name="grep">
<details>
<summary>Tool use: **grep** • Grep for "getAlbumTracks|albumTracks" in "src" • 33 matches</summary>

Output mode: content


| File | Content | Line |
|------|------|------|
| `src\views\playlists\PlaylistSingle.vue` | `const \{ getPlaylist, getPlaylistAlbumsWithDates, loadAlbumsBatched, addAlbumToPlaylist, removeAlbumFromPlaylist: removeFromSpotify, loading: spotifyLoading, error: spotifyError, getAlbumTracks, getAllArtistAlbums, getAllPlaylistTracks \} = useUserSpotifyApi();` | L35 |
| `src\views\playlists\PlaylistSingle.vue` | `const albumTracks = ref(\{}); // Store tracks for each album` | L90 |
| `src\views\playlists\PlaylistSingle.vue` | `if (!albumTracks.value[album.id]) \{` | L145 |
| `src\views\playlists\PlaylistSingle.vue` | `const response = await getAlbumTracks(album.id);` | L147 |
| `src\views\playlists\PlaylistSingle.vue` | `albumTracks.value[album.id] = response.items \|\| [];` | L148 |
| `src\views\playlists\PlaylistSingle.vue` | `albumTracks.value[album.id] = [];` | L151 |
| `src\views\playlists\PlaylistSingle.vue` | `const result = await calculateLovedTrackPercentage(album, lovedTracks.value, albumTracks.value[album.id]);` | L195 |
| `src\views\playlists\PlaylistSingle.vue` | `const result = await calculateLovedTrackPercentage(album, lovedTracks.value, albumTracks.value[album.id]);` | L212 |
| `src\views\playlists\PlaylistSingle.vue` | `const result = await calculateLovedTrackPercentage(album, lovedTracks.value, albumTracks.value[album.id]);` | L242 |
| `src\views\playlists\PlaylistSingle.vue` | `const result = await calculateLovedTrackPercentage(album, lovedTracks.value, albumTracks.value[album.id]);` | L259 |
| `src\views\playlists\PlaylistSingle.vue` | `if (albumLovedData.value[album.id] && albumTracks.value[album.id]) \{` | L283 |
| `src\views\playlists\PlaylistSingle.vue` | `const result = await calculateLovedTrackPercentage(album, lovedTracks.value, albumTracks.value[album.id]);` | L284 |
| `src\views\playlists\PlaylistSingle.vue` | `await clearCache(`albumTracks_$\{albumId\}`);` | L300 |
| `src\views\playlists\PlaylistSingle.vue` | `:tracks="albumTracks[album.id] \|\| []"` | L2245 |
| `src\components\TrackList.vue` | `const \{ getAlbumTracks \} = useUserSpotifyApi();` | L96 |
| `src\components\TrackList.vue` | `const response = await getAlbumTracks(albumId, limit, offset);` | L339 |
| `src\utils\lastFmUtils.js` | `const cacheKey = `albumTracks_$\{albumId\}`;` | L77 |
| `src\utils\lastFmUtils.js` | `const \{ getAlbumTracks \} = useUserSpotifyApi();` | L85 |
| `src\utils\lastFmUtils.js` | `const response = await getAlbumTracks(albumId, limit, offset);` | L94 |
| `src\utils\lastFmUtils.js` | `* @param \{Array\} albumTracks - Optional array of album tracks (will fetch if not provided)` | L127 |
| `src\utils\lastFmUtils.js` | `export async function calculateLovedTrackPercentage(album, lovedTracks = [], albumTracks = null) \{` | L130 |
| `src\utils\lastFmUtils.js` | `if (!albumTracks) \{` | L136 |
| `src\utils\lastFmUtils.js` | `albumTracks = await getCachedAlbumTracks(album.id);` | L137 |
| `src\utils\lastFmUtils.js` | `if (!albumTracks.length) \{` | L140 |
| `src\utils\lastFmUtils.js` | `albumTracks.forEach(track => \{` | L147 |
| `src\utils\lastFmUtils.js` | `const percentage = albumTracks.length > 0 ? Math.round((lovedCount / albumTracks.length) * 100) : 0;` | L167 |
| `src\utils\lastFmUtils.js` | `totalCount: albumTracks.length,` | L171 |
| `src\composables\useUserSpotifyApi.js` | `const albumTracks = await makeUserRequest(`https://api.spotify.com/v1/albums/$\{albumId\}/tracks?limit=50`);` | L350 |
| `src\composables\useUserSpotifyApi.js` | `const trackUris = albumTracks.items.map(track => `spotify:track:$\{track.id\}`);` | L353 |
| `src\composables\useUserSpotifyApi.js` | `const getAlbumTracks = async (albumId, limit = 50, offset = 0) => \{` | L579 |
| `src\composables\useUserSpotifyApi.js` | `getAlbumTracks,` | L650 |
| `src\views\music\AlbumView.vue` | `const \{ getAlbum, getAlbumTracks, getPlaylistAlbumsWithDates\} = useUserSpotifyApi();` | L31 |
| `src\views\music\AlbumView.vue` | `const response = await getAlbumTracks(albumId, limit, offset);` | L91 |


</details>
</tool-use>

---



---

<tool-use data-tool-type="read" data-tool-name="read_file">
<details><summary>Tool use: **read_file** • Read file: src/composables/useUserSpotifyApi.js</summary>

</details>
</tool-use>

---





---

<tool-use data-tool-type="read" data-tool-name="read_file">
<details><summary>Tool use: **read_file** • Read file: src/utils/lastFmUtils.js</summary>

</details>
</tool-use>

---



---


Caching for album data in the **AlbumItem** component (used in PlaylistSingle.vue):

## Caching for AlbumItem Data

### 1. **Album Basic Data** (name, artist, cover, year)
- **Cache keys:**
  - `albumRootData_${albumId}` - Root-level album details from Firestore
  - `playlist_${playlistId}_page_${page}_${sortMode}_${sortDirection}` - Paginated album data
- **Stored in:** `localStorage`
- **Used by:** `getAlbumsDetailsBatch()` and `fetchAlbumsForPage()` in PlaylistSingle.vue

```590:596:src/views/playlists/PlaylistSingle.vue
async function getCachedAlbumDetails(albumId) {
  const cacheKey = `albumRootData_${albumId}`;
  let cached = await getCache(cacheKey);
  if (cached) return cached;
  const details = await getAlbumDetails(albumId);
  if (details) await setCache(cacheKey, details);
  return details;
}
```

### 2. **User Album Data** (playlist history, rating data)
- **Cache key:** `albumDbData_${albumId}_${user.uid}`
- **Stored in:** `localStorage`
- **Contains:** User's playlist history, `createdAt`, `updatedAt`, current playlist info
- **Used by:** `fetchAlbumsData()` in `useAlbumsData.js`

```42:44:src/composables/useAlbumsData.js
    const cacheKey = `albumDbData_${albumId}_${user.value.uid}`;
    let cached = await getCache(cacheKey);
    if (cached) return cached;
```

### 3. **Album Tracks**
- **Cache key:** `albumTracks_${albumId}`
- **Stored in:** `localStorage`
- **Used by:** `getCachedAlbumTracks()` in `lastFmUtils.js`

```74:82:src/utils/lastFmUtils.js
export async function getCachedAlbumTracks(albumId) {
  if (!albumId) return [];
  
  const cacheKey = `albumTracks_${albumId}`;
  let cached = await getCache(cacheKey);
  
  if (cached) {
    return cached;
  }
```

### 4. **Loved Tracks** (Last.fm)
- **Cache key:** `lovedTracks_${lastFmUserName}`
- **Stored in:** `localStorage`
- **Used by:** `getCachedLovedTracks()` in `lastFmUtils.js`

```11:19:src/utils/lastFmUtils.js
export async function getCachedLovedTracks(lastFmUserName) {
  if (!lastFmUserName) return [];
  
  const cacheKey = `lovedTracks_${lastFmUserName}`;
  let cached = await getCache(cacheKey);
  
  if (cached) {
    return cached;
  }
```

### 5. **Playlist Track IDs** (which tracks are in the playlist)
- **Cache key:** `playlist_tracks_${playlistId}`
- **Stored in:** `localStorage`
- **Contains:** Map of `albumId -> { trackId: true }` for all tracks in the playlist

```116:134:src/views/playlists/PlaylistSingle.vue
        const cacheKey = `playlist_tracks_${id.value}`;
        let cachedTrackIds = await getCache(cacheKey);
        
        if (!cachedTrackIds) {
          const allPlaylistTracks = await getAllPlaylistTracks(id.value);
          const trackIdsByAlbum = {};
          
          allPlaylistTracks.forEach(item => {
            if (item.track?.album?.id && item.track?.id) {
              const albumId = item.track.album.id;
              if (!trackIdsByAlbum[albumId]) {
                trackIdsByAlbum[albumId] = {};
              }
              trackIdsByAlbum[albumId][item.track.id] = true;
            }
          });
          
          cachedTrackIds = trackIdsByAlbum;
          await setCache(cacheKey, cachedTrackIds);
        }
```

## Cache Storage Summary

All cache data is stored in `localStorage` via `src/utils/cache.js`:
- **Format:** `{ data: <actual data>, timestamp: <Date.now()> }`
- **Expiration:** 24 hours
- **Max entries:** 100 (with automatic cleanup)
- **Location:** Browser's `localStorage`

Note: In PlaylistSingle.vue, tracks are stored in memory (`albumTracks.value[album.id]`) and not cached individually. The `getCachedAlbumTracks()` function is available but not used in the playlist view; tracks are fetched directly via `getAlbumTracks()` and stored in the reactive ref.

---

_**User (2025-11-19 14:37Z)**_

I think we also have lovedTracks_[username] cache?

---

_**Agent (model default, mode Ask)**_



---


Yes, the `lovedTracks_${lastFmUserName}` cache exists. It's used for Last.fm loved tracks data. Details:


---

<tool-use data-tool-type="search" data-tool-name="grep">
<details>
<summary>Tool use: **grep** • Grep for "lovedTracks_" in "src" • 7 matches</summary>

Output mode: content


| File | Content | Line |
|------|------|------|
| `src\views\playlists\PlaylistSingle.vue` | `const cacheKey = `lovedTracks_$\{userData.value.lastFmUserName\}`;` | L187 |
| `src\views\playlists\PlaylistSingle.vue` | `await clearCache(`lovedTracks_$\{userData.value.lastFmUserName\}`);` | L207 |
| `src\views\playlists\PlaylistSingle.vue` | `const cacheKey = `lovedTracks_$\{userData.value.lastFmUserName\}`;` | L234 |
| `src\views\playlists\PlaylistSingle.vue` | `await clearCache(`lovedTracks_$\{userData.value.lastFmUserName\}`);` | L254 |
| `src\views\playlists\PlaylistSingle.vue` | `await clearCache(`lovedTracks_$\{userData.value.lastFmUserName\}`);` | L278 |
| `src\views\playlists\PlaylistSingle.vue` | `await clearCache(`lovedTracks_$\{userData.value.lastFmUserName\}`);` | L874 |
| `src\utils\lastFmUtils.js` | `const cacheKey = `lovedTracks_$\{lastFmUserName\}`;` | L14 |


</details>
</tool-use>

---



---


The `lovedTracks_${lastFmUserName}` cache exists and is used in multiple places:

**Cache Key:** `lovedTracks_${lastFmUserName}`

**Where it's used:**

1. **Fetched/cached in:** `getCachedLovedTracks()` in `lastFmUtils.js`
```11:19:src/utils/lastFmUtils.js
export async function getCachedLovedTracks(lastFmUserName) {
  if (!lastFmUserName) return [];
  
  const cacheKey = `lovedTracks_${lastFmUserName}`;
  let cached = await getCache(cacheKey);
  
  if (cached) {
    return cached;
  }
```

2. **Updated when tracks are loved/unloved** in PlaylistSingle.vue:
```187:188:src/views/playlists/PlaylistSingle.vue
    const cacheKey = `lovedTracks_${userData.value.lastFmUserName}`;
    await setCache(cacheKey, lovedTracks.value);
```

3. **Cleared on refresh** in PlaylistSingle.vue:
```278:278:src/views/playlists/PlaylistSingle.vue
    await clearCache(`lovedTracks_${userData.value.lastFmUserName}`);
```

**What it contains:** Array of all loved tracks from Last.fm for that user, cached for 24 hours.

**Storage:** `localStorage` via the cache utility.

This cache is used to calculate the "loved tracks percentage" shown in each AlbumItem component.

---

_**User (2025-11-19 14:37Z)**_

there's quite an overlap in data here between caches. especially lovedTracks, albumTracks and playlist_tracks. suggestions to consolidate?

---

_**Agent (model default, mode Ask)**_



---


Analyzing cache overlaps and proposing consolidation strategies:


---

<tool-use data-tool-type="read" data-tool-name="read_file">
<details><summary>Tool use: **read_file** • Read file: src/views/playlists/PlaylistSingle.vue</summary>

</details>
</tool-use>

---

<tool-use data-tool-type="read" data-tool-name="read_file">
<details><summary>Tool use: **read_file** • Read file: src/components/TrackList.vue</summary>

</details>
</tool-use>

---

<tool-use data-tool-type="search" data-tool-name="codebase_search">
<details>
                <summary>Tool use: **codebase_search** • Searched codebase "How are album tracks and playlist tracks used together to display track information?" • **15** results</summary>
            
| File | Lines |
|------|-------|
| `src/components/TrackList.vue` | L76 |
| `src/views/playlists/PlaylistSingle.vue` | L103-164 |
| `src/views/playlists/PlaylistSingle.vue` | L2219-2262 |
| `src/components/AlbumItem.vue` | L272-321 |
| `src/components/TrackList.vue` | L71-121 |
| `src/components/TrackList.vue` | L471-499 |
| `src/views/music/AlbumView.vue` | L298-361 |
| `src/views/music/AlbumView.vue` | L41 |
| `src/components/TrackList.vue` | L421-479 |
| `src/components/TrackList.vue` | L309-377 |
| `src/components/TrackList.vue` | L370-429 |
| `src/composables/useUserSpotifyApi.js` | L5-654 |
| `src/components/AlbumItem.vue` | L37-129 |
| `src/components/AlbumItem.vue` | L219-255 |
| `src/views/playlists/PlaylistSingle.vue` | L77-108 |

</details>
</tool-use>

---



---


Here are consolidation strategies to reduce overlap:

## Current Overlaps

1. **`playlist_tracks_${playlistId}`** - Stores track IDs only: `{ albumId: { trackId: true } }`
2. **`albumTracks_${albumId}`** - Stores full track objects for each album
3. **`albumTracks.value[album.id]`** - In-memory storage (not cached) in PlaylistSingle.vue
4. **`lovedTracks_${lastFmUserName}`** - Separate array of loved tracks

## Consolidation Strategies

### Option 1: Enhanced Playlist Tracks Cache (Recommended)
Store full track objects in the playlist cache instead of just IDs:

```javascript
// Instead of: { albumId: { trackId: true } }
// Store: { albumId: { trackId: trackObject } }
```

**Benefits:**
- Single source of truth for playlist tracks
- Eliminates need to fetch `albumTracks` separately for playlist albums
- Can derive track IDs from full objects when needed

**Implementation:**
```javascript
// In fetchAlbumTracks(), store full track objects:
const trackObjectsByAlbum = {};
allPlaylistTracks.forEach(item => {
  if (item.track?.album?.id && item.track?.id) {
    const albumId = item.track.album.id;
    if (!trackObjectsByAlbum[albumId]) {
      trackObjectsByAlbum[albumId] = {};
    }
    trackObjectsByAlbum[albumId][item.track.id] = item.track; // Full object
  }
});
```

### Option 2: Playlist-Scoped Album Tracks Cache
Cache album tracks per playlist to avoid duplication:

**Cache key:** `playlist_${playlistId}_albumTracks_${albumId}`

**Benefits:**
- Tracks cached in playlist context (where they're most used)
- Still allows `albumTracks_${albumId}` for non-playlist contexts (AlbumView, etc.)

### Option 3: Unified Track Data Structure
Create a single cache entry per playlist with all track data:

**Cache key:** `playlist_${playlistId}_tracks`

**Structure:**
```javascript
{
  albums: {
    [albumId]: {
      tracks: [/* full track objects */],
      trackIds: {/* for fast lookup */}
    }
  },
  metadata: {
    lastUpdated: timestamp,
    totalTracks: number
  }
}
```

**Benefits:**
- Single cache entry per playlist
- All track data in one place
- Easier to invalidate/refresh

### Option 4: Keep `lovedTracks` Separate (Recommended)
Keep `lovedTracks_${lastFmUserName}` separate because:
- It's user-specific, not playlist-specific
- Used across multiple playlists/views
- Updated independently when tracks are loved/unloved

## Recommended Approach

Combine Option 1 + Option 4:

1. Enhance `playlist_tracks_${playlistId}` to store full track objects
2. Use playlist tracks as the source for album tracks in playlist context
3. Keep `albumTracks_${albumId}` for non-playlist contexts (AlbumView, ArtistView)
4. Keep `lovedTracks_${lastFmUserName}` separate

**Cache keys after consolidation:**
- `playlist_tracks_${playlistId}` - Full track objects by album (enhanced)
- `albumTracks_${albumId}` - Still used for non-playlist contexts
- `lovedTracks_${lastFmUserName}` - Separate (user-specific)

This reduces duplication while maintaining flexibility for different use cases.

---

_**User (2025-11-19 14:37Z)**_

regarding the logic to keep lovedTracks separate - you could argue that all these caches are user specific, as they're not being shared between users. track playcount and loved is a fundamental aspect of this app, not a side thing. it would make sense to consolidate as much as possible and build a highly effecient cache. it's not a worry if setting up the cache might take a bit of time, as we're intending to only use and rely on the cache more going forward. playcount and loved can be all updated in the cache, no need to fetch data via api after that first call.

---

_**Agent (model default, mode Ask)**_



---


Since all caches are user-specific (localStorage), consolidating into a unified cache makes sense. Here's a structure that includes tracks, loved status, and playcounts:


---

<tool-use data-tool-type="read" data-tool-name="read_file">
<details><summary>Tool use: **read_file** • Read file: src/components/TrackList.vue</summary>

</details>
</tool-use>

---

<tool-use data-tool-type="search" data-tool-name="codebase_search">
<details>
                <summary>Tool use: **codebase_search** • Searched codebase "How is playcount data fetched and stored for tracks?" • **15** results</summary>
            
| File | Lines |
|------|-------|
| `src/components/TrackList.vue` | L116-179 |
| `src/components/TrackList.vue` | L309-377 |
| `src/components/TrackList.vue` | L71-121 |
| `src/components/TrackList.vue` | L370-429 |
| `src/components/TrackList.vue` | L177-245 |
| `src/views/playlists/PlaylistSingle.vue` | L271-314 |
| `src/components/TrackList.vue` | L495-538 |
| `src/components/TrackList.vue` | L76 |
| `src/views/playlists/PlaylistSingle.vue` | L781-828 |
| `src/views/playlists/PlaylistSingle.vue` | L103-164 |
| `src/views/playlists/PlaylistSingle.vue` | L709-750 |
| `src/views/playlists/PlaylistSingle.vue` | L161-204 |
| `src/composables/useLastFmApi.js` | L3-319 |
| `src/composables/usePlaylistData.js` | L19-194 |
| `src/composables/useCurrentPlayingTrack.js` | L123 |

</details>
</tool-use>

---



---


Proposed unified cache structure that consolidates tracks, loved status, and playcounts:

## Unified Track Data Cache Structure

### Single Cache Key: `user_tracks_${userId}` or `user_tracks_${lastFmUserName}`

**Structure:**
```javascript
{
  // Metadata
  metadata: {
    lastUpdated: timestamp,
    lastFmUserName: string,
    version: 1 // For future migrations
  },
  
  // Tracks indexed by track ID (Spotify track ID)
  tracks: {
    [trackId]: {
      // Spotify track data
      id: string,
      name: string,
      artists: [{ id, name }],
      album: { id, name },
      duration_ms: number,
      track_number: number,
      uri: string,
      
      // User-specific data (updated in cache)
      loved: boolean,
      playcount: number,
      lastPlaycountUpdate: timestamp,
      lastLovedUpdate: timestamp
    }
  },
  
  // Albums indexed by album ID
  albums: {
    [albumId]: {
      trackIds: [trackId1, trackId2, ...], // Ordered track IDs
      lastUpdated: timestamp
    }
  },
  
  // Playlists indexed by playlist ID
  playlists: {
    [playlistId]: {
      albums: {
        [albumId]: {
          trackIds: [trackId1, trackId2, ...], // Tracks in this playlist
          addedAt: timestamp
        }
      },
      lastUpdated: timestamp
    }
  },
  
  // Fast lookup indexes
  indexes: {
    // Track name + artist lookup for loved tracks matching
    byTrackName: {
      [normalizedTrackName]: {
        [normalizedArtistName]: [trackId1, trackId2, ...]
      }
    },
    // Artist lookup
    byArtist: {
      [artistId]: [trackId1, trackId2, ...]
    }
  }
}
```

## Benefits

1. Single source of truth: all track data in one place
2. Incremental updates: loved/playcount updates happen in cache
3. Efficient lookups: multiple indexes for fast queries
4. No API calls after initial fetch: cache-first approach
5. Playlist context preserved: tracks linked to playlists
6. Album context preserved: tracks linked to albums

## Implementation Strategy

### Initial Cache Build (One-time setup)
```javascript
// 1. Fetch all loved tracks from Last.fm
// 2. For each playlist:
//    - Fetch all playlist tracks
//    - For each track, fetch playcount from Last.fm
//    - Store in unified structure
// 3. For albums not in playlists (AlbumView, etc.):
//    - Fetch album tracks
//    - Fetch playcounts
//    - Store in unified structure
```

### Cache Access Functions
```javascript
// Get tracks for an album
getAlbumTracks(albumId) {
  const album = cache.albums[albumId];
  return album.trackIds.map(id => cache.tracks[id]);
}

// Get tracks for a playlist album
getPlaylistAlbumTracks(playlistId, albumId) {
  const playlist = cache.playlists[playlistId];
  const album = playlist.albums[albumId];
  return album.trackIds.map(id => cache.tracks[id]);
}

// Check if track is loved
isTrackLoved(trackId) {
  return cache.tracks[trackId]?.loved || false;
}

// Get track playcount
getTrackPlaycount(trackId) {
  return cache.tracks[trackId]?.playcount || 0;
}

// Update loved status (no API call)
updateTrackLoved(trackId, loved) {
  cache.tracks[trackId].loved = loved;
  cache.tracks[trackId].lastLovedUpdate = Date.now();
  saveCache();
}

// Update playcount (no API call after initial fetch)
updateTrackPlaycount(trackId, playcount) {
  cache.tracks[trackId].playcount = playcount;
  cache.tracks[trackId].lastPlaycountUpdate = Date.now();
  saveCache();
}
```

## Migration Path

1. Create new cache utility: `src/utils/unifiedTrackCache.js`
2. Build initial cache on first load (show progress modal)
3. Update components to use unified cache
4. Keep old caches temporarily for fallback
5. Remove old cache keys after migration

## Cache Size Considerations

- Estimate: ~500 tracks × ~2KB per track = ~1MB
- localStorage limit: ~5-10MB (varies by browser)
- Should fit comfortably

## Incremental Updates

- Loved/unloved: update cache immediately, sync to Last.fm in background
- Playcount: update from Last.fm API only when explicitly refreshed
- New tracks: add to cache when discovered (new album/playlist)

This structure consolidates everything into one cache, supports efficient queries, and enables cache-first updates. Should I draft the implementation code for this unified cache system?

---

_**User (2025-11-19 14:37Z)**_

create a spec for this

---

_**Agent (model default, mode Agent)**_



---


Creating a specification document for the unified track data cache system.


---

<tool-use data-tool-type="generic" data-tool-name="list_dir">
<details>
            <summary>Tool use: **list_dir** • Listed directory undefined • **0** results</summary>
        
No results found
</details>
</tool-use>

---

<tool-use data-tool-type="read" data-tool-name="read_file">
<details><summary>Tool use: **read_file** • Read file: tasks/pipeline-groups-refactor-spec.md</summary>

</details>
</tool-use>

---



---


Creating the unified track cache specification:


---

<tool-use data-tool-type="write" data-tool-name="write">

<details><summary>Tool use: **write** • Edit file: tasks/unified-track-cache-spec.md</summary>

**Chunk 1**
Lines added: 578, lines removed: 1

```diff
@@ -1,1 +1,578 @@
- 
+ # Unified Track Data Cache Specification
+ 
+ ## Overview
+ 
+ This document specifies the design and implementation of a unified, user-specific cache system that consolidates all track-related data (tracks, loved status, playcounts) into a single, highly efficient cache structure. This eliminates data duplication across multiple cache keys and provides a cache-first approach where updates happen in the cache without requiring API calls after the initial fetch.
+ 
+ ## Problem Statement
+ 
+ ### Current Issues
+ 
+ 1. **Cache Fragmentation**: Track data is scattered across multiple cache keys:
+    - &#96;albumTracks_${albumId}&#96; - Full track objects per album
+    - &#96;playlist_tracks_${playlistId}&#96; - Track IDs only per playlist
+    - &#96;lovedTracks_${lastFmUserName}&#96; - Separate array of loved tracks
+    - In-memory &#96;albumTracks.value[albumId]&#96; - Not persisted
+ 
+ 2. **Data Duplication**: Same track data stored multiple times:
+    - Track appears in album cache
+    - Track appears in playlist cache (as ID)
+    - Track metadata duplicated across albums
+ 
+ 3. **Inefficient Updates**: Loved/playcount updates require:
+    - Updating loved tracks array
+    - Recalculating percentages
+    - Multiple cache writes
+ 
+ 4. **API Dependency**: Playcount data fetched on-demand, not cached effectively
+ 
+ 5. **No Single Source of Truth**: Multiple caches can get out of sync
+ 
+ ### Current Cache Structure
+ 
+ &#96;&#96;&#96;javascript
+ // Fragmented across multiple keys:
+ albumTracks_${albumId} = [/* full track objects */]
+ playlist_tracks_${playlistId} = { albumId: { trackId: true } }
+ lovedTracks_${lastFmUserName} = [/* loved track objects */]
+ // Playcounts: fetched on-demand, not cached
+ &#96;&#96;&#96;
+ 
+ ## Solution
+ 
+ ### Core Concept
+ 
+ A **single unified cache** (&#96;user_tracks_${userId}&#96;) that stores:
+ - All track data (Spotify track objects)
+ - Loved status (user-specific, updated in cache)
+ - Playcount data (user-specific, updated in cache)
+ - Album and playlist relationships
+ - Fast lookup indexes
+ 
+ ### Key Principles
+ 
+ 1. **Single Source of Truth**: All track data in one cache entry
+ 2. **Cache-First Updates**: Loved/playcount updates happen in cache, sync to APIs in background
+ 3. **User-Specific**: Cache is per-user (already isolated via localStorage)
+ 4. **Incremental Updates**: New tracks added as discovered, existing tracks updated in place
+ 5. **Efficient Lookups**: Multiple indexes for fast queries by album, playlist, track ID, name, artist
+ 
+ ## Data Structure
+ 
+ ### Cache Key
+ 
+ &#96;&#96;&#96;
+ user_tracks_${userId}
+ &#96;&#96;&#96;
+ 
+ Where &#96;userId&#96; is the Firebase user UID (consistent across sessions).
+ 
+ ### Cache Structure
+ 
+ &#96;&#96;&#96;typescript
+ interface UnifiedTrackCache {
+   // Metadata
+   metadata: {
+     lastUpdated: number;           // Timestamp of last full refresh
+     lastFmUserName: string;        // Last.fm username for this cache
+     userId: string;                // Firebase user ID
+     version: number;               // Cache schema version (for migrations)
+     totalTracks: number;           // Total unique tracks
+     totalAlbums: number;            // Total albums
+     totalPlaylists: number;         // Total playlists
+   };
+ 
+   // Tracks indexed by Spotify track ID (primary data store)
+   tracks: {
+     [trackId: string]: {
+       // Spotify track data (immutable after initial fetch)
+       id: string;
+       name: string;
+       artists: Array&lt;{
+         id: string;
+         name: string;
+       }&gt;;
+       album: {
+         id: string;
+         name: string;
+       };
+       duration_ms: number;
+       track_number: number;
+       uri: string;
+       external_urls: {
+         spotify: string;
+       };
+       
+       // User-specific data (mutable, updated in cache)
+       loved: boolean;                    // Is track loved on Last.fm
+       playcount: number;                 // Last.fm playcount
+       lastPlaycountUpdate: number;       // Timestamp of last playcount fetch
+       lastLovedUpdate: number;           // Timestamp of last loved status update
+       
+       // Relationships
+       albumIds: string[];                // Albums this track appears on
+       playlistIds: string[];             // Playlists this track appears in
+     };
+   };
+ 
+   // Albums indexed by album ID
+   albums: {
+     [albumId: string]: {
+       trackIds: string[];                // Ordered list of track IDs
+       lastUpdated: number;                // When album tracks were last fetched
+       albumTitle: string;                 // For quick access
+       artistName: string;                 // For quick access
+     };
+   };
+ 
+   // Playlists indexed by playlist ID
+   playlists: {
+     [playlistId: string]: {
+       albums: {
+         [albumId: string]: {
+           trackIds: string[];             // Tracks from this album in playlist
+           addedAt: string;                // When album was added to playlist
+         };
+       };
+       lastUpdated: number;                // When playlist tracks were last fetched
+       playlistName: string;               // For quick access
+     };
+   };
+ 
+   // Fast lookup indexes
+   indexes: {
+     // Track name + artist lookup (for loved tracks matching)
+     byTrackName: {
+       [normalizedTrackName: string]: {
+         [normalizedArtistName: string]: string[];  // Array of track IDs
+       };
+     };
+     
+     // Artist lookup
+     byArtist: {
+       [artistId: string]: string[];       // Array of track IDs
+     };
+     
+     // Loved tracks lookup (for quick filtering)
+     lovedTrackIds: string[];              // Array of loved track IDs
+     
+     // Albums by artist (for artist view)
+     albumsByArtist: {
+       [artistId: string]: string[];       // Array of album IDs
+     };
+   };
+ }
+ &#96;&#96;&#96;
+ 
+ ## API Design
+ 
+ ### Core Functions
+ 
+ #### &#96;src/utils/unifiedTrackCache.js&#96;
+ 
+ &#96;&#96;&#96;javascript
+ /**
+  * Initialize or load the unified track cache
+  * @param {string} userId - Firebase user ID
+  * @param {string} lastFmUserName - Last.fm username
+  * @returns {Promise&lt;UnifiedTrackCache&gt;}
+  */
+ export async function loadUnifiedTrackCache(userId, lastFmUserName)
+ 
+ /**
+  * Get tracks for an album
+  * @param {string} albumId - Spotify album ID
+  * @returns {Promise&lt;Array&lt;Track&gt;&gt;}
+  */
+ export async function getAlbumTracks(albumId)
+ 
+ /**
+  * Get tracks for an album within a playlist context
+  * @param {string} playlistId - Spotify playlist ID
+  * @param {string} albumId - Spotify album ID
+  * @returns {Promise&lt;Array&lt;Track&gt;&gt;}
+  */
+ export async function getPlaylistAlbumTracks(playlistId, albumId)
+ 
+ /**
+  * Get all tracks for a playlist
+  * @param {string} playlistId - Spotify playlist ID
+  * @returns {Promise&lt;Array&lt;Track&gt;&gt;}
+  */
+ export async function getPlaylistTracks(playlistId)
+ 
+ /**
+  * Check if a track is loved
+  * @param {string} trackId - Spotify track ID
+  * @returns {boolean}
+  */
+ export function isTrackLoved(trackId)
+ 
+ /**
+  * Get track playcount
+  * @param {string} trackId - Spotify track ID
+  * @returns {number}
+  */
+ export function getTrackPlaycount(trackId)
+ 
+ /**
+  * Update track loved status (cache-first, syncs to Last.fm in background)
+  * @param {string} trackId - Spotify track ID
+  * @param {boolean} loved - New loved status
+  * @returns {Promise&lt;void&gt;}
+  */
+ export async function updateTrackLoved(trackId, loved)
+ 
+ /**
+  * Update track playcount (cache-first)
+  * @param {string} trackId - Spotify track ID
+  * @param {number} playcount - New playcount
+  * @returns {Promise&lt;void&gt;}
+  */
+ export async function updateTrackPlaycount(trackId, playcount)
+ 
+ /**
+  * Add tracks from an album to cache
+  * @param {string} albumId - Spotify album ID
+  * @param {Array&lt;Track&gt;} tracks - Track objects from Spotify API
+  * @param {Object} albumData - Album metadata
+  * @returns {Promise&lt;void&gt;}
+  */
+ export async function addAlbumTracks(albumId, tracks, albumData)
+ 
+ /**
+  * Add tracks from a playlist to cache
+  * @param {string} playlistId - Spotify playlist ID
+  * @param {Array&lt;PlaylistTrackItem&gt;} playlistTracks - Tracks from playlist API
+  * @param {string} playlistName - Playlist name
+  * @returns {Promise&lt;void&gt;}
+  */
+ export async function addPlaylistTracks(playlistId, playlistTracks, playlistName)
+ 
+ /**
+  * Build initial cache from all user playlists and loved tracks
+  * @param {string} userId - Firebase user ID
+  * @param {string} lastFmUserName - Last.fm username
+  * @param {Function} progressCallback - Callback for progress updates
+  * @returns {Promise&lt;void&gt;}
+  */
+ export async function buildInitialCache(userId, lastFmUserName, progressCallback)
+ 
+ /**
+  * Refresh playcounts for tracks (from Last.fm API)
+  * @param {Array&lt;string&gt;} trackIds - Track IDs to refresh
+  * @param {string} lastFmUserName - Last.fm username
+  * @returns {Promise&lt;void&gt;}
+  */
+ export async function refreshPlaycounts(trackIds, lastFmUserName)
+ 
+ /**
+  * Refresh loved tracks (from Last.fm API)
+  * @param {string} lastFmUserName - Last.fm username
+  * @returns {Promise&lt;void&gt;}
+  */
+ export async function refreshLovedTracks(lastFmUserName)
+ 
+ /**
+  * Calculate loved track percentage for an album
+  * @param {string} albumId - Spotify album ID
+  * @returns {Promise&lt;{lovedCount: number, totalCount: number, percentage: number}&gt;}
+  */
+ export async function calculateAlbumLovedPercentage(albumId)
+ 
+ /**
+  * Get cache statistics
+  * @returns {Object} Cache stats
+  */
+ export function getCacheStats()
+ 
+ /**
+  * Clear the unified track cache
+  * @param {string} userId - Firebase user ID
+  * @returns {Promise&lt;void&gt;}
+  */
+ export async function clearUnifiedTrackCache(userId)
+ &#96;&#96;&#96;
+ 
+ ## Implementation Details
+ 
+ ### Cache Initialization
+ 
+ 1. **Check if cache exists** for user
+ 2. **If exists**: Load and validate version
+ 3. **If missing or invalid**: Build initial cache (see below)
+ 
+ ### Initial Cache Build
+ 
+ **Process:**
+ 1. Fetch all loved tracks from Last.fm API
+ 2. For each playlist the user has:
+    - Fetch all playlist tracks from Spotify API
+    - Extract unique tracks
+    - For each track:
+      - Fetch playcount from Last.fm API (if not in loved tracks)
+      - Store track with loved status and playcount
+ 3. Build indexes
+ 4. Save to cache
+ 
+ **Progress Tracking:**
+ - Show progress modal with:
+   - Current step (e.g., "Fetching playlist tracks...")
+   - Progress: X/Y playlists processed
+   - Estimated time remaining
+ 
+ ### Incremental Updates
+ 
+ **When new album is added to playlist:**
+ 1. Fetch album tracks from Spotify API
+ 2. For each track:
+    - Check if already in cache
+    - If new: Fetch playcount, check loved status
+    - Add to cache
+    - Update album and playlist relationships
+ 
+ **When track is loved/unloved:**
+ 1. Update &#96;tracks[trackId].loved&#96; immediately
+ 2. Update &#96;indexes.lovedTrackIds&#96; array
+ 3. Save cache
+ 4. Sync to Last.fm API in background (non-blocking)
+ 
+ **When playcount is refreshed:**
+ 1. Fetch playcount from Last.fm API
+ 2. Update &#96;tracks[trackId].playcount&#96;
+ 3. Update &#96;tracks[trackId].lastPlaycountUpdate&#96;
+ 4. Save cache
+ 
+ ### Index Maintenance
+ 
+ Indexes are updated automatically when tracks are added/updated:
+ 
+ - **byTrackName**: Updated when track name changes
+ - **byArtist**: Updated when track artists change
+ - **lovedTrackIds**: Updated when loved status changes
+ - **albumsByArtist**: Updated when album tracks are added
+ 
+ ### Cache Persistence
+ 
+ - Uses existing &#96;src/utils/cache.js&#96; utilities
+ - Stored in &#96;localStorage&#96; with 24-hour expiration
+ - Cache key: &#96;user_tracks_${userId}&#96;
+ - Format: &#96;{ data: UnifiedTrackCache, timestamp: number }&#96;
+ 
+ ### Cache Size Management
+ 
+ **Estimated Sizes:**
+ - Track object: ~500 bytes
+ - 1000 tracks: ~500 KB
+ - 5000 tracks: ~2.5 MB
+ - 10000 tracks: ~5 MB
+ 
+ **localStorage Limits:**
+ - Chrome/Edge: ~5-10 MB
+ - Firefox: ~10 MB
+ - Safari: ~5 MB
+ 
+ **Optimization Strategies:**
+ 1. Compress track data (remove unused fields)
+ 2. Store only essential metadata
+ 3. Implement LRU eviction for old/unused tracks
+ 4. Split cache if needed (tracks vs. indexes)
+ 
+ ## Migration Strategy
+ 
+ ### Phase 1: Create New Cache System
+ 1. Create &#96;src/utils/unifiedTrackCache.js&#96;
+ 2. Implement core functions
+ 3. Add cache build UI component
+ 
+ ### Phase 2: Parallel Operation
+ 1. New cache system works alongside old caches
+ 2. Components can use either system
+ 3. Build new cache in background
+ 
+ ### Phase 3: Component Migration
+ 1. Update &#96;PlaylistSingle.vue&#96; to use unified cache
+ 2. Update &#96;AlbumItem.vue&#96; to use unified cache
+ 3. Update &#96;TrackList.vue&#96; to use unified cache
+ 4. Update &#96;AlbumView.vue&#96; to use unified cache
+ 5. Update &#96;ArtistView.vue&#96; to use unified cache
+ 
+ ### Phase 4: Cleanup
+ 1. Remove old cache keys:
+    - &#96;albumTracks_${albumId}&#96;
+    - &#96;playlist_tracks_${playlistId}&#96;
+    - &#96;lovedTracks_${lastFmUserName}&#96;
+ 2. Remove old cache utility functions
+ 3. Update documentation
+ 
+ ### Migration Helper
+ 
+ &#96;&#96;&#96;javascript
+ /**
+  * Migrate from old cache system to unified cache
+  * @param {string} userId - Firebase user ID
+  * @param {string} lastFmUserName - Last.fm username
+  * @returns {Promise&lt;void&gt;}
+  */
+ export async function migrateFromOldCache(userId, lastFmUserName) {
+   // 1. Load old caches
+   // 2. Extract track data
+   // 3. Build unified cache structure
+   // 4. Save unified cache
+   // 5. Mark migration as complete
+ }
+ &#96;&#96;&#96;
+ 
+ ## Performance Considerations
+ 
+ ### Lookup Performance
+ 
+ - **Track by ID**: O(1) - Direct object access
+ - **Tracks by album**: O(1) - Direct album lookup, then track IDs
+ - **Tracks by playlist**: O(1) - Direct playlist lookup
+ - **Loved tracks**: O(1) - Pre-computed array
+ - **Track by name+artist**: O(1) - Index lookup
+ 
+ ### Cache Update Performance
+ 
+ - **Add track**: O(1) - Direct assignment
+ - **Update loved**: O(1) - Direct update + index update
+ - **Update playcount**: O(1) - Direct update
+ - **Add album tracks**: O(n) - n = number of tracks
+ 
+ ### Memory Usage
+ 
+ - Track objects: ~500 bytes each
+ - Indexes: ~10-20% overhead
+ - Total: ~600 bytes per track
+ 
+ ### Cache Loading
+ 
+ - Load time: &lt;100ms for 10,000 tracks (JSON parse)
+ - Save time: &lt;200ms for 10,000 tracks (JSON stringify)
+ 
+ ## Error Handling
+ 
+ ### Cache Corruption
+ - Detect invalid cache structure
+ - Fall back to rebuilding cache
+ - Log error for debugging
+ 
+ ### API Failures
+ - Retry failed API calls (3 attempts)
+ - Continue with partial data
+ - Mark tracks as needing refresh
+ 
+ ### Storage Quota
+ - Detect &#96;QuotaExceededError&#96;
+ - Implement LRU eviction
+ - Show user warning
+ - Suggest cache cleanup
+ 
+ ## Testing Strategy
+ 
+ ### Unit Tests
+ - Cache structure validation
+ - Index building
+ - Lookup functions
+ - Update functions
+ 
+ ### Integration Tests
+ - Cache build process
+ - Incremental updates
+ - Migration from old cache
+ - Error scenarios
+ 
+ ### Performance Tests
+ - Cache load time
+ - Lookup performance
+ - Update performance
+ - Memory usage
+ 
+ ## User Experience
+ 
+ ### Initial Cache Build
+ - Show progress modal
+ - Allow cancellation
+ - Resume on next session if interrupted
+ - Estimate completion time
+ 
+ ### Cache Updates
+ - Silent background updates
+ - Show toast notifications for loved/unloved
+ - Progress indicator for playcount refresh
+ 
+ ### Cache Management
+ - Add to existing Cache Manager component
+ - Show cache size
+ - Allow manual refresh
+ - Allow cache clearing
+ 
+ ## Future Enhancements
+ 
+ 1. **Incremental Sync**: Only fetch new/updated tracks
+ 2. **Background Sync**: Periodic updates in background
+ 3. **Compression**: Compress cache data for storage
+ 4. **Cloud Backup**: Sync cache to Firebase (optional)
+ 5. **Multi-Device**: Share cache across devices
+ 6. **Analytics**: Track cache hit rates, performance metrics
+ 
+ ## Dependencies
+ 
+ - &#96;src/utils/cache.js&#96; - Cache storage utilities
+ - &#96;src/composables/useUserSpotifyApi.js&#96; - Spotify API access
+ - &#96;src/composables/useLastFmApi.js&#96; - Last.fm API access
+ - &#96;src/composables/useUserData.js&#96; - User data access
+ 
+ ## Timeline
+ 
+ ### Week 1: Core Implementation
+ - Create unified cache utility
+ - Implement core functions
+ - Build initial cache functionality
+ 
+ ### Week 2: Component Integration
+ - Migrate PlaylistSingle.vue
+ - Migrate AlbumItem.vue
+ - Migrate TrackList.vue
+ 
+ ### Week 3: Additional Views
+ - Migrate AlbumView.vue
+ - Migrate ArtistView.vue
+ - Update other components
+ 
+ ### Week 4: Testing &amp; Cleanup
+ - Comprehensive testing
+ - Remove old cache system
+ - Documentation updates
+ 
+ ## Success Metrics
+ 
+ 1. **Cache Hit Rate**: &gt;95% of track lookups from cache
+ 2. **API Calls Reduced**: &lt;10% of previous API calls
+ 3. **Load Time**: &lt;200ms for cache load
+ 4. **Update Time**: &lt;50ms for loved/playcount updates
+ 5. **Storage Usage**: &lt;5MB for typical user
+ 
+ ## Risks &amp; Mitigations
+ 
+ ### Risk: Cache Size Too Large
+ - **Mitigation**: Implement LRU eviction, compress data
+ 
+ ### Risk: Cache Corruption
+ - **Mitigation**: Version validation, automatic rebuild
+ 
+ ### Risk: Migration Issues
+ - **Mitigation**: Parallel operation, gradual migration
+ 
+ ### Risk: Performance Degradation
+ - **Mitigation**: Performance testing, optimization
+ 
+ ## Open Questions
+ 
+ 1. Should we compress track data to reduce size?
+ 2. Should we implement cache versioning for schema changes?
+ 3. Should we sync cache to Firebase for backup?
+ 4. How should we handle tracks that are removed from playlists?
+ 5. Should we implement cache sharding for very large caches?
+ 
```

</details>

</tool-use>

---



---


Created the unified track cache specification. Creating an initial todo list to track implementation:


---

<tool-use data-tool-type="task" data-tool-name="todo_write">
<details><summary>Tool use: **todo_write** • Todo List</summary>

- [ ] Create unifiedTrackCache.js utility with core cache structure and load/save functions
- [ ] Implement track lookup functions (getAlbumTracks, getPlaylistTracks, isTrackLoved, getTrackPlaycount)
- [ ] Implement cache update functions (updateTrackLoved, updateTrackPlaycount, addAlbumTracks, addPlaylistTracks)
- [ ] Implement initial cache build functionality with progress tracking
- [ ] Create cache build UI component with progress modal
- [ ] Migrate PlaylistSingle.vue to use unified cache
- [ ] Migrate AlbumItem.vue and TrackList.vue to use unified cache
- [ ] Migrate AlbumView.vue and ArtistView.vue to use unified cache
- [ ] Create migration helper to convert old cache format to unified cache
- [ ] Remove old cache keys and utility functions after migration complete

</details>
</tool-use>

---

<tool-use data-tool-type="generic" data-tool-name="read_lints">
<details>
          <summary>Tool use: **read_lints** • Read lints for 1 file</summary>
      
Lint paths:

- `tasks/unified-track-cache-spec.md`

Lint results


**No lint errors found**
</details>
</tool-use>

---



---


Created the unified track cache specification at `tasks/unified-track-cache-spec.md`.

## Specification Highlights

The spec includes:

1. **Problem Statement** - Current cache fragmentation and issues
2. **Solution Design** - Unified cache structure with TypeScript interfaces
3. **Data Structure** - Cache schema with tracks, albums, playlists, and indexes
4. **API Design** - Function signatures for all cache operations
5. **Implementation Details** - Initial build, incremental updates, index maintenance
6. **Migration Strategy** - 4-phase approach with parallel operation
7. **Performance Considerations** - Lookup times, memory usage, optimization strategies
8. **Testing Strategy** - Unit, integration, and performance tests
9. **User Experience** - Progress tracking, error handling, cache management
10. **Timeline** - 4-week implementation plan

The spec also includes:
- Cache size estimates and localStorage limits
- Error handling strategies
- Success metrics
- Risk mitigation
- Open questions for discussion

A todo list has been created to track the 10 implementation tasks. The spec is ready for review and can serve as the blueprint for implementation.

---

