<!-- Generated by SpecStory, Markdown v2.1.0 -->

<!-- cursor Session 2a3a8935-3eb2-4d0d-9447-e9e1a0f6641d (2025-10-11 17:43Z) -->

# Evaluate Last.fm API calls on playlist page (2025-10-11 17:43Z)

_**User (2025-10-11 09:30Z)**_

we need to seriously look into the amount of api calls we're making to lastfm on the playlistsingle page. especially (probably) the tracklist

---

_**Agent (model default, mode Ask)**_

<think><details><summary>Thought Process</summary>
The user is concerned about the number of API calls being made to Last.fm on the PlaylistSingle page, particularly in the TrackList component. Let me investigate this.

First, I should look at:
1. The PlaylistSingle view to see what data it's fetching
2. The TrackList component to see what Last.fm API calls it makes
3. The useLastFmApi composable to understand the API calls
4. Check if there's any caching in place

Let me start by reading the relevant files.</details></think>

---

I'll investigate the Last.fm API calls on the PlaylistSingle page and TrackList component to identify potential issues.

---

<tool-use data-tool-type="read" data-tool-name="read_file">
<details><summary>Tool use: **read_file** • Read file: src/views/playlists/PlaylistSingle.vue</summary>

</details>
</tool-use>

---

<tool-use data-tool-type="read" data-tool-name="read_file">
<details><summary>Tool use: **read_file** • Read file: src/components/TrackList.vue</summary>

</details>
</tool-use>

---

<tool-use data-tool-type="read" data-tool-name="read_file">
<details><summary>Tool use: **read_file** • Read file: src/composables/useLastFmApi.js</summary>

</details>
</tool-use>

---

<think><details><summary>Thought Process</summary>
Now let me analyze the issue with Last.fm API calls on the PlaylistSingle page, especially in the TrackList component.

From what I can see:

**In TrackList.vue (lines 66-108):**
The component calls `fetchTrackPlaycounts()` which:
1. Makes a separate API call for EACH track to get its playcount using `getTrackInfo(track.name, props.albumArtist, props.lastFmUserName)` 
2. This is called via a watch on lines 130-137 whenever `lastFmUserName`, `albumArtist`, or `tracks` change

**In PlaylistSingle.vue:**
1. Shows 20 albums per page (line 285: `itemsPerPage.ref(20)`)
2. When `showTracklists` is enabled, it fetches tracks for ALL albums on the current page (lines 69-90)
3. Each AlbumItem component gets a TrackList which makes individual API calls for each track

**The Problem:**
If you have 20 albums on a page, and each album has say 10 tracks on average, that's:
- 20 albums × 10 tracks = 200 individual Last.fm API calls for playcount data
- This is happening sequentially for each album (though `Promise.all` is used within each album)
- Every time you change pages, load tracklists, or change the sort order

**Potential issues:**
1. **Rate limiting**: Last.fm has rate limits and 200 API calls could hit those limits
2. **Performance**: 200 API calls takes a long time to complete
3. **No caching**: The playcount data doesn't appear to be cached anywhere
4. **Redundant calls**: If you navigate away and come back, all calls are made again

**Solutions would include:**
1. Cache the playcount data with a reasonable TTL (like 1 hour or 24 hours)


2. Implement strategic API request management to mitigate rate limiting and performance challenges. I'll explore techniques like introducing controlled delays between requests, creating a batching mechanism, and implementing intelligent fetching strategies that minimize unnecessary API interactions.

The approach involves carefully throttling requests, potentially using a queue system that spaces out API calls and prevents overwhelming the Last.fm service. By introducing intelligent request management, we can significantly reduce the load and improve overall application responsiveness.

Implementing a smart caching layer would allow storing playcount data temporarily, reducing redundant network requests and improving user experience. The goal is to create a more efficient data retrieval process that respects API constraints while providing a smooth, responsive interface.</details></think>

---

Looking at the code, I can see the issue clearly. When you enable tracklists on the PlaylistSingle page, it's making a **massive number of Last.fm API calls**:

## The Problem

**In `TrackList.vue` (lines 66-108):**
- For **every album**, it calls `fetchTrackPlaycounts()`
- This makes a **separate Last.fm API call for EACH track** to get playcount data using `getTrackInfo()`
- Uses `Promise.all` to fetch all tracks in parallel (which could hit rate limits)

**On PlaylistSingle page:**
- Shows 20 albums per page
- If each album has ~10 tracks, that's **200 Last.fm API calls per page load**
- This happens every time you:
  - Toggle tracklists on
  - Change pages
  - Change sort order
  - Refresh the page

## Key Issues

1. **No caching** - Playcount data isn't cached, so same tracks are fetched repeatedly
2. **Rate limiting** - 200+ concurrent API calls likely hits Last.fm's rate limits
3. **Performance** - Loading 200+ API responses takes significant time
4. **Redundant calls** - Navigate away and back = all calls made again

## Recommended Solutions

1. **Add caching for track playcounts** (24 hour TTL would be reasonable for playcount data)
   ```javascript
   const cacheKey = `trackPlaycount_${props.lastFmUserName}_${artist}_${trackName}`;
   ```

2. **Batch the requests with delays** - Add small delays between track fetches to avoid rate limiting:
   ```javascript
   for (const track of props.tracks) {
     // fetch playcount
     await new Promise(resolve => setTimeout(resolve, 50)); // 50ms delay
   }
   ```

3. **Lazy load playcounts** - Only fetch when the tracklist is actually expanded/visible

4. **Backend batching** - Create a backend endpoint that can fetch multiple track playcounts in one request, managing rate limits server-side

5. **Make playcounts optional** - Consider making the playcount feature opt-in or only showing for the currently playing album

The biggest win would be **caching** + **rate limiting the requests**. The current implementation with `Promise.all` tries to fire off all 200+ requests simultaneously, which is overwhelming the API.

---

