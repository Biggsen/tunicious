<!-- Generated by SpecStory, Markdown v2.1.0 -->

<!-- cursor Session 758104d5-8d89-4fc8-ba71-3306a0f23bd1 (2025-04-12 20:55Z) -->

# Refactoring useAlbumsData for Improved Logic (2025-04-12 20:55Z)

_**User (2025-04-12 20:56Z)**_

considering all the albums related data here, is there some logic we can move into useAlbumsData or possibly refactor that composable to suit better?

---

_**Agent (mode Ask)**_

Let me analyze the code and suggest potential refactoring opportunities for `useAlbumsData`. I see several opportunities for improvement:

1. **Album Loading Logic**: In `AlbumView.vue`, there's complex album loading logic in the `onMounted` hook that could be moved to `useAlbumsData`. This includes:
   - Token initialization
   - Album mapping checks
   - Album and tracks fetching
   - Album existence checks
   - Current playlist info fetching

2. **Album Saving/Updating Logic**: The `saveAlbum` and `updateAlbumData` functions in `AlbumView.vue` contain complex Firestore operations that could be abstracted into `useAlbumsData`.

3. **Album Mapping Integration**: The mapping-related checks are scattered across the component. We could better integrate this with the album data management.

Here's a suggested refactoring for `useAlbumsData`:

```typescript
// useAlbumsData.js
import { ref } from 'vue';
import { doc, getDoc, setDoc, collection, query, where, getDocs, serverTimestamp } from 'firebase/firestore';
import { db } from '../firebase';
import { useCurrentUser } from 'vuefire';
import { useAlbumMappings } from './useAlbumMappings';
import { useToken } from '@utils/auth';
import { getAlbum, getAlbumTracks } from '@utils/api';

export function useAlbumsData() {
  // ... existing refs and imports ...

  /**
   * Loads complete album data including Spotify data, mapping status, and database state
   */
  const loadCompleteAlbumData = async (albumId) => {
    if (!user.value) return null;

    try {
      loading.value = true;
      error.value = null;

      const { token, initializeToken } = useToken();
      const { isAlternateId, getPrimaryId } = useAlbumMappings();

      // Initialize token if needed
      if (!token.value) {
        await initializeToken();
      }

      // Check mapping status
      const isMappedAlbum = await isAlternateId(albumId);
      const primaryId = isMappedAlbum ? await getPrimaryId(albumId) : albumId;
      
      // Fetch Spotify data
      const [albumData, tracksData] = await Promise.all([
        getAlbum(token.value, albumId),
        fetchAllTracks(albumId, token.value)
      ]);

      // Check database existence
      const albumRef = doc(db, 'albums', primaryId);
      const albumDoc = await getDoc(albumRef);
      const exists = albumDoc.exists();

      // Get current playlist info if exists
      const playlistInfo = exists ? await getCurrentPlaylistInfo(primaryId) : null;

      return {
        spotifyData: albumData,
        tracks: tracksData,
        isMappedAlbum,
        primaryAlbumId: primaryId,
        exists,
        playlistInfo,
        needsUpdate: await checkIfNeedsUpdate(primaryId)
      };
    } catch (e) {
      console.error('Error loading complete album data:', e);
      error.value = e.message || 'Failed to load album data';
      return null;
    } finally {
      loading.value = false;
    }
  };

  /**
   * Checks if album data needs updating
   */
  const checkIfNeedsUpdate = async (albumId) => {
    if (!user.value) return false;
    
    const albumRef = doc(db, 'albums', albumId);
    const albumDoc = await getDoc(albumRef);
    
    if (!albumDoc.exists()) return false;
    
    const albumData = albumDoc.data();
    const userData = albumData.userEntries?.[user.value.uid];
    
    return !albumData.albumTitle || 
           !albumData.artistName || 
           !userData?.playlistHistory?.some(entry => entry.playlistName) ||
           userData?.playlistHistory?.some(entry => entry.playlistName === 'Unknown Playlist');
  };

  /**
   * Saves or updates album in a playlist
   */
  const saveAlbumToPlaylist = async (albumId, playlistId, albumData) => {
    if (!user.value || !albumData) return null;

    try {
      loading.value = true;
      error.value = null;

      // Get playlist data
      const playlistsRef = collection(db, 'playlists');
      const q = query(playlistsRef, where('playlistId', '==', playlistId));
      const querySnapshot = await getDocs(q);
      
      if (querySnapshot.empty) {
        throw new Error('Playlist not found');
      }

      const playlistData = querySnapshot.docs[0].data();
      const now = new Date();

      // Get existing album data
      const existingData = await fetchAlbumData(albumId);

      // Create new playlist history entry
      const newEntry = {
        playlistId: playlistData.playlistId,
        playlistName: playlistData.name,
        category: playlistData.category,
        type: playlistData.type,
        priority: playlistData.priority,
        addedAt: now,
        removedAt: null
      };

      // Update album document
      const albumRef = doc(db, 'albums', albumId);
      await setDoc(albumRef, {
        albumTitle: albumData.name,
        artistName: albumData.artists[0].name,
        userEntries: {
          [user.value.uid]: {
            playlistHistory: existingData?.playlistHistory 
              ? [...existingData.playlistHistory.filter(h => h.removedAt !== null), newEntry]
              : [newEntry],
            createdAt: existingData?.createdAt || serverTimestamp(),
            updatedAt: serverTimestamp()
          }
        }
      }, { merge: true });

      return await getCurrentPlaylistInfo(albumId);
    } catch (e) {
      console.error('Error saving album to playlist:', e);
      error.value = e.message || 'Failed to save album';
      return null;
    } finally {
      loading.value = false;
    }
  };

  // ... existing methods ...

  return {
    albumData,
    loading,
    error,
    loadCompleteAlbumData,
    saveAlbumToPlaylist,
    checkIfNeedsUpdate,
    // ... existing returned methods ...
  };
}
```

This refactoring would simplify the `AlbumView.vue` component significantly. The component would then only need to:

1. Call `loadCompleteAlbumData` on mount
2. Handle the UI state based on the returned data
3. Call `saveAlbumToPlaylist` when needed

Benefits of this refactoring:
1. Better separation of concerns - data management logic is moved to the composable
2. Reduced code duplication
3. More reusable album-related functionality
4. Simpler component logic
5. Better testability of the data management logic
6. Centralized error handling
7. More consistent data loading patterns

Would you like me to show how the `AlbumView.vue` component would look after this refactoring?

---

_**User (2025-04-12 21:00Z)**_

reconsider the above with @useAlbumsData.js  and @useAlbumMappings.js 

---

_**Agent (mode Ask)**_

Looking at both composables together, I can see some opportunities for better integration and separation of concerns. Here's my refined suggestion:

1. First, let's create a new interface for album data types (could be in a separate types file):

```typescript
// types/album.ts
export interface SpotifyAlbumData {
  id: string;
  name: string;
  artists: { id: string; name: string }[];
  images: { url: string }[];
}

export interface AlbumMappingInfo {
  isMappedAlbum: boolean;
  primaryAlbumId: string | null;
}

export interface AlbumPlaylistData {
  playlistHistory: PlaylistHistoryEntry[];
  createdAt: Date;
  updatedAt: Date;
}

export interface CompleteAlbumData {
  spotifyData: SpotifyAlbumData | null;
  tracks: any[]; // Could be more specific with Spotify track type
  mappingInfo: AlbumMappingInfo;
  firestoreData: AlbumPlaylistData | null;
  currentPlaylistInfo: PlaylistHistoryEntry | null;
  needsUpdate: boolean;
}
```

2. Then, let's refactor both composables to work together better:

```typescript
// composables/useAlbumData.js
import { ref } from 'vue';
import { useCurrentUser } from 'vuefire';
import { useAlbumMappings } from './useAlbumMappings';
import { useToken } from '@utils/auth';
import { getAlbum, getAlbumTracks } from '@utils/api';
import { doc, getDoc, setDoc, collection, query, where, getDocs, serverTimestamp } from 'firebase/firestore';
import { db } from '../firebase';

export function useAlbumsData() {
  const user = useCurrentUser();
  const { token, initializeToken } = useToken();
  const albumMappings = useAlbumMappings();
  
  const loading = ref(false);
  const error = ref(null);

  /**
   * Fetches all tracks for an album with retry logic
   */
  const fetchAllTracks = async (albumId) => {
    let allTracks = [];
    let offset = 0;
    const limit = 50;
    let retryCount = 0;
    const maxRetries = 3;

    while (true) {
      try {
        if (!token.value) await initializeToken();

        const response = await getAlbumTracks(albumId, limit, offset);
        allTracks = [...allTracks, ...response.items];
        
        if (response.items.length < limit) break;
        
        offset += limit;
        retryCount = 0;
      } catch (err) {
        if (err.status === 401 || err.status === 403) {
          await initializeToken();
          continue;
        }
        
        if (err.status >= 500 && retryCount < maxRetries) {
          retryCount++;
          await new Promise(resolve => setTimeout(resolve, 1000 * retryCount));
          continue;
        }
        
        throw err;
      }
    }
    
    return allTracks;
  };

  /**
   * Loads complete album data including Spotify, mapping, and Firestore data
   */
  const loadAlbumData = async (albumId) => {
    if (!user.value) return null;

    try {
      loading.value = true;
      error.value = null;

      // 1. Get mapping information
      const mappingInfo = await albumMappings.getAlbumMappingInfo(albumId);
      const effectiveAlbumId = mappingInfo.primaryAlbumId || albumId;

      // 2. Fetch Spotify data and tracks in parallel
      const [spotifyData, tracks] = await Promise.all([
        getAlbum(token.value, albumId),
        fetchAllTracks(albumId)
      ]);

      // 3. Get Firestore data
      const firestoreData = await getFirestoreAlbumData(effectiveAlbumId);
      
      // 4. Get current playlist info
      const currentPlaylistInfo = firestoreData?.playlistHistory.find(
        entry => entry.removedAt === null
      );

      return {
        spotifyData,
        tracks,
        mappingInfo,
        firestoreData,
        currentPlaylistInfo,
        needsUpdate: await checkIfNeedsUpdate(effectiveAlbumId, spotifyData)
      };
    } catch (e) {
      console.error('Error loading album data:', e);
      error.value = e.message;
      return null;
    } finally {
      loading.value = false;
    }
  };

  /**
   * Gets album data from Firestore
   */
  const getFirestoreAlbumData = async (albumId) => {
    const albumDoc = await getDoc(doc(db, 'albums', albumId));
    if (!albumDoc.exists()) return null;

    const data = albumDoc.data();
    const userData = data.userEntries?.[user.value.uid];
    
    return userData ? {
      ...userData,
      playlistHistory: userData.playlistHistory.map(entry => ({
        ...entry,
        addedAt: entry.addedAt?.toDate?.() || entry.addedAt,
        removedAt: entry.removedAt?.toDate?.() || entry.removedAt
      }))
    } : null;
  };

  /**
   * Saves or updates album in playlist
   */
  const saveAlbumToPlaylist = async (albumId, playlistId, spotifyData) => {
    if (!user.value || !spotifyData) return null;

    try {
      loading.value = true;
      error.value = null;

      // Get mapping info to ensure we're using the correct ID
      const mappingInfo = await albumMappings.getAlbumMappingInfo(albumId);
      const effectiveAlbumId = mappingInfo.primaryAlbumId || albumId;

      // Get playlist data
      const playlistData = await getPlaylistData(playlistId);
      if (!playlistData) throw new Error('Playlist not found');

      // Get existing album data
      const existingData = await getFirestoreAlbumData(effectiveAlbumId);

      // Create new entry and update document
      const newEntry = createPlaylistHistoryEntry(playlistData);
      await updateAlbumDocument(effectiveAlbumId, spotifyData, existingData, newEntry);

      return newEntry;
    } catch (e) {
      console.error('Error saving album to playlist:', e);
      error.value = e.message;
      return null;
    } finally {
      loading.value = false;
    }
  };

  // Helper functions...

  return {
    loading,
    error,
    loadAlbumData,
    saveAlbumToPlaylist,
    getFirestoreAlbumData
  };
}
```

3. And refine the album mappings composable:

```typescript
// composables/useAlbumMappings.js
export function useAlbumMappings() {
  const loading = ref(false);
  const error = ref(null);

  /**
   * Gets complete mapping information for an album
   */
  const getAlbumMappingInfo = async (albumId) => {
    try {
      loading.value = true;
      error.value = null;

      const isMappedAlbum = await isAlternateId(albumId);
      const primaryAlbumId = isMappedAlbum ? await getPrimaryId(albumId) : null;

      return {
        isMappedAlbum,
        primaryAlbumId
      };
    } catch (e) {
      console.error('Error getting album mapping info:', e);
      error.value = e.message;
      return {
        isMappedAlbum: false,
        primaryAlbumId: null
      };
    } finally {
      loading.value = false;
    }
  };

  // ... existing methods ...

  return {
    loading,
    error,
    getAlbumMappingInfo,
    createMapping,
    // ... other existing methods ...
  };
}
```

Key improvements in this refactoring:

1. **Better Integration**: The composables now work together more seamlessly, with `useAlbumsData` using `useAlbumMappings` in a more structured way.

2. **Clear Responsibilities**:
   - `useAlbumsData`: Handles album data loading, saving, and updates
   - `useAlbumMappings`: Focuses purely on album ID mapping operations

3. **Simplified Interface**: The `loadAlbumData` method now returns a complete, well-structured object with all necessary data.

4. **Better Error Handling**: Consistent error handling across both composables.

5. **Type Safety**: With proper TypeScript interfaces (if using TypeScript).

6. **Reduced Duplication**: Common operations are extracted into helper functions.

7. **Cleaner Component Integration**: Components using these composables will have a much simpler interface to work with.

This would allow the `AlbumView.vue` component to be much simpler:

```vue
<script setup>
import { onMounted, ref } from 'vue';
import { useRoute } from 'vue-router';
import { useAlbumsData } from '@composables/useAlbumsData';

const route = useRoute();
const { loadAlbumData, saveAlbumToPlaylist, loading, error } = useAlbumsData();

const albumData = ref(null);

onMounted(async () => {
  albumData.value = await loadAlbumData(route.params.id);
});

const handleSaveToPlaylist = async (playlistId) => {
  if (!albumData.value?.spotifyData) return;
  
  const result = await saveAlbumToPlaylist(
    route.params.id,
    playlistId,
    albumData.value.spotifyData
  );
  
  if (result) {
    albumData.value = await loadAlbumData(route.params.id);
  }
};
</script>
```

Would you like me to elaborate on any part of this refactoring?

---

