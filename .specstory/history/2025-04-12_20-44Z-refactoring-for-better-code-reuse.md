<!-- Generated by SpecStory, Markdown v2.1.0 -->

<!-- cursor Session f9642483-b3a7-4234-84bc-d95b3deac24f (2025-04-12 20:44Z) -->

# Refactoring for Better Code Reuse (2025-04-12 20:44Z)

_**User (2025-04-12 20:46Z)**_

suggest refactors or better reuse in this file. With /composables and /components in mind

---

_**Agent (mode Ask)**_

I'll analyze the code and suggest potential refactors and better reuse opportunities, focusing on composables and components.

1. **Album Data Management Composable**
The file currently handles a lot of album-related logic directly. We could extract this into a dedicated composable `useAlbumDetails`:

```typescript
// composables/useAlbumDetails.js
export function useAlbumDetails(albumId) {
  const album = ref(null);
  const tracks = ref([]);
  const loading = ref(true);
  const error = ref(null);

  const fetchAlbumDetails = async () => {
    // Move album fetching logic here
    // Including token management, album data, and tracks
  };

  const checkAlbumExists = async () => {
    // Move album existence check logic here
  };

  return {
    album,
    tracks,
    loading,
    error,
    fetchAlbumDetails,
    checkAlbumExists
  };
}
```

2. **Album Mapping Logic Composable**
The mapping-related functionality could be enhanced in its own composable:

```typescript
// composables/useAlbumMapping.js
export function useAlbumMapping(albumId) {
  const searchResults = ref([]);
  const isSearching = ref(false);
  const searchError = ref(null);
  const isMappedAlbum = ref(false);
  const primaryAlbumId = ref(null);

  // Move all mapping-related functions here
  const checkExistingAlbum = async () => { /* ... */ };
  const createNewMapping = async () => { /* ... */ };

  return {
    searchResults,
    isSearching,
    searchError,
    isMappedAlbum,
    primaryAlbumId,
    checkExistingAlbum,
    createNewMapping
  };
}
```

3. **Playlist Management Composable**
The playlist-related functionality could be extracted:

```typescript
// composables/usePlaylistManagement.js
export function usePlaylistManagement(albumId) {
  const saving = ref(false);
  const currentPlaylistInfo = ref(null);
  const updating = ref(false);
  const needsUpdate = ref(false);

  const saveToPlaylist = async () => { /* ... */ };
  const updatePlaylistData = async () => { /* ... */ };
  const checkUpdateNeeded = async () => { /* ... */ };

  return {
    saving,
    currentPlaylistInfo,
    updating,
    needsUpdate,
    saveToPlaylist,
    updatePlaylistData,
    checkUpdateNeeded
  };
}
```

4. **Component Splitting**
The template could be split into more focused components:

```typescript
// components/album/AlbumCover.vue
// For the album cover and related actions

// components/album/AlbumInfo.vue
// For album metadata display

// components/album/AlbumActions.vue
// For action buttons and status
```

5. **Error Handling Composable**
Create a reusable error handling composable:

```typescript
// composables/useErrorHandler.js
export function useErrorHandler() {
  const error = ref(null);
  
  const handleError = (err, customMessage = '') => {
    console.error(err);
    error.value = err.message || customMessage;
  };

  return {
    error,
    handleError
  };
}
```

6. **Loading State Management**
Create a reusable loading state composable:

```typescript
// composables/useLoadingState.js
export function useLoadingState() {
  const loading = ref(false);
  
  const withLoading = async (fn) => {
    loading.value = true;
    try {
      await fn();
    } finally {
      loading.value = false;
    }
  };

  return {
    loading,
    withLoading
  };
}
```

These refactors would provide several benefits:
- Better separation of concerns
- More reusable code across the application
- Easier testing of individual pieces
- Reduced complexity in the main component
- More maintainable code structure
- Better error handling
- Consistent loading state management

The main `AlbumView.vue` would become much simpler:

```typescript
<script setup>
import { useAlbumDetails } from '@/composables/useAlbumDetails';
import { useAlbumMapping } from '@/composables/useAlbumMapping';
import { usePlaylistManagement } from '@/composables/usePlaylistManagement';
import { useLoadingState } from '@/composables/useLoadingState';
import { useErrorHandler } from '@/composables/useErrorHandler';

const route = useRoute();
const albumId = route.params.id;

const { album, tracks, fetchAlbumDetails } = useAlbumDetails(albumId);
const { searchResults, checkExistingAlbum, createNewMapping } = useAlbumMapping(albumId);
const { currentPlaylistInfo, saveToPlaylist, updatePlaylistData } = usePlaylistManagement(albumId);
const { loading, withLoading } = useLoadingState();
const { error, handleError } = useErrorHandler();

onMounted(() => {
  withLoading(async () => {
    try {
      await fetchAlbumDetails();
    } catch (err) {
      handleError(err, 'Failed to load album details');
    }
  });
});
</script>
```

This would make the code more maintainable, reusable, and easier to test. Each piece of functionality would be isolated and could be used independently across different parts of the application.

---

_**User (2025-04-12 20:54Z)**_

the first suggestion seems to not consider @useAlbumsData.js . or am I wrong?

---

_**Agent (mode Ask)**_

You're absolutely right - I apologize for not considering the existing `useAlbumsData.js` composable more carefully in my first suggestion. Looking at both files now:

1. **Current State**
`useAlbumsData.js` already handles:
- Album data fetching
- Current playlist info
- Album searching (exact and fuzzy)
- Loading and error states
- User-specific album data

2. **Refined Refactoring Suggestions**

Instead of creating a new `useAlbumDetails`, we should:

A. **Enhance useAlbumsData.js** with Spotify-specific functionality:
```typescript
// composables/useAlbumsData.js
export function useAlbumsData() {
  // ... existing code ...

  // Add new functions for Spotify data
  const fetchSpotifyAlbumDetails = async (albumId, token) => {
    // Move the Spotify API calls here from AlbumView
    // (getAlbum and fetchAllTracks logic)
  };

  return {
    // ... existing returns ...
    fetchSpotifyAlbumDetails,
  };
}
```

B. **Create usePlaylistManagement** (this is still valid from previous suggestion):
```typescript
// composables/usePlaylistManagement.js
export function usePlaylistManagement(albumId) {
  const { getCurrentPlaylistInfo } = useAlbumsData();
  const saving = ref(false);
  const updating = ref(false);
  const needsUpdate = ref(false);

  const checkIfNeedsUpdate = async () => {
    // Move the update check logic here
  };

  const saveAlbum = async (playlistId, albumData) => {
    // Move the save logic here
  };

  const updateAlbumData = async (playlistId) => {
    // Move the update logic here
  };

  return {
    saving,
    updating,
    needsUpdate,
    checkIfNeedsUpdate,
    saveAlbum,
    updateAlbumData
  };
}
```

C. **Create useSpotifyToken** (to handle token management):
```typescript
// composables/useSpotifyToken.js
export function useSpotifyToken() {
  const token = ref(null);
  const tokenError = ref(null);

  const initializeToken = async () => {
    // Move token initialization logic here
  };

  const refreshToken = async () => {
    // Add token refresh logic
  };

  return {
    token,
    tokenError,
    initializeToken,
    refreshToken
  };
}
```

Then the `AlbumView.vue` would become:

```typescript
<script setup>
import { ref, onMounted } from 'vue';
import { useRoute } from 'vue-router';
import { useAlbumsData } from '@/composables/useAlbumsData';
import { usePlaylistManagement } from '@/composables/usePlaylistManagement';
import { useSpotifyToken } from '@/composables/useSpotifyToken';
import { useAlbumMappings } from '@/composables/useAlbumMappings';

const route = useRoute();
const albumId = route.params.id;

const { 
  fetchAlbumData, 
  fetchSpotifyAlbumDetails,
  loading: albumLoading,
  error: albumError 
} = useAlbumsData();

const {
  saving,
  updating,
  needsUpdate,
  checkIfNeedsUpdate,
  saveAlbum,
  updateAlbumData
} = usePlaylistManagement(albumId);

const { token, initializeToken } = useSpotifyToken();

const album = ref(null);
const tracks = ref([]);

onMounted(async () => {
  if (!token.value) {
    await initializeToken();
  }

  try {
    // Fetch both Spotify and database data
    const [spotifyData, dbData] = await Promise.all([
      fetchSpotifyAlbumDetails(albumId, token.value),
      fetchAlbumData(albumId)
    ]);

    album.value = spotifyData.album;
    tracks.value = spotifyData.tracks;

    if (dbData) {
      await checkIfNeedsUpdate();
    }
  } catch (err) {
    console.error('Error in AlbumView:', err);
  }
});
</script>
```

This refactoring approach:
1. Builds upon the existing `useAlbumsData` composable instead of duplicating functionality
2. Separates concerns more clearly between database operations and Spotify API operations
3. Extracts token management into its own composable
4. Maintains the playlist management separation
5. Reduces code duplication
6. Makes the component code more focused on composition and less on implementation

The main difference from my previous suggestion is that we're not creating a new album data composable, but rather extending the existing one and creating complementary composables for other functionalities. This approach better respects the existing codebase structure while still achieving better separation of concerns.

---

