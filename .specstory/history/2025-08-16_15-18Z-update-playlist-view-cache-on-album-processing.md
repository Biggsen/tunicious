<!-- Generated by SpecStory, Markdown v2.1.0 -->

<!-- cursor Session 047820fe-28d1-46af-aae8-d1a0388b7ebc (2025-08-16 15:18Z) -->

# Update playlist view cache on album processing (2025-08-16 15:18Z)

_**User (2025-08-15 16:41Z)**_

when I've processed an album from a playlist, I need the playlistView cahce to be updated when I get to that page. right now I have to press reload every time. can we do something about that?

---

_**Agent (model default, mode Ask)**_

I'll help you fix the cache invalidation issue when processing albums. Let me first examine the current cache implementation and playlist view to understand how the caching works.


---

<tool-use data-tool-type="search" data-tool-name="codebase_search">
<details>
                <summary>Tool use: **codebase_search** • Searched codebase "playlistView cache invalidation when processing albums" • **14** results</summary>
            
| File | Lines |
|------|-------|
| `src/views/playlists/PlaylistSingle.vue` | L259-306 |
| `src/views/music/ArtistView.vue` | L51-103 |
| `src/views/playlists/PlaylistSingle.vue` | L472-528 |
| `src/views/playlists/PlaylistView.vue` | L175-219 |
| `src/views/music/ArtistView.vue` | L142-199 |
| `src/views/playlists/PlaylistView.vue` | L98-144 |
| `src/views/playlists/PlaylistSingle.vue` | L420-475 |
| `src/composables/useAlbumsData.js` | L25-576 |
| `src/views/playlists/PlaylistManagementView.vue` | L381-447 |
| `src/views/playlists/PlaylistSingle.vue` | L166-214 |
| `src/views/playlists/PlaylistSingle.vue` | L44 |
| `src/views/playlists/PlaylistSingle.vue` | L524-558 |
| `src/views/playlists/PlaylistSingle.vue` | L356-424 |
| `src/views/music/ArtistView.vue` | L101-148 |

</details>
</tool-use>

---

Now let me look at the cache utility functions to understand how caching works:


---

<tool-use data-tool-type="read" data-tool-name="read_file">
<details><summary>Tool use: **read_file** • Read file: src/utils/cache.js</summary>

</details>
</tool-use>

---

Now let me look at the AlbumItem component to see how it handles processing and what events it emits:


---

<tool-use data-tool-type="read" data-tool-name="read_file">
<details><summary>Tool use: **read_file** • Read file: src/components/AlbumItem.vue</summary>

</details>
</tool-use>

---

Let me continue reading the AlbumItem component to see the processing buttons:


---

<tool-use data-tool-type="read" data-tool-name="read_file">
<details><summary>Tool use: **read_file** • Read file: src/components/AlbumItem.vue</summary>

</details>
</tool-use>

---

Now let me look at the PlaylistView to see how it handles cache invalidation:


---

<tool-use data-tool-type="read" data-tool-name="read_file">
<details><summary>Tool use: **read_file** • Read file: src/views/playlists/PlaylistView.vue</summary>

</details>
</tool-use>

---

Let me continue reading the PlaylistView to see the cache handling:


---

<tool-use data-tool-type="read" data-tool-name="read_file">
<details><summary>Tool use: **read_file** • Read file: src/views/playlists/PlaylistView.vue</summary>

</details>
</tool-use>

---

Now I understand the issue. The problem is that when you process an album from a playlist (using the Yes/No buttons), the cache is cleared for that specific playlist page, but the main PlaylistView cache (which shows the playlist summaries with track counts) is not being invalidated. This means when you navigate back to the PlaylistView, it still shows the old track counts.

Let me look at the PlaylistItem component to see how it displays the track counts:


---

<tool-use data-tool-type="read" data-tool-name="read_file">
<details><summary>Tool use: **read_file** • Read file: src/components/PlaylistItem.vue</summary>

</details>
</tool-use>

---

Perfect! Now I can see the issue clearly. The PlaylistItem component displays `playlist.tracks.total` which comes from the cached playlist summaries in PlaylistView. When an album is processed and removed from a playlist, the PlaylistSingle view clears its own cache, but the PlaylistView cache (which contains the track counts) is not being invalidated.

The solution is to add a mechanism to invalidate the PlaylistView cache when albums are processed. Here are a few approaches we can take:

1. **Event-based approach**: Use a global event system to notify PlaylistView when albums are processed
2. **Cache key invalidation**: Clear the PlaylistView cache from PlaylistSingle when processing albums
3. **Reactive approach**: Make the cache system more reactive to data changes

Let me implement the cache key invalidation approach, which is the most straightforward:


---

<tool-use data-tool-type="read" data-tool-name="read_file">
<details><summary>Tool use: **read_file** • Read file: src/views/playlists/PlaylistSingle.vue</summary>

</details>
</tool-use>

---

Now I need to modify the `handleProcessAlbum` function to also clear the PlaylistView cache. Let me create a utility function to clear the playlist summaries cache and call it from the processing function:

```javascript:src/views/playlists/PlaylistSingle.vue
// ... existing code ...

async function handleProcessAlbum({ album, action }) {
  if (action !== 'yes' && action !== 'no') return;
  
  try {
    spotifyApiError.value = null;
    successMessage.value = '';
    processingAlbum.value = album.id;
    
    // Get the current playlist data
    const currentPlaylistData = playlistDoc.value?.data();
    
    let targetPlaylistId, targetPlaylistData, targetSpotifyPlaylistId;
    
    if (action === 'yes') {
      if (!currentPlaylistData?.nextStagePlaylistId) {
        throw new Error('No next stage playlist configured for this source playlist');
      }
      
      // Fetch the target playlist document
      const targetPlaylistDoc = await getDoc(doc(db, 'playlists', currentPlaylistData.nextStagePlaylistId));
      if (!targetPlaylistDoc.exists()) {
        throw new Error('Target playlist not found');
      }
      
      targetPlaylistData = targetPlaylistDoc.data();
      targetSpotifyPlaylistId = targetPlaylistData.playlistId;
      
    } else if (action === 'no') {
      if (!currentPlaylistData?.terminationPlaylistId) {
        throw new Error('No termination playlist configured for this source playlist');
      }
      
      // Fetch the termination playlist document
      const terminationPlaylistDoc = await getDoc(doc(db, 'playlists', currentPlaylistData.terminationPlaylistId));
      if (!terminationPlaylistDoc.exists()) {
        throw new Error('Termination playlist not found');
      }
      
      targetPlaylistData = terminationPlaylistDoc.data();
      targetSpotifyPlaylistId = targetPlaylistData.playlistId;
    }
    
    // 1. Remove album from current playlist
    await removeFromSpotify(id.value, album);
    await removeAlbumFromPlaylist(album.id, id.value);
    
    // 2. Add album to target Spotify playlist
    await addAlbumToPlaylist(targetSpotifyPlaylistId, album.id);
    
    // 3. Add album to target playlist in Firebase collection
    await addAlbumToCollection({
      album: album,
      playlistId: targetSpotifyPlaylistId,
      playlistData: targetPlaylistData,
      spotifyAddedAt: new Date()
    });
    
    const actionText = action === 'yes' ? 'moved to next stage' : 'terminated';
    successMessage.value = `"${album.name}" processed and ${actionText} successfully!`;
    
    // Clear cache and reload the playlist to reflect the changes
    await handleClearCache();
    
    // Also clear the PlaylistView cache to update track counts
    if (user.value) {
      const playlistViewCacheKey = `playlist_summaries_${user.value.uid}`;
      await clearCache(playlistViewCacheKey);
    }
    
  } catch (err) {
    console.error('Error processing album:', err);
    spotifyApiError.value = err.message || 'Failed to process album';
  } finally {
    processingAlbum.value = null;
  }
};
```

I should also update the `handleRemoveAlbum` function to clear the PlaylistView cache:

```javascript:src/views/playlists/PlaylistSingle.vue
// ... existing code ...

const handleRemoveAlbum = async (album) => {
  if (!confirm(`Are you sure you want to remove "${album.name}" from this playlist?`)) {
    return;
  }
  
  try {
    spotifyApiError.value = null;
    successMessage.value = '';
    
    // Remove from Spotify playlist
    await removeFromSpotify(id.value, album);
    
    // Remove from Firebase collection
    await removeAlbumFromPlaylist(album.id, id.value);
    
    successMessage.value = `"${album.name}" removed from playlist and collection successfully!`;
    
    // Clear cache and reload the playlist to reflect the removal
    await handleClearCache();
    
    // Also clear the PlaylistView cache to update track counts
    if (user.value) {
      const playlistViewCacheKey = `playlist_summaries_${user.value.uid}`;
      await clearCache(playlistViewCacheKey);
    }
    
  } catch (err) {
    console.error('Error removing album:', err);
    spotifyApiError.value = err.message || 'Failed to remove album from playlist';
  }
};
```

And also update the `handleAddAlbum` function:

```javascript:src/views/playlists/PlaylistSingle.vue
// ... existing code ...

const handleAddAlbum = async () => {
  try {
    spotifyApiError.value = null;
    successMessage.value = '';
    
    if (!selectedAlbum.value) {
      throw new Error('Please select an album first');
    }
    
    // Add album to Spotify playlist
    await addAlbumToPlaylist(id.value, selectedAlbum.value.id);
    
    // Add album to Firebase collection
    await addAlbumToCollection({
      album: selectedAlbum.value,
      playlistId: id.value,
      playlistData: playlistDoc.value?.data(),
      spotifyAddedAt: new Date()
    });
    
    successMessage.value = `"${selectedAlbum.value.name}" added to playlist and collection successfully!`;
    
    // Reset form
    selectedAlbum.value = null;
    
    // Clear cache and reload the playlist to show the new album
    await handleClearCache();
    
    // Also clear the PlaylistView cache to update track counts
    if (user.value) {
      const playlistViewCacheKey = `playlist_summaries_${user.value.uid}`;
      await clearCache(playlistViewCacheKey);
    }
    
  } catch (err) {
    console.error('Error adding album:', err);
    spotifyApiError.value = err.message || 'Failed to add album to playlist';
  }
};
```

Let me implement these changes:


---

<tool-use data-tool-type="read" data-tool-name="read_file">
<details><summary>Tool use: **read_file** • Read file: src/views/playlists/PlaylistSingle.vue</summary>

</details>
</tool-use>

---

<tool-use data-tool-type="read" data-tool-name="read_file">
<details><summary>Tool use: **read_file** • Read file: src/views/playlists/PlaylistSingle.vue</summary>

</details>
</tool-use>

---

Now I'll implement the changes to clear the PlaylistView cache when albums are processed, added, or removed:

```javascript:src/views/playlists/PlaylistSingle.vue
// ... existing code ...

const handleAddAlbum = async () => {
  try {
    spotifyApiError.value = null;
    successMessage.value = '';
    
    if (!selectedAlbum.value) {
      throw new Error('Please select an album first');
    }
    
    // Add album to Spotify playlist
    await addAlbumToPlaylist(id.value, selectedAlbum.value.id);
    
    // Add album to Firebase collection
    await addAlbumToCollection({
      album: selectedAlbum.value,
      playlistId: id.value,
      playlistData: playlistDoc.value?.data(),
      spotifyAddedAt: new Date()
    });
    
    successMessage.value = `"${selectedAlbum.value.name}" added to playlist and collection successfully!`;
    
    // Reset form
    selectedAlbum.value = null;
    
    // Clear cache and reload the playlist to show the new album
    await handleClearCache();
    
    // Also clear the PlaylistView cache to update track counts
    if (user.value) {
      const playlistViewCacheKey = `playlist_summaries_${user.value.uid}`;
      await clearCache(playlistViewCacheKey);
    }
    
  } catch (err) {
    console.error('Error adding album:', err);
    spotifyApiError.value = err.message || 'Failed to add album to playlist';
  }
};

const handleRemoveAlbum = async (album) => {
  if (!confirm(`Are you sure you want to remove "${album.name}" from this playlist?`)) {
    return;
  }
  
  try {
    spotifyApiError.value = null;
    successMessage.value = '';
    
    // Remove from Spotify playlist
    await removeFromSpotify(id.value, album);
    
    // Remove from Firebase collection
    await removeAlbumFromPlaylist(album.id, id.value);
    
    successMessage.value = `"${album.name}" removed from playlist and collection successfully!`;
    
    // Clear cache and reload the playlist to reflect the removal
    await handleClearCache();
    
    // Also clear the PlaylistView cache to update track counts
    if (user.value) {
      const playlistViewCacheKey = `playlist_summaries_${user.value.uid}`;
      await clearCache(playlistViewCacheKey);
    }
    
  } catch (err) {
    console.error('Error removing album:', err);
    spotifyApiError.value = err.message || 'Failed to remove album from playlist';
  }
};

const handleProcessAlbum = async ({ album, action }) => {
  if (action !== 'yes' && action !== 'no') return;
  
  try {
    spotifyApiError.value = null;
    successMessage.value = '';
    processingAlbum.value = album.id;
    
    // Get the current playlist data
    const currentPlaylistData = playlistDoc.value?.data();
    
    let targetPlaylistId, targetPlaylistData, targetSpotifyPlaylistId;
    
    if (action === 'yes') {
      if (!currentPlaylistData?.nextStagePlaylistId) {
        throw new Error('No next stage playlist configured for this source playlist');
      }
      
      // Fetch the target playlist document
      const targetPlaylistDoc = await getDoc(doc(db, 'playlists', currentPlaylistData.nextStagePlaylistId));
      if (!targetPlaylistDoc.exists()) {
        throw new Error('Target playlist not found');
      }
      
      targetPlaylistData = targetPlaylistDoc.data();
      targetSpotifyPlaylistId = targetPlaylistData.playlistId;
      
    } else if (action === 'no') {
      if (!currentPlaylistData?.terminationPlaylistId) {
        throw new Error('No termination playlist configured for this source playlist');
      }
      
      // Fetch the termination playlist document
      const terminationPlaylistDoc = await getDoc(doc(db, 'playlists', currentPlaylistData.terminationPlaylistId));
      if (!terminationPlaylistDoc.exists()) {
        throw new Error('Termination playlist not found');
      }
      
      targetPlaylistData = terminationPlaylistDoc.data();
      targetSpotifyPlaylistId = targetPlaylistData.playlistId;
    }
    
    // 1. Remove album from current playlist
    await removeFromSpotify(id.value, album);
    await removeAlbumFromPlaylist(album.id, id.value);
    
    // 2. Add album to target Spotify playlist
    await addAlbumToPlaylist(targetSpotifyPlaylistId, album.id);
    
    // 3. Add album to target playlist in Firebase collection
    await addAlbumToCollection({
      album: album,
      playlistId: targetSpotifyPlaylistId,
      playlistData: targetPlaylistData,
      spotifyAddedAt: new Date()
    });
    
    const actionText = action === 'yes' ? 'moved to next stage' : 'terminated';
    successMessage.value = `"${album.name}" processed and ${actionText} successfully!`;
    
    // Clear cache and reload the playlist to reflect the changes
    await handleClearCache();
    
    // Also clear the PlaylistView cache to update track counts
    if (user.value) {
      const playlistViewCacheKey = `playlist_summaries_${user.value.uid}`;
      await clearCache(playlistViewCacheKey);
    }
    
  } catch (err) {
    console.error('Error processing album:', err);
    spotifyApiError.value = err.message || 'Failed to process album';
  } finally {
    processingAlbum.value = null;
  }
};
```

The changes I've made will:

1. **Clear the PlaylistView cache** whenever an album is processed (Yes/No buttons), added, or removed from a playlist
2. **Update track counts** in the PlaylistView automatically when you navigate back to it
3. **Maintain consistency** between the playlist page and the main playlist view

This ensures that when you process an album and then navigate back to the PlaylistView, the track counts will be accurate without needing to manually reload the page.

The key addition is this line in each of the three functions:
```javascript
// Also clear the PlaylistView cache to update track counts
if (user.value) {
  const playlistViewCacheKey = `playlist_summaries_${user.value.uid}`;
  await clearCache(playlistViewCacheKey);
}
```

This clears the cache that PlaylistView uses to display the playlist summaries with track counts, forcing it to fetch fresh data from Spotify when you next visit that page.

---

_**User (2025-08-15 16:41Z)**_

ok, do it

---

_**Agent (model default, mode Agent)**_

I'll implement the changes to clear the PlaylistView cache when albums are processed, added, or removed. Let me update the PlaylistSingle.vue file:


---

<tool-use data-tool-type="write" data-tool-name="search_replace">

<details><summary>Tool use: **search_replace** • Edit file: src/views/playlists/PlaylistSingle.vue</summary>

**Chunk 1**
Lines added: 6, lines removed: undefined

```diff
@@ -390,4 +390,10 @@
      await handleClearCache();
      
+     // Also clear the PlaylistView cache to update track counts
+     if (user.value) {
+       const playlistViewCacheKey = &#96;playlist_summaries_${user.value.uid}&#96;;
+       await clearCache(playlistViewCacheKey);
+     }
+     
    } catch (err) {
      console.error('Error adding album:', err);
```

</details>

</tool-use>

---

<tool-use data-tool-type="write" data-tool-name="search_replace">

<details><summary>Tool use: **search_replace** • Edit file: src/views/playlists/PlaylistSingle.vue</summary>

**Chunk 1**
Lines added: 6, lines removed: undefined

```diff
@@ -422,4 +422,10 @@
      await handleClearCache();
      
+     // Also clear the PlaylistView cache to update track counts
+     if (user.value) {
+       const playlistViewCacheKey = &#96;playlist_summaries_${user.value.uid}&#96;;
+       await clearCache(playlistViewCacheKey);
+     }
+     
    } catch (err) {
      console.error('Error removing album:', err);
```

</details>

</tool-use>

---

<tool-use data-tool-type="write" data-tool-name="search_replace">

<details><summary>Tool use: **search_replace** • Edit file: src/views/playlists/PlaylistSingle.vue</summary>

**Chunk 1**
Lines added: 6, lines removed: undefined

```diff
@@ -497,4 +497,10 @@
      await handleClearCache();
      
+     // Also clear the PlaylistView cache to update track counts
+     if (user.value) {
+       const playlistViewCacheKey = &#96;playlist_summaries_${user.value.uid}&#96;;
+       await clearCache(playlistViewCacheKey);
+     }
+     
    } catch (err) {
      console.error('Error processing album:', err);
```

</details>

</tool-use>

---

Perfect! I've successfully implemented the cache invalidation fix. Here's what the changes do:

## Summary of Changes

I've added cache invalidation for the PlaylistView in three key functions in `PlaylistSingle.vue`:

1. **`handleAddAlbum`** - When adding a new album to a playlist
2. **`handleRemoveAlbum`** - When removing an album from a playlist  
3. **`handleProcessAlbum`** - When processing an album (Yes/No buttons)

## How It Works

Each function now includes this additional code after clearing the local playlist cache:

```javascript
// Also clear the PlaylistView cache to update track counts
if (user.value) {
  const playlistViewCacheKey = `playlist_summaries_${user.value.uid}`;
  await clearCache(playlistViewCacheKey);
}
```

## What This Fixes

- **Before**: When you processed an album and navigated back to PlaylistView, the track counts were stale and required a manual reload
- **After**: The PlaylistView cache is automatically cleared when albums are processed, so track counts update immediately when you navigate back

Now when you process an album from a playlist using the Yes/No buttons, the PlaylistView will automatically show the updated track counts without requiring a manual reload!

---

